// Ori Standard Library - Prelude
//
// Auto-imported into every Ori program (like Rust's std::prelude).
// Provides core traits and utility functions.
//
// Note: Primitive types (int, float, bool, str, char, byte, void, Never)
// and generic types (Option<T>, Result<T,E>, Ordering) are built into the compiler.
// Collection syntax ([T], {K: V}) is also built-in.
//
// TODO: Once Phase 6 (Type Declarations) is complete, move type definitions here:
// - pub type Option<T> = Some(T) | None
// - pub type Result<T, E> = Ok(T) | Err(E)
// - pub type Ordering = Less | Equal | Greater
// - pub type Error = { message: str }
// =============================================================================
// Core Traits
// =============================================================================
// Equality comparison
pub trait Eq {
    @eq (self, other: Self) -> bool
}

// Ordering comparison
pub trait Comparable: Eq {
    @cmp (self, other: Self) -> Ordering
}

// Can be used as a map key or set element
pub trait Hashable: Eq {
    @hash (self) -> int
}

// Can be converted to a string representation
pub trait Printable {
    @to_string (self) -> str
}

// Can be explicitly copied
pub trait Clone {
    @clone (self) -> Self
}

// Has a default value
pub trait Default {
    @default () -> Self
}

// =============================================================================
// Operator Traits
// =============================================================================
//
// Operator traits enable user-defined types to support operator syntax.
// The compiler desugars operators to trait method calls.
// Primitives (int, float, etc.) have built-in implementations.

// Binary arithmetic: a + b -> a.add(rhs: b)
pub trait Add<Rhs = Self> {
    type Output = Self
    @add (self, rhs: Rhs) -> Self.Output
}

// Binary arithmetic: a - b -> a.subtract(rhs: b)
pub trait Sub<Rhs = Self> {
    type Output = Self
    @subtract (self, rhs: Rhs) -> Self.Output
}

// Binary arithmetic: a * b -> a.multiply(rhs: b)
pub trait Mul<Rhs = Self> {
    type Output = Self
    @multiply (self, rhs: Rhs) -> Self.Output
}

// Binary arithmetic: a / b -> a.divide(rhs: b)
pub trait Div<Rhs = Self> {
    type Output = Self
    @divide (self, rhs: Rhs) -> Self.Output
}

// Binary arithmetic: a div b -> a.floor_divide(rhs: b)
pub trait FloorDiv<Rhs = Self> {
    type Output = Self
    @floor_divide (self, rhs: Rhs) -> Self.Output
}

// Binary arithmetic: a % b -> a.remainder(rhs: b)
pub trait Rem<Rhs = Self> {
    type Output = Self
    @remainder (self, rhs: Rhs) -> Self.Output
}

// Unary negation: -a -> a.negate()
pub trait Neg {
    type Output = Self
    @negate (self) -> Self.Output
}

// Unary logical not: !a -> a.not()
pub trait Not {
    type Output = Self
    @not (self) -> Self.Output
}

// Unary bitwise not: ~a -> a.bit_not()
pub trait BitNot {
    type Output = Self
    @bit_not (self) -> Self.Output
}

// Bitwise and: a & b -> a.bit_and(rhs: b)
pub trait BitAnd<Rhs = Self> {
    type Output = Self
    @bit_and (self, rhs: Rhs) -> Self.Output
}

// Bitwise or: a | b -> a.bit_or(rhs: b)
pub trait BitOr<Rhs = Self> {
    type Output = Self
    @bit_or (self, rhs: Rhs) -> Self.Output
}

// Bitwise xor: a ^ b -> a.bit_xor(rhs: b)
pub trait BitXor<Rhs = Self> {
    type Output = Self
    @bit_xor (self, rhs: Rhs) -> Self.Output
}

// Left shift: a << b -> a.shift_left(rhs: b)
pub trait Shl<Rhs = int> {
    type Output = Self
    @shift_left (self, rhs: Rhs) -> Self.Output
}

// Right shift: a >> b -> a.shift_right(rhs: b)
pub trait Shr<Rhs = int> {
    type Output = Self
    @shift_right (self, rhs: Rhs) -> Self.Output
}

// =============================================================================
// Capability Traits
// =============================================================================
//
// Capabilities track effects and suspension. Functions must declare required
// capabilities with `uses`. See spec/14-capabilities.md.
//
// Marker capabilities (Async, Unsafe) have no methods.
// Effect capabilities (Http, FileSystem, etc.) define operations that may
// have side effects.
// Suspension marker - function may suspend (non-blocking I/O)
// No methods; presence indicates async behavior
pub trait Async {}

// Unsafe marker - function may perform unsafe operations (FFI, raw pointers)
// Required for extern functions and raw memory access
pub trait Unsafe {}

// HTTP client operations
// Implementations may suspend (use with `uses Http, Async` for non-blocking)
pub trait Http {
    @get (url: str) -> Result<str, Error>

    @post (url: str, body: str) -> Result<str, Error>

    @put (url: str, body: str) -> Result<str, Error>

    @delete (url: str) -> Result<str, Error>
}

// File system operations
// Implementations may suspend (use with `uses FileSystem, Async` for non-blocking)
pub trait FileSystem {
    @read (path: str) -> Result<str, Error>

    @write (path: str, content: str) -> Result<void, Error>

    @exists (path: str) -> bool

    @delete (path: str) -> Result<void, Error>
}

// Cache operations
// Implementations may suspend (use with `uses Cache, Async` for non-blocking)
pub trait Cache {
    @get (key: str) -> Option<str>

    @set (key: str, value: str) -> void

    @del (key: str) -> void
}

// Time operations (typically synchronous)
pub trait Clock {
    @now () -> int

    @today () -> str
}

// Random number generation (typically synchronous)
pub trait Random {
    @rand_int (min: int, max: int) -> int

    @rand_float () -> float
}

// Logging operations (typically synchronous)
pub trait Logger {
    @debug (msg: str) -> void

    @info (msg: str) -> void

    @warn (msg: str) -> void

    @error (msg: str) -> void
}

// Environment variable access (typically synchronous)
pub trait Env {
    @get (name: str) -> Option<str>
}

// =============================================================================
// Utility Functions
// =============================================================================
// Get the length of a list
pub @len (items: [int]) -> int = items.len()

// Check if a list is empty
pub @is_empty (items: [int]) -> bool = items.len() == 0

// Check if Option is Some
pub @is_some (opt: Option<int>) -> bool = match(opt,
    Some(_) -> true,
    None -> false,
)

// Check if Option is None
pub @is_none (opt: Option<int>) -> bool = match(opt,
    Some(_) -> false,
    None -> true,
)

// Check if Result is Ok
pub @is_ok (res: Result<int, str>) -> bool = match(res,
    Ok(_) -> true,
    Err(_) -> false,
)

// Check if Result is Err
pub @is_err (res: Result<int, str>) -> bool = match(res,
    Ok(_) -> false,
    Err(_) -> true,
)

// =============================================================================
// Assertions
// =============================================================================
// Assert that a condition is true
pub @assert (cond: bool) -> void = if !cond then panic(msg: "assertion failed")

// Assert that two values are equal
pub @assert_eq (actual: int, expected: int) -> void =
    if actual != expected then
        panic(msg: "assertion failed: " + str(actual) + " != " + str(expected))

// Assert that two values are not equal
pub @assert_ne (actual: int, unexpected: int) -> void =
    if actual == unexpected then panic(msg: "assertion failed: values are equal: " + str(actual))

// Assert that an Option is Some
pub @assert_some (opt: Option<int>) -> void =
    if is_none(opt: opt) then panic(msg: "assertion failed: expected Some, got None")

// Assert that an Option is None
pub @assert_none (opt: Option<int>) -> void =
    if is_some(opt: opt) then panic(msg: "assertion failed: expected None, got Some")

// Assert that a Result is Ok
pub @assert_ok (res: Result<int, str>) -> void =
    if is_err(res: res) then panic(msg: "assertion failed: expected Ok, got Err")

// Assert that a Result is Err
pub @assert_err (res: Result<int, str>) -> void =
    if is_ok(res: res) then panic(msg: "assertion failed: expected Err, got Ok")

// Assert that an expression panics
pub @assert_panics (f: () -> void) -> void = run(
    let result = catch(
        expr: f(),
    ),
    if is_ok(res: result) then panic(msg: "assertion failed: expected panic but succeeded"),
)

// Assert that an expression panics with a specific message
pub @assert_panics_with (f: () -> void, msg: str) -> void = run(
    let result = catch(
        expr: f(),
    ),
    match(result,
        Err(actual_msg) -> if actual_msg != msg then
            panic(msg: "assertion failed: expected panic with: " + msg + " but got: " + actual_msg),
        Ok(_) -> panic(msg: "assertion failed: expected panic with: " + msg + " but succeeded"),
    ),
)

// =============================================================================
// Comparison Functions
// =============================================================================
// Compare two integers
pub @compare (a: int, b: int) -> Ordering = run(
    if a < b then Less else if a > b then Greater else Equal,
)

// Get the minimum of two integers
pub @min (a: int, b: int) -> int = if a < b then a else b

// Get the maximum of two integers
pub @max (a: int, b: int) -> int = if a > b then a else b
