// Ori Standard Library - Prelude
//
// Auto-imported into every Ori program (like Rust's std::prelude).
// Provides core traits and utility functions.
//
// Note: Primitive types (int, float, bool, str, char, byte, void, Never)
// and generic types (Option<T>, Result<T,E>, Ordering) are built into the compiler.
// Collection syntax ([T], {K: V}) is also built-in.
//
// TODO: Once Phase 6 (Type Declarations) is complete, move type definitions here:
// - pub type Option<T> = Some(T) | None
// - pub type Result<T, E> = Ok(T) | Err(E)
// - pub type Ordering = Less | Equal | Greater
// - pub type Error = { message: str }
// =============================================================================
// Core Traits
// =============================================================================
// Equality comparison
pub trait Eq {
    @eq (self, other: Self) -> bool
}

// Ordering comparison
pub trait Comparable: Eq {
    @compare (self, other: Self) -> Ordering
}

// Can be used as a map key or set element
pub trait Hashable: Eq {
    @hash (self) -> int
}

// Can be converted to a string representation
pub trait Printable {
    @to_str (self) -> str
}

// Supports custom formatting with format specifications (spec ยง3.16)
// All Printable types get a blanket impl that falls back to to_str()
//
// Built-in format types (registered by the compiler, like Ordering):
// - pub type Alignment = Left | Center | Right
// - pub type Sign = Plus | Minus | Space
// - pub type FormatType = Binary | Octal | Hex | HexUpper | Exp | ExpUpper | Fixed | Percent
// - pub type FormatSpec = { fill: Option<char>, align: Option<Alignment>,
//     sign: Option<Sign>, width: Option<int>, precision: Option<int>,
//     format_type: Option<FormatType> }
pub trait Formattable {
    @format (self, spec: FormatSpec) -> str
}

// Developer-facing structural representation
pub trait Debug {
    @debug (self) -> str
}

// Can be explicitly copied
pub trait Clone {
    @clone (self) -> Self
}

// Has a default value
pub trait Default {
    @default () -> Self
}

// Error trace propagation (spec ยง3.13)
// Implemented by Error type; Result delegates to inner Error.
// The ? operator auto-injects trace entries as errors propagate.
pub trait Traceable {
    @with_trace (self, entry: TraceEntry) -> Self
    @trace (self) -> str
    @trace_entries (self) -> [TraceEntry]
    @has_trace (self) -> bool
}

// Types with a countable length (collections, strings, tuples, ranges)
pub trait Len {
    @len (self) -> int
}

// =============================================================================
// Iteration Traits
// =============================================================================
//
// Iteration traits enable generic programming over sequences. Built-in types
// (list, map, set, str, range) have hardcoded implementations. User types
// can implement these traits to participate in for loops and iterator chains.

// Lazy, functional iterator producing elements of type T.
// next() returns the next element (if any) and the updated iterator state.
pub trait Iterator<T> {
    @next (self) -> (Option<T>, Self)
}

// Iterator that can also produce elements from the back.
// Enables rev(), last(), rfind(), rfold().
pub trait DoubleEndedIterator<T>: Iterator {
    @next_back (self) -> (Option<T>, Self)
}

// Type that can produce an iterator over its elements.
// Enables for loops: `for x in collection do ...`
pub trait Iterable<T> {
    @iter (self) -> Iterator<T>
}

// Type that can be constructed from an iterator.
// Enables .collect(): `iter.collect()` with type-directed inference.
pub trait Collect<T> {
    @from_iter (iter: Iterator<T>) -> Self
}

// =============================================================================
// Operator Traits
// =============================================================================
//
// Operator traits enable user-defined types to support operator syntax.
// The compiler desugars operators to trait method calls.
// Primitives (int, float, etc.) have built-in implementations.
// Binary arithmetic: a + b -> a.add(rhs: b)
pub trait Add<Rhs = Self> {
    type Output

    @add (self, rhs: Rhs) -> Self.Output
}

// Binary arithmetic: a - b -> a.subtract(rhs: b)
pub trait Sub<Rhs = Self> {
    type Output

    @subtract (self, rhs: Rhs) -> Self.Output
}

// Binary arithmetic: a * b -> a.multiply(rhs: b)
pub trait Mul<Rhs = Self> {
    type Output

    @multiply (self, rhs: Rhs) -> Self.Output
}

// Binary arithmetic: a / b -> a.divide(rhs: b)
pub trait Div<Rhs = Self> {
    type Output

    @divide (self, rhs: Rhs) -> Self.Output
}

// Binary arithmetic: a div b -> a.floor_divide(rhs: b)
pub trait FloorDiv<Rhs = Self> {
    type Output

    @floor_divide (self, rhs: Rhs) -> Self.Output
}

// Binary arithmetic: a % b -> a.remainder(rhs: b)
pub trait Rem<Rhs = Self> {
    type Output

    @remainder (self, rhs: Rhs) -> Self.Output
}

// Unary negation: -a -> a.negate()
pub trait Neg {
    type Output

    @negate (self) -> Self.Output
}

// Unary logical not: !a -> a.not()
pub trait Not {
    type Output

    @not (self) -> Self.Output
}

// Unary bitwise not: ~a -> a.bit_not()
pub trait BitNot {
    type Output

    @bit_not (self) -> Self.Output
}

// Bitwise and: a & b -> a.bit_and(rhs: b)
pub trait BitAnd<Rhs = Self> {
    type Output

    @bit_and (self, rhs: Rhs) -> Self.Output
}

// Bitwise or: a | b -> a.bit_or(rhs: b)
pub trait BitOr<Rhs = Self> {
    type Output

    @bit_or (self, rhs: Rhs) -> Self.Output
}

// Bitwise xor: a ^ b -> a.bit_xor(rhs: b)
pub trait BitXor<Rhs = Self> {
    type Output

    @bit_xor (self, rhs: Rhs) -> Self.Output
}

// Left shift: a << b -> a.shift_left(rhs: b)
pub trait Shl<Rhs = int> {
    type Output

    @shift_left (self, rhs: Rhs) -> Self.Output
}

// Right shift: a >> b -> a.shift_right(rhs: b)
pub trait Shr<Rhs = int> {
    type Output

    @shift_right (self, rhs: Rhs) -> Self.Output
}

// Subscript access: x[k] -> x.index(key: k)
pub trait Index<Key, Value> {
    @index (self, key: Key) -> Value
}

// =============================================================================
// Conversion Traits
// =============================================================================
//
// Explicit, lossless type conversion via `.into()`.
// Distinct from `as`/`as?` (built-in primitive casts).
// No blanket identity impl. No auto-chaining.
// Standard impls: str -> Error, int -> float, Set<T> -> [T]

// Explicit type conversion
pub trait Into<T> {
    @into (self) -> T
}

// =============================================================================
// Capability Traits
// =============================================================================
//
// Capabilities track effects and suspension. Functions must declare required
// capabilities with `uses`. See spec/14-capabilities.md.
//
// Marker capabilities (Async, Unsafe) have no methods.
// Effect capabilities (Http, FileSystem, etc.) define operations that may
// have side effects.
// Suspension marker - function may suspend (non-blocking I/O)
// No methods; presence indicates async behavior
pub trait Async {}

// Unsafe marker - function may perform unsafe operations (FFI, raw pointers)
// Required for extern functions and raw memory access
pub trait Unsafe {}

// HTTP client operations
// Implementations may suspend (use with `uses Http, Async` for non-blocking)
pub trait Http {
    @get (url: str) -> Result<str, Error>

    @post (url: str, body: str) -> Result<str, Error>

    @put (url: str, body: str) -> Result<str, Error>

    @delete (url: str) -> Result<str, Error>
}

// File system operations
// Implementations may suspend (use with `uses FileSystem, Async` for non-blocking)
pub trait FileSystem {
    @read (path: str) -> Result<str, Error>

    @write (path: str, content: str) -> Result<void, Error>

    @exists (path: str) -> bool

    @delete (path: str) -> Result<void, Error>
}

// Cache operations
// Implementations may suspend (use with `uses Cache, Async` for non-blocking)
pub trait Cache {
    @get (key: str) -> Option<str>

    @set (key: str, value: str) -> void

    @del (key: str) -> void
}

// Time operations (typically synchronous)
pub trait Clock {
    @now () -> int

    @today () -> str
}

// Random number generation (typically synchronous)
pub trait Random {
    @rand_int (min: int, max: int) -> int

    @rand_float () -> float
}

// Logging operations (typically synchronous)
pub trait Logger {
    @debug (msg: str) -> void

    @info (msg: str) -> void

    @warn (msg: str) -> void

    @error (msg: str) -> void
}

// Environment variable access (typically synchronous)
pub trait Env {
    @get (name: str) -> Option<str>
}

// =============================================================================
// Utility Functions
// =============================================================================
// Get the length of any collection implementing Len
pub @len<T: Len> (collection: T) -> int = collection.len();

// Check if a list is empty
pub @is_empty<T> (collection: [T]) -> bool = collection.len() == 0;

// Check if Option is Some
pub @is_some<T> (opt: Option<T>) -> bool = match opt {
    Some(_) -> true,
    None -> false
}

// Check if Option is None
pub @is_none<T> (opt: Option<T>) -> bool = match opt {
    Some(_) -> false,
    None -> true
}

// Check if Result is Ok
pub @is_ok<T, E> (r: Result<T, E>) -> bool = match r {
    Ok(_) -> true,
    Err(_) -> false
}

// Check if Result is Err
pub @is_err<T, E> (r: Result<T, E>) -> bool = match r {
    Ok(_) -> false,
    Err(_) -> true
}

// =============================================================================
// Comparison Functions
// =============================================================================
// Compare two integers
pub @compare (a: int, b: int) -> Ordering = {
    if a < b then Less else if a > b then Greater else Equal
}

// Get the minimum of two integers
pub @min (a: int, b: int) -> int = if a < b then a else b;

// Get the maximum of two integers
pub @max (a: int, b: int) -> int = if a > b then a else b;

// Combine two hash values using the Boost hash combine algorithm.
// Uses wrapping arithmetic (built-in) since hash computation overflows by design.
pub @hash_combine (seed: int, value: int) -> int
