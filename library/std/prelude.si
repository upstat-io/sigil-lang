// Sigil Standard Library - Prelude
//
// Auto-imported into every Sigil program (like Rust's std::prelude).
// Provides core traits and utility functions.
//
// Note: Primitive types (int, float, bool, str, char, byte, void, Never)
// and generic types (Option<T>, Result<T,E>, Ordering) are built into the compiler.
// Collection syntax ([T], {K: V}) is also built-in.
//
// TODO: Once Phase 6 (Type Declarations) is complete, move type definitions here:
// - pub type Option<T> = Some(T) | None
// - pub type Result<T, E> = Ok(T) | Err(E)
// - pub type Ordering = Less | Equal | Greater
// - pub type Error = { message: str }

// =============================================================================
// Core Traits
// =============================================================================

// Equality comparison
pub trait Eq {
    @eq (self, other: Self) -> bool
}

// Ordering comparison
pub trait Comparable: Eq {
    @cmp (self, other: Self) -> Ordering
}

// Can be used as a map key or set element
pub trait Hashable: Eq {
    @hash (self) -> int
}

// Can be converted to a string representation
pub trait Printable {
    @to_string (self) -> str
}

// Can be explicitly copied
pub trait Clone {
    @clone (self) -> Self
}

// Has a default value
pub trait Default {
    @default () -> Self
}

// =============================================================================
// Capability Traits
// =============================================================================
//
// Capabilities track effects and suspension. Functions must declare required
// capabilities with `uses`. See spec/14-capabilities.md.
//
// Marker capabilities (Async, Unsafe) have no methods.
// Effect capabilities (Http, FileSystem, etc.) define operations that may
// have side effects.

// Suspension marker - function may suspend (non-blocking I/O)
// No methods; presence indicates async behavior
pub trait Async {}

// Unsafe marker - function may perform unsafe operations (FFI, raw pointers)
// Required for extern functions and raw memory access
pub trait Unsafe {}

// HTTP client operations
// Implementations may suspend (use with `uses Http, Async` for non-blocking)
pub trait Http {
    @get (url: str) -> Result<str, Error>
    @post (url: str, body: str) -> Result<str, Error>
    @put (url: str, body: str) -> Result<str, Error>
    @delete (url: str) -> Result<str, Error>
}

// File system operations
// Implementations may suspend (use with `uses FileSystem, Async` for non-blocking)
pub trait FileSystem {
    @read (path: str) -> Result<str, Error>
    @write (path: str, content: str) -> Result<void, Error>
    @exists (path: str) -> bool
    @delete (path: str) -> Result<void, Error>
}

// Cache operations
// Implementations may suspend (use with `uses Cache, Async` for non-blocking)
pub trait Cache {
    @get (key: str) -> Option<str>
    @set (key: str, value: str) -> void
    @del (key: str) -> void
}

// Time operations (typically synchronous)
pub trait Clock {
    @now () -> int
    @today () -> str
}

// Random number generation (typically synchronous)
pub trait Random {
    @rand_int (min: int, max: int) -> int
    @rand_float () -> float
}

// Logging operations (typically synchronous)
pub trait Logger {
    @debug (msg: str) -> void
    @info (msg: str) -> void
    @warn (msg: str) -> void
    @error (msg: str) -> void
}

// Environment variable access (typically synchronous)
pub trait Env {
    @get (name: str) -> Option<str>
}

// =============================================================================
// Utility Functions
// =============================================================================

// Get the length of a list
pub @len (items: [int]) -> int = items.len()

// Check if a list is empty
pub @is_empty (items: [int]) -> bool = items.len() == 0

// Check if Option is Some
pub @is_some (opt: Option<int>) -> bool = match(opt, Some(_) -> true, None -> false)

// Check if Option is None
pub @is_none (opt: Option<int>) -> bool = match(opt, Some(_) -> false, None -> true)

// Check if Result is Ok
pub @is_ok (res: Result<int, str>) -> bool = match(res, Ok(_) -> true, Err(_) -> false)

// Check if Result is Err
pub @is_err (res: Result<int, str>) -> bool = match(res, Ok(_) -> false, Err(_) -> true)

// =============================================================================
// Assertions
// =============================================================================

// Assert that a condition is true
pub @assert (cond: bool) -> void = if cond then () else panic(msg: "assertion failed")

// Assert that two values are equal
pub @assert_eq (actual: int, expected: int) -> void = run(
    if actual == expected then ()
    else panic(msg: "assertion failed: " + str(actual) + " != " + str(expected))
)

// Assert that two values are not equal
pub @assert_ne (actual: int, unexpected: int) -> void = run(
    if actual != unexpected then ()
    else panic(msg: "assertion failed: values are equal: " + str(actual))
)

// Assert that an Option is Some
pub @assert_some (opt: Option<int>) -> void = run(
    if is_some(opt: opt) then ()
    else panic(msg: "assertion failed: expected Some, got None")
)

// Assert that an Option is None
pub @assert_none (opt: Option<int>) -> void = run(
    if is_none(opt: opt) then ()
    else panic(msg: "assertion failed: expected None, got Some")
)

// Assert that a Result is Ok
pub @assert_ok (res: Result<int, str>) -> void = run(
    if is_ok(res: res) then ()
    else panic(msg: "assertion failed: expected Ok, got Err")
)

// Assert that a Result is Err
pub @assert_err (res: Result<int, str>) -> void = run(
    if is_err(res: res) then ()
    else panic(msg: "assertion failed: expected Err, got Ok")
)

// =============================================================================
// Comparison Functions
// =============================================================================

// Compare two integers
pub @compare (a: int, b: int) -> Ordering = run(
    if a < b then Less
    else if a > b then Greater
    else Equal
)

// Get the minimum of two integers
pub @min (a: int, b: int) -> int = if a < b then a else b

// Get the maximum of two integers
pub @max (a: int, b: int) -> int = if a > b then a else b
