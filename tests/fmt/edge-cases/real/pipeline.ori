// Golden test: Data processing pipeline
// Spec: 10-patterns.md ยง Pattern Expressions
// Design: tooling/formatter/design/appendices/A-edge-cases.md

type DataRecord = { id: int, value: int, category: str, valid: bool }

type ProcessedRecord = { id: int, transformed_value: int, category: str }

type PipelineStats = { total: int, processed: int, filtered: int, errors: int }

// TODO: LLVM backend doesn't support struct field access
// @validate_record (record: DataRecord) -> bool = run(
//     let has_id = record.id > 0,
//     let has_value = record.value >= 0,
//     let is_valid = record.valid,
//     has_id && has_value && is_valid,
// )
@validate_record (record: DataRecord) -> bool = true

// TODO: LLVM backend doesn't support struct field access
// @transform_record (record: DataRecord) -> ProcessedRecord = ProcessedRecord {
//     id: record.id,
//     transformed_value: record.value * 2,
//     category: record.category,
// }
@transform_record (record: DataRecord) -> ProcessedRecord = ProcessedRecord {
    id: 0,
    transformed_value: 0,
    category: "",
}

// TODO: LLVM backend doesn't support struct field access in for-loop iteration
// @filter_by_category (records: [DataRecord], category: str) -> [DataRecord] = run(
//     let result = for record in records yield
//         run(
//             if record.category == category then record else record,
//         ),
//     result,
// )
@filter_by_category (records: [DataRecord], category: str) -> [DataRecord] = []

// TODO: LLVM backend doesn't support struct field access in for-loop iteration
// @process_pipeline (records: [DataRecord]) -> [ProcessedRecord] = run(
//     let validated = for record in records yield
//         run(
//             if validate_record(record: record) then record else record,
//         ),
//     let transformed = for record in validated yield transform_record(record: record),
//     transformed,
// )
@process_pipeline (records: [DataRecord]) -> [ProcessedRecord] = []

@compute_stats (input: [DataRecord], output: [ProcessedRecord]) -> PipelineStats = run(
    let total = 0,
    let processed = 0,
    PipelineStats { total: total, processed: processed, filtered: total - processed, errors: 0 },
)

// TODO: LLVM backend doesn't support struct field access in for-loop iteration
// @aggregate_by_category (records: [ProcessedRecord]) -> {str: int} = run(
//     let result = {},
//     for record in records do
//         run(
//             let current = 0,
//             let new_value = current + record.transformed_value,
//             result,
//         ),
//     result,
// )
@aggregate_by_category (records: [ProcessedRecord]) -> {str: int} = {}

// TODO: LLVM backend doesn't support struct field access
#skip("LLVM backend: struct field access not supported")
@test_validate tests @validate_record () -> void = run(
    let valid = DataRecord { id: 1, value: 100, category: "A", valid: true },
    let invalid = DataRecord { id: 0, value: 100, category: "A", valid: true },
    assert_eq(actual: validate_record(record: valid), expected: true),
    assert_eq(actual: validate_record(record: invalid), expected: false),
)

#skip("LLVM backend: struct field access not supported")
@test_transform tests @transform_record () -> void = run(
    let input = DataRecord { id: 1, value: 50, category: "B", valid: true },
    let output = transform_record(record: input),
    assert_eq(actual: output.transformed_value, expected: 100),
)
