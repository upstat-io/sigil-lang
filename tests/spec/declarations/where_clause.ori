// Spec: 08-declarations.md ยง Where Clause
// Tests for where clauses (grammar.ebnf ยง where_clause)

use std.testing { assert, assert_eq }

// =============================================================================
// Basic Where Clause - Single Constraint
// =============================================================================

@with_eq<T> (x: T) -> T where T: Eq = x

@test_where_eq tests @with_eq () -> void = run(
    assert_eq(actual: with_eq(x: 42), expected: 42),
    assert_eq(actual: with_eq(x: "hello"), expected: "hello"),
)

@with_clone<T> (x: T) -> T where T: Clone = x.clone()

@test_where_clone tests @with_clone () -> void = run(
    assert_eq(actual: with_clone(x: 42), expected: 42),
    assert_eq(actual: with_clone(x: "test"), expected: "test"),
)

// =============================================================================
// Multiple Constraints on Same Type Parameter
// =============================================================================

@with_eq_and_hash<T> (x: T, y: T) -> bool where T: Eq, T: Hashable =
    x == y && x.hash() == y.hash()

@test_multiple_constraints tests @with_eq_and_hash () -> void = run(
    assert(cond: with_eq_and_hash(x: 42, y: 42)),
    assert(cond: !with_eq_and_hash(x: 42, y: 43)),
)

@with_three_bounds<T> (x: T) -> int where T: Eq, T: Clone, T: Hashable = x.hash()

@test_three_constraints tests @with_three_bounds () -> void = run(
    let h = with_three_bounds(x: 42),
    assert(cond: h != 0 || h == 0),  // Hash returned something
)

// =============================================================================
// Constraints on Multiple Type Parameters
// =============================================================================

@compare_both<A, B> (a: A, b: B) -> bool where A: Eq, B: Eq =
    a == a && b == b

@test_multi_param_constraints tests @compare_both () -> void = run(
    assert(cond: compare_both(a: 42, b: "hello")),
)

@clone_pair<A, B> (a: A, b: B) -> (A, B) where A: Clone, B: Clone =
    (a.clone(), b.clone())

@test_multi_param_clone tests @clone_pair () -> void = run(
    let (x, y) = clone_pair(a: 10, b: 20),
    assert_eq(actual: x, expected: 10),
    assert_eq(actual: y, expected: 20),
)

// =============================================================================
// Complex Multi-Parameter Constraints
// =============================================================================

@complex_where<T, U, V> (t: T, u: U, v: V) -> bool where T: Eq + Clone, U: Hashable, V: Printable = t == t && u.hash() != 0 || true

@test_complex_multi tests @complex_where () -> void = run(
    assert(cond: complex_where(t: 42, u: 10, v: "hello")),
)

// =============================================================================
// Where Clause with Combined Bounds
// =============================================================================

@eq_and_clone<T> (x: T) -> bool where T: Eq + Clone = x == x.clone()

@test_combined_bounds tests @eq_and_clone () -> void = run(
    assert(cond: eq_and_clone(x: 42)),
    assert(cond: eq_and_clone(x: "hello")),
)

// =============================================================================
// Where Clause on Generic Type Definitions
// =============================================================================

type Wrapper<T> = { value: T }

@wrap_eq<T> (x: T) -> Wrapper<T> where T: Eq = Wrapper { value: x }

@test_where_on_return tests @wrap_eq () -> void = run(
    let w = wrap_eq(x: 42),
    assert_eq(actual: w.value, expected: 42),
)

// =============================================================================
// Where Clause with Comparable
// =============================================================================

@max_where<T> (a: T, b: T) -> T where T: Comparable =
    if a.compare(other: b) == Greater then a else b

#skip("Ordering type does not implement Eq for == comparison")
@test_where_comparable tests @max_where () -> void = run(
    assert_eq(actual: max_where(a: 10, b: 20), expected: 20),
    assert_eq(actual: max_where(a: 50, b: 30), expected: 50),
)

@min_where<T> (a: T, b: T) -> T where T: Comparable =
    if a.compare(other: b) == Less then a else b

#skip("Ordering type does not implement Eq for == comparison")
@test_where_min tests @min_where () -> void = run(
    assert_eq(actual: min_where(a: 10, b: 20), expected: 10),
    assert_eq(actual: min_where(a: 50, b: 30), expected: 30),
)

// =============================================================================
// Where Clause with Printable
// =============================================================================

@stringify_where<T> (x: T) -> str where T: Printable = x.to_str()

@test_where_printable tests @stringify_where () -> void = run(
    assert_eq(actual: stringify_where(x: 42), expected: "42"),
    assert_eq(actual: stringify_where(x: true), expected: "true"),
)

// =============================================================================
// Const Generic Constraints in Where
// =============================================================================
// Per spec: "Const Bounds: comparison, logical, arithmetic"
//
// STATUS: Lexer [OK], Parser [BROKEN] - const generic where bounds not supported
// Parser does not recognize `where N > 0` or `where MIN >= 0, MAX > MIN`.

// SKIP: Const generic where bounds not implemented
// @positive_array<$N: int> () -> [int] where N > 0 = for i in 0..N yield i
@positive_array () -> [int] = for i in 0..5 yield i

#skip("const generic where bounds not implemented")
@test_const_where tests @positive_array () -> void = run(
    let arr: [int] = positive_array(),
    assert_eq(actual: len(collection: arr), expected: 5),
)

// SKIP: Multiple const constraints not implemented
// @bounded_range<$MIN: int, $MAX: int> () -> [int] where MIN >= 0, MAX > MIN = ...
@bounded_range () -> [int] = for i in 2..5 yield i

#skip("multiple const constraints not implemented")
@test_multi_const_where tests @bounded_range () -> void = run(
    let arr: [int] = bounded_range(),
    assert_eq(actual: len(collection: arr), expected: 3),
)

// =============================================================================
// Where Clause on Trait Impl
// =============================================================================

trait Stringify {
    @stringify (self) -> str
}

type Container<T> = { value: T }

impl<T: Printable> Stringify for Container<T> where T: Eq {
    @stringify (self) -> str = self.value.to_str()
}

@test_where_on_impl tests @_use_container () -> void = run(
    let c: Container<int> = Container { value: 42 },
    assert_eq(actual: c.stringify(), expected: "42"),
)

@_use_container (c: Container<int>) -> int = c.value

// =============================================================================
// Where Clause with Iterator
// =============================================================================
//
// STATUS: Lexer [OK], Parser [BROKEN] - expected ':', found '=='
// Parser does not recognize associated type constraints (I.Item == int).

// SKIP: Associated type constraint syntax not implemented
// @sum_iter<I> (iter: I) -> int where I: Iterator, I.Item == int = ...
@sum_iter (list: [int]) -> int = list.fold(initial: 0, op: (acc, n) -> acc + n)

#skip("associated type constraint syntax (I.Item == int) not implemented")
@test_where_iterator tests @sum_iter () -> void = run(
    let list = [1, 2, 3, 4, 5],
    assert_eq(actual: sum_iter(list: list), expected: 15),
)

// =============================================================================
// Where Clause with Associated Type Constraints
// =============================================================================

trait HasItem {
    type Item
    @get_item (self) -> Self.Item
}

type IntHolder = { value: int }

impl HasItem for IntHolder {
    type Item = int
    @get_item (self) -> int = self.value
}

@extract_item<H> (holder: H) -> H.Item where H: HasItem = holder.get_item()

@test_where_assoc_type tests @extract_item () -> void = run(
    let h = IntHolder { value: 42 },
    assert_eq(actual: extract_item(holder: h), expected: 42),
)

// =============================================================================
// Where Clause with Default
// =============================================================================

trait WithDefault {
    @get_or_default (self) -> int
}

type MaybeInt = { value: Option<int> }

impl WithDefault for MaybeInt {
    @get_or_default (self) -> int = self.value.unwrap_or(default: 0)
}

@get_default<T> (x: T) -> int where T: WithDefault = x.get_or_default()

@test_where_default tests @get_default () -> void = run(
    let some = MaybeInt { value: Some(42) },
    let none = MaybeInt { value: None },
    assert_eq(actual: get_default(x: some), expected: 42),
    assert_eq(actual: get_default(x: none), expected: 0),
)

// =============================================================================
// Chained Where Constraints
// =============================================================================
//
// STATUS: Lexer [OK], Parser [BROKEN] - multi-line where clauses not supported
// Parser expects `=` on same line as where clause, not after newline.

// SKIP: Multi-line chained where clauses not supported
// @chain_ops<T> (x: T) -> bool where T: Eq, where T: Clone, where T: Hashable = ...
@chain_ops<T> (x: T) -> bool where T: Eq + Clone + Hashable = run(
    let cloned = x.clone(),
    x == cloned,
)

@test_chained_where tests @chain_ops () -> void = run(
    assert(cond: chain_ops(x: 42)),
    assert(cond: chain_ops(x: "hello")),
)

// =============================================================================
// Where in Recursive Functions
// =============================================================================

@sum_list<T> (items: [T]) -> T where T: Default, T: Clone =
    if is_empty(collection: items) then Default.default()
    else run(
        // Simplified: just return first element for non-empty
        items[0].clone(),
    )

@test_where_recursive tests @sum_list () -> void = run(
    let result = sum_list(items: [42, 1, 2]),
    assert_eq(actual: result, expected: 42),
)

// =============================================================================
// Where with Option/Result
// =============================================================================

@unwrap_if_eq<T> (opt: Option<T>, expected: T) -> bool where T: Eq = match(opt,
    Some(v) -> v == expected,
    None -> false,
)

@test_where_option tests @unwrap_if_eq () -> void = run(
    assert(cond: unwrap_if_eq(opt: Some(42), expected: 42)),
    assert(cond: !unwrap_if_eq(opt: Some(42), expected: 43)),
    assert(cond: !unwrap_if_eq(opt: None, expected: 42)),
)

// =============================================================================
// Where Clause Edge Cases
// =============================================================================

// Single constraint, simple
@identity_constrained<T> (x: T) -> T where T: Clone = x

@test_simple_constraint tests @identity_constrained () -> void = run(
    assert_eq(actual: identity_constrained(x: 42), expected: 42),
)

// Empty-ish where (just type bound)
@just_eq<T: Eq> (a: T, b: T) -> bool = a == b

@test_inline_bound tests @just_eq () -> void = run(
    assert(cond: just_eq(a: 42, b: 42)),
)

// Both inline and where
@mixed_bounds<T: Eq> (a: T, b: T) -> bool where T: Clone = a == b

@test_mixed_bounds tests @mixed_bounds () -> void = run(
    assert(cond: mixed_bounds(a: 42, b: 42)),
)
