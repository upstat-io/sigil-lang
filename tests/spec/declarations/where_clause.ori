// Spec: 08-declarations.md ยง Where Clause
// Tests for where clauses (grammar.ebnf ยง where_clause)
//
// TODO: Type checker needs various features
// - Where clause constraint parsing and validation
// - Multiple constraints on same type parameter
// - Constraints on multiple type parameters
// - Associated type constraints in where clauses
// - Const generic constraints (where N > 0)
//
// Uncomment when type checker supports these features.

// use std.testing { assert, assert_eq }
//
// // =============================================================================
// // Basic Where Clause - Single Constraint
// // =============================================================================
//
// @with_eq<T> (x: T) -> T where T: Eq = x
//
// @test_where_eq tests @with_eq () -> void = run(
//     assert_eq(actual: with_eq(x: 42), expected: 42),
//     assert_eq(actual: with_eq(x: "hello"), expected: "hello"),
// )
//
// @with_clone<T> (x: T) -> T where T: Clone = x.clone()
//
// @test_where_clone tests @with_clone () -> void = run(
//     assert_eq(actual: with_clone(x: 42), expected: 42),
//     assert_eq(actual: with_clone(x: "test"), expected: "test"),
// )
//
// // =============================================================================
// // Multiple Constraints on Same Type Parameter
// // =============================================================================
//
// @with_eq_and_hash<T> (x: T, y: T) -> bool where T: Eq, T: Hashable =
//     x == y && x.hash() == y.hash()
//
// @test_multiple_constraints tests @with_eq_and_hash () -> void = run(
//     assert(cond: with_eq_and_hash(x: 42, y: 42)),
//     assert(cond: !with_eq_and_hash(x: 42, y: 43)),
// )
//
// @with_three_bounds<T> (x: T) -> int where T: Eq, T: Clone, T: Hashable = x.hash()
//
// @test_three_constraints tests @with_three_bounds () -> void = run(
//     let h = with_three_bounds(x: 42),
//     assert(cond: h != 0 || h == 0),  // Hash returned something
// )
//
// // =============================================================================
// // Constraints on Multiple Type Parameters
// // =============================================================================
//
// @compare_both<A, B> (a: A, b: B) -> bool where A: Eq, B: Eq =
//     a == a && b == b
//
// @test_multi_param_constraints tests @compare_both () -> void = run(
//     assert(cond: compare_both(a: 42, b: "hello")),
// )
//
// @clone_pair<A, B> (a: A, b: B) -> (A, B) where A: Clone, B: Clone =
//     (a.clone(), b.clone())
//
// @test_multi_param_clone tests @clone_pair () -> void = run(
//     let (x, y) = clone_pair(a: 10, b: 20),
//     assert_eq(actual: x, expected: 10),
//     assert_eq(actual: y, expected: 20),
// )
//
// // =============================================================================
// // Complex Multi-Parameter Constraints
// // =============================================================================
//
// @complex_where<T, U, V> (t: T, u: U, v: V) -> bool where T: Eq + Clone, U: Hashable, V: Printable = t == t && u.hash() != 0 || true
//
// @test_complex_multi tests @complex_where () -> void = run(
//     assert(cond: complex_where(t: 42, u: 10, v: "hello")),
// )
//
// // =============================================================================
// // Where Clause with Combined Bounds
// // =============================================================================
//
// @eq_and_clone<T> (x: T) -> bool where T: Eq + Clone = x == x.clone()
//
// @test_combined_bounds tests @eq_and_clone () -> void = run(
//     assert(cond: eq_and_clone(x: 42)),
//     assert(cond: eq_and_clone(x: "hello")),
// )
//
// // ... (remaining where clause tests)
//
// // =============================================================================
// // Const Generic Constraints in Where
// // =============================================================================
// // Per spec: "Const Bounds: comparison, logical, arithmetic"
// //
// // STATUS: Lexer [OK], Parser [BROKEN] - const generic where bounds not supported
// // Parser does not recognize `where N > 0` or `where MIN >= 0, MAX > MIN`.
//
// // SKIP: Const generic where bounds not implemented
// // @positive_array<$N: int> () -> [int] where N > 0 = for i in 0..N yield i
// @positive_array () -> [int] = for i in 0..5 yield i
//
// #skip("const generic where bounds not implemented")
// @test_const_where tests @positive_array () -> void = run(
//     let arr: [int] = positive_array(),
//     assert_eq(actual: len(collection: arr), expected: 5),
// )
//
// // ... (remaining tests)
