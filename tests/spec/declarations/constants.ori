// Spec: 08-declarations.md ยง Constants
// Spec: 04-constants.md
// Tests for module-level constants (grammar.ebnf ยง constant_decl)

use std.testing { assert, assert_eq }

// =============================================================================
// Module-Level Constants
// =============================================================================
// Per spec: "Module-level must be `$`"
//
// STATUS: Lexer [OK], Parser [OK], Evaluator [BROKEN] - module-level config vars not registered
// Evaluator does not register module-level $NAME constants for use in expressions.

let $PI_APPROX = 3

let $E_APPROX = 2

let $GOLDEN_RATIO = 1

#skip("module-level config variables not registered in evaluator")
@test_module_const tests @_use_pi () -> void = run(
    assert_eq(actual: $PI_APPROX, expected: 3),
)

#skip("module-level config variables not registered in evaluator")
@test_module_e tests @_use_e () -> void = run(
    assert_eq(actual: $E_APPROX, expected: 2),
)

#skip("module-level config variables not registered in evaluator")
@test_module_golden tests @_use_golden () -> void = run(
    assert_eq(actual: $GOLDEN_RATIO, expected: 1),
)

@_use_pi () -> int = $PI_APPROX
@_use_e () -> int = $E_APPROX
@_use_golden () -> int = $GOLDEN_RATIO

// =============================================================================
// Typed Constants
// =============================================================================
//
// STATUS: Lexer [OK], Parser [BROKEN] - typed constant syntax not supported
// Parser does not recognize `let $NAME: Type = value` - expects `=` after name.

// SKIP: Typed constant syntax not implemented
// let $TYPED_INT: int = 42
// let $TYPED_STR: str = "hello"
// let $TYPED_BOOL: bool = true
let $TYPED_INT = 42
let $TYPED_STR = "hello"
let $TYPED_BOOL = true

#skip("typed constant syntax (let $NAME: Type = value) not implemented")
@test_typed_int tests @_use_typed_int () -> void = run(
    assert_eq(actual: $TYPED_INT, expected: 42),
)

#skip("typed constant syntax not implemented")
@test_typed_str tests @_use_typed_str () -> void = run(
    assert_eq(actual: $TYPED_STR, expected: "hello"),
)

#skip("typed constant syntax not implemented")
@test_typed_bool tests @_use_typed_bool () -> void = run(
    assert(cond: $TYPED_BOOL),
)

@_use_typed_int () -> int = $TYPED_INT
@_use_typed_str () -> str = $TYPED_STR
@_use_typed_bool () -> bool = $TYPED_BOOL

// =============================================================================
// Public Constants
// =============================================================================

pub let $PUBLIC_CONST = 100

#skip("module-level config variables not registered in evaluator")
@test_public_const tests @_use_public () -> void = run(
    assert_eq(actual: $PUBLIC_CONST, expected: 100),
)

@_use_public () -> int = $PUBLIC_CONST

// =============================================================================
// Constants with Expressions
// =============================================================================
//
// STATUS: Lexer [OK], Parser [BROKEN] - config variable must be initialized with a literal
// Parser requires constants to be literals, does not support computed expressions.

// SKIP: Computed constant expressions not supported
// let $COMPUTED = 2 + 3
// let $PRODUCT = 6 * 7
// let $DIFFERENCE = 100 - 58
let $COMPUTED = 5
let $PRODUCT = 42
let $DIFFERENCE = 42

#skip("computed constant expressions not implemented")
@test_computed tests @_use_computed () -> void = run(
    assert_eq(actual: $COMPUTED, expected: 5),
)

#skip("computed constant expressions not implemented")
@test_product tests @_use_product () -> void = run(
    assert_eq(actual: $PRODUCT, expected: 42),
)

#skip("computed constant expressions not implemented")
@test_difference tests @_use_diff () -> void = run(
    assert_eq(actual: $DIFFERENCE, expected: 42),
)

@_use_computed () -> int = $COMPUTED
@_use_product () -> int = $PRODUCT
@_use_diff () -> int = $DIFFERENCE

// =============================================================================
// Constants Referencing Other Constants
// =============================================================================

let $BASE = 10

// SKIP: Constants referencing other constants not supported
// let $DOUBLE_BASE = $BASE * 2
// let $TRIPLE_BASE = $BASE * 3
let $DOUBLE_BASE = 20
let $TRIPLE_BASE = 30

#skip("constants referencing other constants not implemented")
@test_ref_const tests @_use_ref () -> void = run(
    assert_eq(actual: $DOUBLE_BASE, expected: 20),
    assert_eq(actual: $TRIPLE_BASE, expected: 30),
)

@_use_ref () -> int = $DOUBLE_BASE

// =============================================================================
// Constants in Expressions
// =============================================================================

@add_to_const (n: int) -> int = n + $BASE

#skip("module-level config variables not registered in evaluator")
@test_const_in_expr tests @add_to_const () -> void = run(
    assert_eq(actual: add_to_const(n: 5), expected: 15),
)

@multiply_by_const (n: int) -> int = n * $PI_APPROX

#skip("module-level config variables not registered in evaluator")
@test_const_multiply tests @multiply_by_const () -> void = run(
    assert_eq(actual: multiply_by_const(n: 4), expected: 12),
)

// =============================================================================
// String Constants
// =============================================================================

let $GREETING = "Hello, World!"

let $EMPTY_STR = ""

let $MULTIWORD = "Hello there"

#skip("module-level config variables not registered in evaluator")
@test_string_const tests @_use_greeting () -> void = run(
    assert_eq(actual: $GREETING, expected: "Hello, World!"),
)

#skip("module-level config variables not registered in evaluator")
@test_empty_string tests @_use_empty () -> void = run(
    assert_eq(actual: $EMPTY_STR, expected: ""),
)

@_use_greeting () -> str = $GREETING
@_use_empty () -> str = $EMPTY_STR

// =============================================================================
// Boolean Constants
// =============================================================================

let $TRUE_CONST = true

let $FALSE_CONST = false

#skip("module-level config variables not registered in evaluator")
@test_true_const tests @_use_true () -> void = run(
    assert(cond: $TRUE_CONST),
)

#skip("module-level config variables not registered in evaluator")
@test_false_const tests @_use_false () -> void = run(
    assert(cond: !$FALSE_CONST),
)

@_use_true () -> bool = $TRUE_CONST
@_use_false () -> bool = $FALSE_CONST

// =============================================================================
// Constants in Control Flow
// =============================================================================

let $THRESHOLD = 50

@is_above_threshold (n: int) -> bool = n > $THRESHOLD

#skip("module-level config variables not registered in evaluator")
@test_const_in_condition tests @is_above_threshold () -> void = run(
    assert(cond: is_above_threshold(n: 60)),
    assert(cond: !is_above_threshold(n: 40)),
)

// =============================================================================
// Local Immutable Bindings ($)
// =============================================================================
// Per spec: local bindings use `let $name` for immutability

@local_const_binding () -> int = run(
    let $local = 42,
    $local,
)

@test_local_const tests @local_const_binding () -> void = run(
    assert_eq(actual: local_const_binding(), expected: 42),
)

@local_with_ops () -> int = run(
    let $a = 10,
    let $b = 20,
    $a + $b,
)

@test_local_ops tests @local_with_ops () -> void = run(
    assert_eq(actual: local_with_ops(), expected: 30),
)

// =============================================================================
// Negative Constants
// =============================================================================
//
// STATUS: Lexer [OK], Parser [BROKEN] - negative literals treated as expressions
// Parser treats `-42` as negation of `42`, not as a literal.

// SKIP: Negative constant literals not supported as literals
// let $NEGATIVE = -42
// let $NEGATIVE_RESULT = 10 - 50
let $NEG_VALUE = 42  // Use positive, negate at use site

#skip("negative constant literals treated as expressions, not literals")
@test_negative tests @_use_negative () -> void = run(
    assert_eq(actual: 0 - $NEG_VALUE, expected: -42),
)

#skip("computed constant expressions not implemented")
@test_negative_result tests @_use_neg_result () -> void = run(
    assert_eq(actual: 10 - 50, expected: -40),
)

@_use_negative () -> int = 0 - $NEG_VALUE
@_use_neg_result () -> int = 10 - 50

// =============================================================================
// Zero Constants
// =============================================================================

let $ZERO = 0

// SKIP: Computed constant expressions not supported
// let $ZERO_RESULT = 10 - 10
let $ZERO_RESULT = 0

#skip("computed constant expressions not implemented")
@test_zero tests @_use_zero () -> void = run(
    assert_eq(actual: $ZERO, expected: 0),
    assert_eq(actual: $ZERO_RESULT, expected: 0),
)

@_use_zero () -> int = $ZERO

// =============================================================================
// Large Constants
// =============================================================================

let $MILLION = 1000000

let $BILLION = 1000000000

#skip("module-level config variables not registered in evaluator")
@test_large tests @_use_million () -> void = run(
    assert_eq(actual: $MILLION, expected: 1000000),
    assert_eq(actual: $BILLION, expected: 1000000000),
)

@_use_million () -> int = $MILLION

// =============================================================================
// Constant Functions
// =============================================================================
// Per spec: "$name (p: T) -> R = expr" - pure, comptime functions
//
// STATUS: Lexer [OK], Parser [BROKEN] - expected '=', found '('
// Parser does not recognize const function syntax ($name (params) -> T = expr).

// SKIP: Const function syntax not implemented
// $double (n: int) -> int = n * 2
@_double (n: int) -> int = n * 2  // Use regular function as workaround

#skip("const function syntax ($name (params) -> T = expr) not implemented")
@test_const_fn tests @_call_double () -> void = run(
    assert_eq(actual: _double(n: 21), expected: 42),
)

@_call_double () -> int = _double(n: 5)

// SKIP: Const function syntax not implemented
// $add (a: int, b: int) -> int = a + b
@_add (a: int, b: int) -> int = a + b

#skip("const function syntax not implemented")
@test_const_add tests @_call_add () -> void = run(
    assert_eq(actual: _add(a: 10, b: 32), expected: 42),
)

@_call_add () -> int = _add(a: 1, b: 2)

// SKIP: Const function syntax not implemented
// $factorial (n: int) -> int = if n <= 1 then 1 else n * $factorial(n: n - 1)
@_factorial (n: int) -> int = if n <= 1 then 1 else n * _factorial(n: n - 1)

#skip("const function syntax not implemented")
@test_const_factorial tests @_call_factorial () -> void = run(
    assert_eq(actual: _factorial(n: 5), expected: 120),
)

@_call_factorial () -> int = _factorial(n: 3)

// =============================================================================
// Const Functions Calling Other Const Functions
// =============================================================================

// SKIP: Const function syntax not implemented
// $square (n: int) -> int = n * n
// $cube (n: int) -> int = $square(n: n) * n
@_square (n: int) -> int = n * n
@_cube (n: int) -> int = _square(n: n) * n

#skip("const function syntax not implemented")
@test_const_chain tests @_call_cube () -> void = run(
    assert_eq(actual: _cube(n: 3), expected: 27),
)

@_call_cube () -> int = _cube(n: 2)

// =============================================================================
// Constants in Match
// =============================================================================

let $MATCH_VALUE = 2

@describe_level (level: int) -> str = match(level,
    1 -> "low",
    2 -> "medium",
    3 -> "high",
    _ -> "unknown",
)

#skip("module-level config variables not registered in evaluator")
@test_const_in_match tests @describe_level () -> void = run(
    // Use a constant as the scrutinee
    assert_eq(actual: describe_level(level: $MATCH_VALUE), expected: "medium"),
)

// =============================================================================
// Duration and Size Constants
// =============================================================================

let $DEFAULT_TIMEOUT = 30s

let $BUFFER_SIZE = 1mb

#skip("module-level config variables not registered in evaluator")
@test_duration_const tests @_use_timeout () -> void = run(
    assert_eq(actual: $DEFAULT_TIMEOUT.seconds(), expected: 30),
)

#skip("module-level config variables not registered in evaluator")
@test_size_const tests @_use_buffer () -> void = run(
    assert_eq(actual: $BUFFER_SIZE.megabytes(), expected: 1),
)

@_use_timeout () -> int = $DEFAULT_TIMEOUT.seconds()
@_use_buffer () -> int = $BUFFER_SIZE.bytes()

// =============================================================================
// List Constants
// =============================================================================
//
// STATUS: Lexer [OK], Parser [BROKEN] - list/struct literals not supported in constants
// Parser only accepts primitive literals (int, str, bool) for config variables.

// SKIP: List literals in constants not supported
// let $PRIMES = [2, 3, 5, 7, 11]
// let $EMPTY_LIST: [int] = []
@_get_primes () -> [int] = [2, 3, 5, 7, 11]
@_get_empty_list () -> [int] = []

#skip("list literals in constants not supported")
@test_list_const tests @_use_primes () -> void = run(
    let primes = _get_primes(),
    assert_eq(actual: len(collection: primes), expected: 5),
    assert_eq(actual: primes[0], expected: 2),
)

#skip("list literals in constants not supported")
@test_empty_list_const tests @_use_empty_list () -> void = run(
    let empty = _get_empty_list(),
    assert_eq(actual: len(collection: empty), expected: 0),
)

@_use_primes () -> [int] = _get_primes()
@_use_empty_list () -> [int] = _get_empty_list()

// =============================================================================
// Constants in Type Annotations
// =============================================================================

type Config = { timeout: int, buffer: int }

// SKIP: Struct literals in constants not supported
// let $DEFAULT_CONFIG = Config { timeout: 30, buffer: 1024 }
@_get_default_config () -> Config = Config { timeout: 30, buffer: 1024 }

#skip("struct literals in constants not supported")
@test_struct_const tests @_use_config () -> void = run(
    let config = _get_default_config(),
    assert_eq(actual: config.timeout, expected: 30),
    assert_eq(actual: config.buffer, expected: 1024),
)

@_use_config () -> Config = _get_default_config()
