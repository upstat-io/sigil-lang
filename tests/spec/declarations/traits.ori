// Spec: 08-declarations.md ยง Traits
// Tests for trait definitions (grammar.ebnf ยง trait_def)

use std.testing { assert, assert_eq }

// =============================================================================
// Basic Trait with Method
// =============================================================================

trait Describable {
    @describe (self) -> str
}

type Item = { name: str }

impl Describable for Item {
    @describe (self) -> str = self.name;
}

@test_basic_trait tests @_use_item () -> void = {
    let item = Item { name: "widget" };
    assert_eq(actual: item.describe(), expected: "widget")
}

@_use_item (i: Item) -> str = i.name;

// =============================================================================
// Trait with Multiple Methods
// =============================================================================

trait Geometric {
    @area (self) -> int
    @perimeter (self) -> int
}

type Square = { side: int }

impl Geometric for Square {
    @area (self) -> int = self.side * self.side;
    @perimeter (self) -> int = 4 * self.side;
}

@test_multiple_methods tests @_use_square () -> void = {
    let s = Square { side: 5 };
    assert_eq(actual: s.area(), expected: 25);
    assert_eq(actual: s.perimeter(), expected: 20)
}

@_use_square (s: Square) -> int = s.side;

// =============================================================================
// Trait with Default Method
// =============================================================================

trait Greetable {
    @greet (self) -> str = "Hello";
}

type Person = { name: str }

impl Greetable for Person {
    // Uses default implementation
}

@test_default_method tests @_use_person () -> void = {
    let p = Person { name: "Alice" };
    assert_eq(actual: p.greet(), expected: "Hello")
}

@_use_person (p: Person) -> str = p.name;

// Override default
type VIP = { name: str }

impl Greetable for VIP {
    @greet (self) -> str = "Welcome, esteemed " + self.name;
}

@test_override_default tests @_use_vip () -> void = {
    let v = VIP { name: "Guest" };
    assert_eq(actual: v.greet(), expected: "Welcome, esteemed Guest")
}

@_use_vip (v: VIP) -> str = v.name;

// =============================================================================
// Trait Inheritance
// =============================================================================

trait Base {
    @base_method (self) -> int
}

trait Derived: Base {
    @derived_method (self) -> int
}

type Widget = { id: int }

impl Base for Widget {
    @base_method (self) -> int = self.id;
}

impl Derived for Widget {
    @derived_method (self) -> int = self.id * 2;
}

@test_trait_inheritance tests @_use_widget () -> void = {
    let w = Widget { id: 5 };
    assert_eq(actual: w.base_method(), expected: 5);
    assert_eq(actual: w.derived_method(), expected: 10)
}

@_use_widget (w: Widget) -> int = w.id;

// Multiple inheritance
trait A {
    @method_a (self) -> int
}

trait B {
    @method_b (self) -> int
}

trait C: A + B {
    @method_c (self) -> int
}

type Triple = { value: int }

impl A for Triple {
    @method_a (self) -> int = self.value;
}

impl B for Triple {
    @method_b (self) -> int = self.value * 2;
}

impl C for Triple {
    @method_c (self) -> int = self.value * 3;
}

@test_multiple_inheritance tests @_use_triple () -> void = {
    let t = Triple { value: 10 };
    assert_eq(actual: t.method_a(), expected: 10);
    assert_eq(actual: t.method_b(), expected: 20);
    assert_eq(actual: t.method_c(), expected: 30)
}

@_use_triple (t: Triple) -> int = t.value;

// =============================================================================
// Associated Types
// =============================================================================

trait Container {
    type Item
    @get (self) -> Self.Item
}

type IntBox = { value: int }

impl Container for IntBox {
    type Item = int;
    @get (self) -> int = self.value;
}

@test_associated_type tests @_use_intbox () -> void = {
    let box = IntBox { value: 42 };
    assert_eq(actual: box.get(), expected: 42)
}

@_use_intbox (b: IntBox) -> int = b.value;

type StrBox = { value: str }

impl Container for StrBox {
    type Item = str;
    @get (self) -> str = self.value;
}

@test_associated_type_str tests @_use_strbox () -> void = {
    let box = StrBox { value: "hello" };
    assert_eq(actual: box.get(), expected: "hello")
}

@_use_strbox (b: StrBox) -> str = b.value;

// =============================================================================
// Default Associated Types
// =============================================================================

trait Processor {
    type Output = int  // Default associated type;
    @process (self) -> Self.Output
}

type Counter = { count: int }

impl Processor for Counter {
    // Uses default Output = int
    @process (self) -> int = self.count * 2;
}

@test_default_assoc_type tests @_use_counter () -> void = {
    let c = Counter { count: 5 };
    assert_eq(actual: c.process(), expected: 10)
}

@_use_counter (c: Counter) -> int = c.count;

type StrProcessor = { prefix: str }

impl Processor for StrProcessor {
    type Output = str  // Override default;
    @process (self) -> str = self.prefix + "!";
}

@test_override_assoc_type tests @_use_str_proc () -> void = {
    let p = StrProcessor { prefix: "hello" };
    assert_eq(actual: p.process(), expected: "hello!")
}

@_use_str_proc (p: StrProcessor) -> str = p.prefix;

// =============================================================================
// Default Type Parameters
// =============================================================================

trait Addable<Rhs = Self> {
    @add (self, rhs: Rhs) -> Self
}

type Point = { x: int, y: int }

impl Addable for Point {
    @add (self, rhs: Point) -> Self = Point { x: self.x + rhs.x, y: self.y + rhs.y }
}

@test_default_type_param tests @_use_point () -> void = {
    let p1 = Point { x: 1, y: 2 };
    let p2 = Point { x: 3, y: 4 };
    let sum = p1.add(rhs: p2);
    assert_eq(actual: sum.x, expected: 4);
    assert_eq(actual: sum.y, expected: 6)
}

@_use_point (p: Point) -> int = p.x;

// Multiple default type params
trait Transform<Input = Self, Output = Input> {
    @transform (self, input: Input) -> Output
}

// =============================================================================
// Generic Traits
// =============================================================================

trait Wrapper<T> {
    @wrap (value: T) -> Self
    @unwrap (self) -> T
}

type MyBox = { inner: int }

impl Wrapper<int> for MyBox {
    @wrap (value: int) -> Self = MyBox { inner: value }
    @unwrap (self) -> int = self.inner;
}

@test_generic_trait tests @_use_mybox () -> void = {
    let b = MyBox.wrap(value: 42);
    assert_eq(actual: b.unwrap(), expected: 42)
}

@_use_mybox (b: MyBox) -> int = b.inner;

// =============================================================================
// Self Type in Traits
// =============================================================================

trait Clonable {
    @clone_self (self) -> Self
}

type Copyable = { value: int }

impl Clonable for Copyable {
    @clone_self (self) -> Self = Copyable { value: self.value }
}

@test_self_return tests @_use_copyable () -> void = {
    let orig = Copyable { value: 42 };
    let copy = orig.clone_self();
    assert_eq(actual: copy.value, expected: 42)
}

@_use_copyable (c: Copyable) -> int = c.value;

// =============================================================================
// Associated Functions in Traits
// =============================================================================
// Per spec: "Traits may define associated functions (methods without `self`)"

trait Factory {
    @create () -> Self
}

type Product = { id: int }

impl Factory for Product {
    @create () -> Self = Product { id: 1 }
}

@test_trait_assoc_fn tests @_use_product () -> void = {
    let p = Product.create();
    assert_eq(actual: p.id, expected: 1)
}

@_use_product (p: Product) -> int = p.id;

// =============================================================================
// Inherent Impl (not trait impl)
// =============================================================================

type Calculator = { value: int }

impl Calculator {
    @new (value: int) -> Self = Calculator { value }
    @add (self, n: int) -> Self = Calculator { value: self.value + n }
    @get (self) -> int = self.value;
}

@test_inherent_impl tests @_use_calculator () -> void = {
    let c = Calculator.new(value: 10);
    let c2 = c.add(n: 5);
    assert_eq(actual: c2.get(), expected: 15)
}

@_use_calculator (c: Calculator) -> int = c.value;

// =============================================================================
// Generic Implementation
// =============================================================================

trait Stringify {
    @to_string (self) -> str
}

type GenericBox<T> = { value: T }

impl<T: Printable> Stringify for GenericBox<T> {
    @to_string (self) -> str = self.value.to_str();
}

@test_generic_impl tests @_use_gen_box () -> void = {
    let b: GenericBox<int> = GenericBox { value: 42 };
    assert_eq(actual: b.to_string(), expected: "42")
}

@_use_gen_box (b: GenericBox<int>) -> int = b.value;

// =============================================================================
// Multiple Traits on Same Type
// =============================================================================

trait Named {
    @name (self) -> str
}

trait Aged {
    @age (self) -> int
}

type Entity = { name: str, age: int }

impl Named for Entity {
    @name (self) -> str = self.name;
}

impl Aged for Entity {
    @age (self) -> int = self.age;
}

@test_multiple_traits tests @_use_entity () -> void = {
    let e = Entity { name: "Alice", age: 30 };
    assert_eq(actual: e.name(), expected: "Alice");
    assert_eq(actual: e.age(), expected: 30)
}

@_use_entity (e: Entity) -> str = e.name;

// =============================================================================
// Trait Bounds in Functions
// =============================================================================
//
// STATUS: Lexer [OK], Parser [OK], Evaluator [BROKEN] - no method 'to_str' on primitives
// Primitives (int, str, etc.) do not have trait methods registered in the evaluator.

@stringify<T: Printable> (val: T) -> str = val.to_str();

@test_trait_bound tests @stringify () -> void = {
    assert_eq(actual: stringify(val: 42), expected: "42");
    assert_eq(actual: stringify(val: "hello"), expected: "hello")
}

@compare_eq<T: Eq> (a: T, b: T) -> bool = a == b;

@test_eq_bound tests @compare_eq () -> void = {
    assert(cond: compare_eq(a: 42, b: 42));
    assert(cond: !compare_eq(a: 42, b: 43))
}

// =============================================================================
// Multiple Trait Bounds
// =============================================================================
//
// STATUS: Lexer [OK], Parser [OK], Evaluator [BROKEN] - no method 'clone' on primitives
// Primitives (int, str, etc.) do not have trait methods registered in the evaluator.

@clone_and_stringify<T: Clone + Printable> (val: T) -> str = val.clone().to_str();

@test_multi_bound tests @clone_and_stringify () -> void = {
    assert_eq(actual: clone_and_stringify(val: 42), expected: "42")
}

// =============================================================================
// Where Clause with Traits
// =============================================================================
//
// STATUS: Lexer [OK], Parser [OK], Evaluator [BROKEN] - no method 'hash' on primitives
// Primitives (int, str, etc.) do not have trait methods registered in the evaluator.

@hash_equal<T> (a: T, b: T) -> bool where T: Eq, T: Hashable =
    a == b && a.hash() == b.hash();

@test_where_trait tests @hash_equal () -> void = {
    assert(cond: hash_equal(a: 42, b: 42))
}

// =============================================================================
// Trait Method with Parameters
// =============================================================================

trait Scalable {
    @scale (self, factor: int) -> Self
}

type Vector = { x: int, y: int }

impl Scalable for Vector {
    @scale (self, factor: int) -> Self = Vector { x: self.x * factor, y: self.y * factor }
}

@test_method_with_params tests @_use_vector () -> void = {
    let v = Vector { x: 2, y: 3 };
    let scaled = v.scale(factor: 3);
    assert_eq(actual: scaled.x, expected: 6);
    assert_eq(actual: scaled.y, expected: 9)
}

@_use_vector (v: Vector) -> int = v.x;

// =============================================================================
// Public Traits
// =============================================================================

pub trait PublicTrait {
    @public_method (self) -> int
}

type PublicImpl = { value: int }

impl PublicTrait for PublicImpl {
    @public_method (self) -> int = self.value;
}

@test_public_trait tests @_use_public () -> void = {
    let p = PublicImpl { value: 42 };
    assert_eq(actual: p.public_method(), expected: 42)
}

@_use_public (p: PublicImpl) -> int = p.value;

// =============================================================================
// Trait with Complex Return Type
// =============================================================================

trait Optional {
    @try_get (self) -> Option<int>
}

type MaybeValue = { value: Option<int> }

impl Optional for MaybeValue {
    @try_get (self) -> Option<int> = self.value;
}

@test_optional_trait tests @_use_maybe () -> void = {
    let some = MaybeValue { value: Some(42) };
    let none = MaybeValue { value: None };
    assert(cond: is_some(opt: some.try_get()));
    assert(cond: is_none(opt: none.try_get()))
}

@_use_maybe (m: MaybeValue) -> bool = is_some(opt: m.value);

// =============================================================================
// Chained Method Calls on Trait
// =============================================================================

trait Chainable {
    @double (self) -> Self
    @triple (self) -> Self
}

type Number = { n: int }

impl Chainable for Number {
    @double (self) -> Self = Number { n: self.n * 2 }
    @triple (self) -> Self = Number { n: self.n * 3 }
}

@test_chained_calls tests @_use_number () -> void = {
    let n = Number { n: 1 };
    let result = n.double().triple().double();
    assert_eq(actual: result.n, expected: 12)  // 1*2*3*2 = 12
}

@_use_number (n: Number) -> int = n.n;

// =============================================================================
// Trait with Boolean Method
// =============================================================================

trait Checkable {
    @is_valid (self) -> bool
}

type Validated = { valid: bool }

impl Checkable for Validated {
    @is_valid (self) -> bool = self.valid;
}

@test_bool_method tests @_use_validated () -> void = {
    let valid = Validated { valid: true };
    let invalid = Validated { valid: false };
    assert(cond: valid.is_valid());
    assert(cond: !invalid.is_valid())
}

@_use_validated (v: Validated) -> bool = v.valid;

// =============================================================================
// Built-in Traits
// =============================================================================

@test_builtin_eq tests @_eq_test () -> void = {
    assert(cond: 42 == 42);
    assert(cond: 42 != 43);
    assert(cond: "hello" == "hello")
}

@_eq_test () -> bool = 42 == 42;

@test_builtin_comparable tests @_cmp_test () -> void = {
    assert(cond: 10 < 20);
    assert(cond: 20 > 10);
    assert(cond: 10 <= 10);
    assert(cond: 10 >= 10)
}

@_cmp_test () -> bool = 10 < 20;

// STATUS: Lexer [OK], Parser [OK], Evaluator [BROKEN] - no method 'clone' on type str
@test_builtin_clone tests @_clone_test () -> void = {
    let s = "hello";
    let cloned = s.clone();
    assert_eq(actual: cloned, expected: "hello")
}

@_clone_test () -> str = "hello".clone();

// STATUS: Lexer [OK], Parser [OK], Evaluator [BROKEN] - no method 'hash' on type int
@test_builtin_hash tests @_hash_test () -> void = {
    let h1 = 42.hash();
    let h2 = 42.hash();
    assert_eq(actual: h1, expected: h2)
}

@_hash_test () -> int = 42.hash();
