// Spec: 03-lexical-elements.md ยง String Literals
// Tests for string literals (grammar.ebnf ยง string_literal)
// string_literal = '"' { string_char } '"' .
// string_char    = unicode_char - ( '"' | '\' | newline ) | escape .
// escape         = '\' ( '"' | '\' | 'n' | 't' | 'r' | '0' ) .

use std.testing { assert, assert_eq }

// =============================================================================
// Basic String Literals
// =============================================================================

@string_empty () -> str = ""

@test_string_empty tests @string_empty () -> void = run(
    assert(cond: string_empty() == ""),
    assert_eq(actual: string_empty().len(), expected: 0),
)

@string_single_char () -> str = "a"

@test_string_single_char tests @string_single_char () -> void = run(
    assert(cond: string_single_char() == "a"),
    assert_eq(actual: string_single_char().len(), expected: 1),
)

@string_hello () -> str = "hello"

@test_string_hello tests @string_hello () -> void = run(
    assert(cond: string_hello() == "hello"),
    assert_eq(actual: string_hello().len(), expected: 5),
)

@string_hello_world () -> str = "Hello, World!"

@test_string_hello_world tests @string_hello_world () -> void = run(
    assert(cond: string_hello_world() == "Hello, World!"),
    assert_eq(actual: string_hello_world().len(), expected: 13),
)

// =============================================================================
// Strings with Spaces
// =============================================================================

@string_leading_space () -> str = " hello"

@test_string_leading_space tests @string_leading_space () -> void = run(
    assert(cond: string_leading_space() == " hello"),
)

@string_trailing_space () -> str = "hello "

@test_string_trailing_space tests @string_trailing_space () -> void = run(
    assert(cond: string_trailing_space() == "hello "),
)

@string_multiple_spaces () -> str = "  spaces  "

@test_string_multiple_spaces tests @string_multiple_spaces () -> void = run(
    assert(cond: string_multiple_spaces() == "  spaces  "),
)

@string_only_space () -> str = " "

@test_string_only_space tests @string_only_space () -> void = run(
    assert(cond: string_only_space() == " "),
    assert_eq(actual: string_only_space().len(), expected: 1),
)

@string_multiple_words () -> str = "hello world foo bar"

@test_string_multiple_words tests @string_multiple_words () -> void = run(
    assert(cond: string_multiple_words() == "hello world foo bar"),
)

// =============================================================================
// Strings with Various Characters
// =============================================================================

@string_digits () -> str = "12345"

@test_string_digits tests @string_digits () -> void = run(
    assert(cond: string_digits() == "12345"),
)

@string_mixed () -> str = "abc123"

@test_string_mixed tests @string_mixed () -> void = run(
    assert(cond: string_mixed() == "abc123"),
)

@string_punctuation () -> str = "foo@bar.com"

@test_string_punctuation tests @string_punctuation () -> void = run(
    assert(cond: string_punctuation() == "foo@bar.com"),
)

@string_math () -> str = "1+2=3"

@test_string_math tests @string_math () -> void = run(
    assert(cond: string_math() == "1+2=3"),
)

@string_special_chars () -> str = "!@#$%^&*()"

@test_string_special_chars tests @string_special_chars () -> void = run(
    assert(cond: string_special_chars() == "!@#$%^&*()"),
)

// =============================================================================
// Escape Sequences
// =============================================================================

@string_escape_backslash () -> str = "a\\b"

@test_string_escape_backslash tests @string_escape_backslash () -> void = run(
    assert(cond: string_escape_backslash() == "a\\b"),
)

@string_escape_quote () -> str = "say \"hello\""

@test_string_escape_quote tests @string_escape_quote () -> void = run(
    assert(cond: string_escape_quote() == "say \"hello\""),
)

@string_escape_newline () -> str = "line1\nline2"

@test_string_escape_newline tests @string_escape_newline () -> void = run(
    assert(cond: string_escape_newline() == "line1\nline2"),
)

@string_escape_tab () -> str = "col1\tcol2"

@test_string_escape_tab tests @string_escape_tab () -> void = run(
    assert(cond: string_escape_tab() == "col1\tcol2"),
)

@string_escape_carriage () -> str = "line\r"

@test_string_escape_carriage tests @string_escape_carriage () -> void = run(
    assert(cond: string_escape_carriage() == "line\r"),
)

@string_escape_crlf () -> str = "win\r\nline"

@test_string_escape_crlf tests @string_escape_crlf () -> void = run(
    assert(cond: string_escape_crlf() == "win\r\nline"),
)

@string_escape_null () -> str = "null\0char"

@test_string_escape_null tests @string_escape_null () -> void = run(
    assert(cond: string_escape_null() == "null\0char"),
)

// =============================================================================
// Multiple Escapes in Single String
// =============================================================================

@string_multi_escape () -> str = "a\\b\\c"

@test_string_multi_escape tests @string_multi_escape () -> void = run(
    assert(cond: string_multi_escape() == "a\\b\\c"),
)

@string_multi_newline () -> str = "line1\nline2\nline3"

@test_string_multi_newline tests @string_multi_newline () -> void = run(
    assert(cond: string_multi_newline() == "line1\nline2\nline3"),
)

@string_multi_quote () -> str = "\"one\" and \"two\""

@test_string_multi_quote tests @string_multi_quote () -> void = run(
    assert(cond: string_multi_quote() == "\"one\" and \"two\""),
)

@string_mixed_escapes () -> str = "path\\to\\file\nname\ttab"

@test_string_mixed_escapes tests @string_mixed_escapes () -> void = run(
    assert(cond: string_mixed_escapes() == "path\\to\\file\nname\ttab"),
)

// =============================================================================
// Unicode Strings
// =============================================================================

@string_unicode_accented () -> str = "cafe"

@test_string_unicode_accented tests @string_unicode_accented () -> void = run(
    assert(cond: string_unicode_accented() == "cafe"),
)

@string_unicode_french () -> str = "francais"

@test_string_unicode_french tests @string_unicode_french () -> void = run(
    assert(cond: string_unicode_french() == "francais"),
)

@string_unicode_german () -> str = "Munchen"

@test_string_unicode_german tests @string_unicode_german () -> void = run(
    assert(cond: string_unicode_german() == "Munchen"),
)

@string_unicode_spanish () -> str = "espanol"

@test_string_unicode_spanish tests @string_unicode_spanish () -> void = run(
    assert(cond: string_unicode_spanish() == "espanol"),
)

// =============================================================================
// String Comparisons
// =============================================================================

@string_compare_eq () -> bool = "hello" == "hello"

@test_string_compare_eq tests @string_compare_eq () -> void = run(
    assert(cond: string_compare_eq()),
)

@string_compare_neq () -> bool = "hello" != "world"

@test_string_compare_neq tests @string_compare_neq () -> void = run(
    assert(cond: string_compare_neq()),
)

@string_compare_empty () -> bool = "" == ""

@test_string_compare_empty tests @string_compare_empty () -> void = run(
    assert(cond: string_compare_empty()),
)

@string_compare_case () -> bool = "Hello" != "hello"

@test_string_compare_case tests @string_compare_case () -> void = run(
    assert(cond: string_compare_case()), // Case sensitive
)

// =============================================================================
// String Operations
// =============================================================================

@string_length () -> int = "hello".len()

@test_string_length tests @string_length () -> void = run(
    assert_eq(actual: string_length(), expected: 5),
)

@string_empty_length () -> int = "".len()

@test_string_empty_length tests @string_empty_length () -> void = run(
    assert_eq(actual: string_empty_length(), expected: 0),
)

@string_is_empty () -> bool = "".len() == 0

@test_string_is_empty tests @string_is_empty () -> void = run(
    assert(cond: string_is_empty()),
)

@string_not_empty () -> bool = "hello".len() > 0

@test_string_not_empty tests @string_not_empty () -> void = run(
    assert(cond: string_not_empty()),
)

// =============================================================================
// Strings in Collections
// =============================================================================

@string_in_list () -> int = ["a", "b", "c"].len()

@test_string_in_list tests @string_in_list () -> void = run(
    assert_eq(actual: string_in_list(), expected: 3),
)

@string_in_map () -> int = run(
    let map = {"key": "value"},
    map.len(),
)

@test_string_in_map tests @string_in_map () -> void = run(
    assert_eq(actual: string_in_map(), expected: 1),
)

type StringStruct = { name: str, value: str }

@string_in_struct () -> str = run(
    let s = StringStruct { name: "foo", value: "bar" },
    s.name,
)

@test_string_in_struct tests @string_in_struct () -> void = run(
    assert(cond: string_in_struct() == "foo"),
)

// =============================================================================
// Long Strings
// =============================================================================

@string_long () -> int = "This is a fairly long string that tests the lexer's ability to handle longer string literals without any issues whatsoever.".len()

@test_string_long tests @string_long () -> void = run(
    assert(cond: string_long() > 100),
)

// =============================================================================
// Strings with All Printable ASCII
// =============================================================================

@string_printable_ascii () -> str = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789"

@test_string_printable_ascii tests @string_printable_ascii () -> void = run(
    assert_eq(actual: string_printable_ascii().len(), expected: 62),
)

// =============================================================================
// Edge Cases
// =============================================================================

@string_only_escape () -> str = "\n"

@test_string_only_escape tests @string_only_escape () -> void = run(
    assert(cond: string_only_escape() == "\n"),
)

@string_only_backslash () -> str = "\\"

@test_string_only_backslash tests @string_only_backslash () -> void = run(
    assert(cond: string_only_backslash() == "\\"),
)

@string_only_quote () -> str = "\""

@test_string_only_quote tests @string_only_quote () -> void = run(
    assert(cond: string_only_quote() == "\""),
)

@string_consecutive_escapes () -> str = "\n\n\n"

@test_string_consecutive_escapes tests @string_consecutive_escapes () -> void = run(
    assert(cond: string_consecutive_escapes() == "\n\n\n"),
)

// =============================================================================
// Strings in Conditionals
// =============================================================================

@string_conditional () -> str = if true then "yes" else "no"

@test_string_conditional tests @string_conditional () -> void = run(
    assert(cond: string_conditional() == "yes"),
)

@string_conditional_compare () -> str = if "a" == "a" then "match" else "no match"

@test_string_conditional_compare tests @string_conditional_compare () -> void = run(
    assert(cond: string_conditional_compare() == "match"),
)

// =============================================================================
// String Bindings
// =============================================================================

@string_binding () -> str = run(
    let s = "hello",
    s,
)

@test_string_binding tests @string_binding () -> void = run(
    assert(cond: string_binding() == "hello"),
)

@string_rebind () -> str = run(
    let s = "hello",
    let s = "world",
    s,
)

@test_string_rebind tests @string_rebind () -> void = run(
    assert(cond: string_rebind() == "world"),
)

// =============================================================================
// String as Function Parameter
// =============================================================================

@string_param (s: str) -> str = s

@test_string_param tests @string_param () -> void = run(
    assert(cond: string_param(s: "test") == "test"),
)

@string_param_escape (s: str) -> str = s

@test_string_param_escape tests @string_param_escape () -> void = run(
    assert(cond: string_param_escape(s: "line1\nline2") == "line1\nline2"),
)
