// Spec: 03-lexical-elements.md ยง Operators
// Tests for operators (grammar.ebnf ยง operators)
// Precedence (high to low):
// 1. . [] () ?  2. ! - ~ (unary)  3. * / % div  4. + -  5. << >>
// 6. .. ..=  7. < > <= >=  8. == !=  9. &  10. ^  11. |  12. &&  13. ||  14. ??

use std.testing { assert, assert_eq }

// =============================================================================
// Arithmetic Operators
// =============================================================================

@arith_add () -> int = 1 + 2

@test_arith_add tests @arith_add () -> void = {
    assert_eq(actual: arith_add(), expected: 3)
}

@arith_sub () -> int = 5 - 2

@test_arith_sub tests @arith_sub () -> void = {
    assert_eq(actual: arith_sub(), expected: 3)
}

@arith_mul () -> int = 3 * 4

@test_arith_mul tests @arith_mul () -> void = {
    assert_eq(actual: arith_mul(), expected: 12)
}

@arith_div () -> int = 10 / 2

@test_arith_div tests @arith_div () -> void = {
    assert_eq(actual: arith_div(), expected: 5)
}

@arith_mod () -> int = 10 % 3

@test_arith_mod tests @arith_mod () -> void = {
    assert_eq(actual: arith_mod(), expected: 1)
}

@arith_floordiv () -> int = 7 div 3

@test_arith_floordiv tests @arith_floordiv () -> void = {
    assert_eq(actual: arith_floordiv(), expected: 2)
}

@arith_neg_floordiv () -> int = -7 div 3

@test_arith_neg_floordiv tests @arith_neg_floordiv () -> void = {
    // Floor division rounds toward negative infinity
    assert_eq(actual: arith_neg_floordiv(), expected: -3)
}

// =============================================================================
// Unary Operators
// =============================================================================

@unary_neg () -> int = -42

@test_unary_neg tests @unary_neg () -> void = {
    assert_eq(actual: unary_neg(), expected: -42)
}

@unary_double_neg () -> int = --42

@test_unary_double_neg tests @unary_double_neg () -> void = {
    assert_eq(actual: unary_double_neg(), expected: 42)
}

@unary_not () -> bool = !false

@test_unary_not tests @unary_not () -> void = {
    assert(cond: unary_not())
}

@unary_double_not () -> bool = !!true

@test_unary_double_not tests @unary_double_not () -> void = {
    assert(cond: unary_double_not())
}

@unary_bit_not () -> int = ~0

@test_unary_bit_not tests @unary_bit_not () -> void = {
    assert_eq(actual: unary_bit_not(), expected: -1)
}

@unary_bit_not_value () -> int = ~0xFF

@test_unary_bit_not_value tests @unary_bit_not_value () -> void = {
    // ~0xFF = -256 in two's complement
    assert_eq(actual: unary_bit_not_value(), expected: -256)
}

// =============================================================================
// Comparison Operators
// =============================================================================

@cmp_eq_true () -> bool = 1 == 1

@test_cmp_eq_true tests @cmp_eq_true () -> void = {
    assert(cond: cmp_eq_true())
}

@cmp_eq_false () -> bool = 1 == 2

@test_cmp_eq_false tests @cmp_eq_false () -> void = {
    assert(cond: !cmp_eq_false())
}

@cmp_neq_true () -> bool = 1 != 2

@test_cmp_neq_true tests @cmp_neq_true () -> void = {
    assert(cond: cmp_neq_true())
}

@cmp_neq_false () -> bool = 1 != 1

@test_cmp_neq_false tests @cmp_neq_false () -> void = {
    assert(cond: !cmp_neq_false())
}

@cmp_lt () -> bool = 1 < 2

@test_cmp_lt tests @cmp_lt () -> void = {
    assert(cond: cmp_lt());
    assert(cond: !(2 < 1));
    assert(cond: !(1 < 1))
}

@cmp_gt () -> bool = 2 > 1

@test_cmp_gt tests @cmp_gt () -> void = {
    assert(cond: cmp_gt());
    assert(cond: !(1 > 2));
    assert(cond: !(1 > 1))
}

@cmp_lte () -> bool = 1 <= 1

@test_cmp_lte tests @cmp_lte () -> void = {
    assert(cond: cmp_lte());
    assert(cond: 1 <= 2);
    assert(cond: !(2 <= 1))
}

@cmp_gte () -> bool = 2 >= 2

@test_cmp_gte tests @cmp_gte () -> void = {
    assert(cond: cmp_gte());
    assert(cond: 3 >= 2);
    assert(cond: !(1 >= 2))
}

// =============================================================================
// Logical Operators
// =============================================================================

@logic_and_tt () -> bool = true && true

@test_logic_and_tt tests @logic_and_tt () -> void = {
    assert(cond: logic_and_tt())
}

@logic_and_tf () -> bool = true && false

@test_logic_and_tf tests @logic_and_tf () -> void = {
    assert(cond: !logic_and_tf())
}

@logic_and_ft () -> bool = false && true

@test_logic_and_ft tests @logic_and_ft () -> void = {
    assert(cond: !logic_and_ft())
}

@logic_and_ff () -> bool = false && false

@test_logic_and_ff tests @logic_and_ff () -> void = {
    assert(cond: !logic_and_ff())
}

@logic_or_tt () -> bool = true || true

@test_logic_or_tt tests @logic_or_tt () -> void = {
    assert(cond: logic_or_tt())
}

@logic_or_tf () -> bool = true || false

@test_logic_or_tf tests @logic_or_tf () -> void = {
    assert(cond: logic_or_tf())
}

@logic_or_ft () -> bool = false || true

@test_logic_or_ft tests @logic_or_ft () -> void = {
    assert(cond: logic_or_ft())
}

@logic_or_ff () -> bool = false || false

@test_logic_or_ff tests @logic_or_ff () -> void = {
    assert(cond: !logic_or_ff())
}

@logic_not_true () -> bool = !true

@test_logic_not_true tests @logic_not_true () -> void = {
    assert(cond: !logic_not_true())
}

@logic_not_false () -> bool = !false

@test_logic_not_false tests @logic_not_false () -> void = {
    assert(cond: logic_not_false())
}

// =============================================================================
// Bitwise Operators
// =============================================================================

@bit_and () -> int = 0b1100 & 0b1010

@test_bit_and tests @bit_and () -> void = {
    assert_eq(actual: bit_and(), expected: 0b1000) // 8
}

@bit_or () -> int = 0b1100 | 0b1010

@test_bit_or tests @bit_or () -> void = {
    assert_eq(actual: bit_or(), expected: 0b1110) // 14
}

@bit_xor () -> int = 0b1100 ^ 0b1010

@test_bit_xor tests @bit_xor () -> void = {
    assert_eq(actual: bit_xor(), expected: 0b0110) // 6
}

@bit_shl () -> int = 1 << 4

@test_bit_shl tests @bit_shl () -> void = {
    assert_eq(actual: bit_shl(), expected: 16)
}

@bit_shr () -> int = 16 >> 2

@test_bit_shr tests @bit_shr () -> void = {
    assert_eq(actual: bit_shr(), expected: 4)
}

@bit_shl_multi () -> int = 3 << 3

@test_bit_shl_multi tests @bit_shl_multi () -> void = {
    // 3 << 3 = 3 * 8 = 24
    assert_eq(actual: bit_shl_multi(), expected: 24)
}

@bit_shr_multi () -> int = 64 >> 3

@test_bit_shr_multi tests @bit_shr_multi () -> void = {
    // 64 >> 3 = 64 / 8 = 8
    assert_eq(actual: bit_shr_multi(), expected: 8)
}

// =============================================================================
// Range Operators
// =============================================================================

@range_excl () -> [int] = for x in 0..5 yield x

@test_range_excl tests @range_excl () -> void = {
    let sum = range_excl().fold(initial: 0, combine: (a, b) -> a + b);
    assert_eq(actual: sum, expected: 10) // 0+1+2+3+4
}

@range_incl () -> [int] = for x in 0..=4 yield x

@test_range_incl tests @range_incl () -> void = {
    let sum = range_incl().fold(initial: 0, combine: (a, b) -> a + b);
    assert_eq(actual: sum, expected: 10) // 0+1+2+3+4
}

@range_step () -> [int] = for x in 0..10 by 2 yield x

@test_range_step tests @range_step () -> void = {
    let result = range_step();
    assert_eq(actual: result.len(), expected: 5) // 0, 2, 4, 6, 8
}

@range_step_incl () -> [int] = for x in 0..=10 by 2 yield x

@test_range_step_incl tests @range_step_incl () -> void = {
    let result = range_step_incl();
    assert_eq(actual: result.len(), expected: 6) // 0, 2, 4, 6, 8, 10
}

@range_descending () -> [int] = for x in 5..0 by -1 yield x

@test_range_descending tests @range_descending () -> void = {
    let result = range_descending();
    assert_eq(actual: result.len(), expected: 5) // 5, 4, 3, 2, 1
}

// =============================================================================
// Null Coalesce Operator
// =============================================================================

@coalesce_some () -> int = {
    let opt: Option<int> = Some(42);
    opt.unwrap_or(default: 0)
}

@test_coalesce_some tests @coalesce_some () -> void = {
    assert_eq(actual: coalesce_some(), expected: 42)
}

@coalesce_none () -> int = {
    let opt: Option<int> = None;
    opt.unwrap_or(default: 100)
}

@test_coalesce_none tests @coalesce_none () -> void = {
    assert_eq(actual: coalesce_none(), expected: 100)
}

// =============================================================================
// Arrow Operators
// =============================================================================

@arrow_lambda () -> int = {
    let f = x -> x + 1;
    f(41)
}

@test_arrow_lambda tests @arrow_lambda () -> void = {
    assert_eq(actual: arrow_lambda(), expected: 42)
}

@arrow_lambda_multi () -> int = {
    let f = (a, b) -> a + b;
    f(20, 22)
}

@test_arrow_lambda_multi tests @arrow_lambda_multi () -> void = {
    assert_eq(actual: arrow_lambda_multi(), expected: 42)
}

// =============================================================================
// Dot Operator (Field/Method Access)
// =============================================================================

type DotTestStruct = { x: int, y: int }

@dot_field_access () -> int = {
    let s = DotTestStruct { x: 10, y: 20 };
    s.x + s.y
}

@test_dot_field_access tests @dot_field_access () -> void = {
    assert_eq(actual: dot_field_access(), expected: 30)
}

@dot_method_chain () -> int = {
    let list = [1, 2, 3, 4, 5];
    list.filter(predicate: x -> x % 2 == 0).len()
}

@test_dot_method_chain tests @dot_method_chain () -> void = {
    assert_eq(actual: dot_method_chain(), expected: 2)
}

// =============================================================================
// Index Operator
// =============================================================================

@index_list () -> int = {
    let list = [10, 20, 30];
    list[0] + list[1] + list[2]
}

@test_index_list tests @index_list () -> void = {
    assert_eq(actual: index_list(), expected: 60)
}

@index_map () -> int = {
    let map = {"a": 1, "b": 2};
    // Map indexing returns Option<V>, unwrap to get the value
    map["a"].unwrap() + map["b"].unwrap()
}

@test_index_map tests @index_map () -> void = {
    assert_eq(actual: index_map(), expected: 3)
}

// =============================================================================
// Operator Precedence Tests
// =============================================================================

// Multiplicative > Additive
@prec_mul_add () -> int = 2 + 3 * 4

@test_prec_mul_add tests @prec_mul_add () -> void = {
    assert_eq(actual: prec_mul_add(), expected: 14) // 2 + 12, not 20
}

@prec_add_mul () -> int = 3 * 4 + 2

@test_prec_add_mul tests @prec_add_mul () -> void = {
    assert_eq(actual: prec_add_mul(), expected: 14) // 12 + 2
}

// Unary > Multiplicative
@prec_unary_mul () -> int = -2 * 3

@test_prec_unary_mul tests @prec_unary_mul () -> void = {
    assert_eq(actual: prec_unary_mul(), expected: -6)
}

// Shift > Comparison
@prec_shift_cmp () -> bool = 1 << 2 < 10

@test_prec_shift_cmp tests @prec_shift_cmp () -> void = {
    assert(cond: prec_shift_cmp()) // 4 < 10
}

// Comparison > Equality
@prec_cmp_eq () -> bool = 1 < 2 == true

@test_prec_cmp_eq tests @prec_cmp_eq () -> void = {
    assert(cond: prec_cmp_eq()) // (1 < 2) == true
}

// Bitwise AND > Bitwise XOR > Bitwise OR
@prec_bitwise () -> int = 0xFF | 0x0F ^ 0x0F & 0xFF

@test_prec_bitwise tests @prec_bitwise () -> void = {
    // 0xFF & 0x0F = 0x0F, 0x0F ^ 0x0F = 0, 0xFF | 0 = 0xFF
    // Actually: & first, then ^, then |
    // 0x0F & 0xFF = 0x0F
    // 0x0F ^ 0x0F = 0x00
    // 0xFF | 0x00 = 0xFF
    assert_eq(actual: prec_bitwise(), expected: 0xFF)
}

// Logical AND > Logical OR
@prec_logic () -> bool = false || true && true

@test_prec_logic tests @prec_logic () -> void = {
    assert(cond: prec_logic()) // false || (true && true) = true
}

@prec_logic_2 () -> bool = true && false || true

@test_prec_logic_2 tests @prec_logic_2 () -> void = {
    assert(cond: prec_logic_2()) // (true && false) || true = true
}

// Parentheses override precedence
@prec_parens () -> int = (2 + 3) * 4

@test_prec_parens tests @prec_parens () -> void = {
    assert_eq(actual: prec_parens(), expected: 20)
}

// =============================================================================
// Operator Associativity Tests
// =============================================================================

// Left associativity for arithmetic
@assoc_sub () -> int = 10 - 4 - 2

@test_assoc_sub tests @assoc_sub () -> void = {
    assert_eq(actual: assoc_sub(), expected: 4) // (10 - 4) - 2 = 4
}

@assoc_div () -> int = 100 / 10 / 2

@test_assoc_div tests @assoc_div () -> void = {
    assert_eq(actual: assoc_div(), expected: 5) // (100 / 10) / 2 = 5
}

// Left associativity for shifts
@assoc_shl () -> int = 1 << 2 << 1

@test_assoc_shl tests @assoc_shl () -> void = {
    assert_eq(actual: assoc_shl(), expected: 8) // (1 << 2) << 1 = 8
}

// =============================================================================
// Complex Expressions
// =============================================================================

@complex_expr_1 () -> int = 1 + 2 * 3 - 4 / 2

@test_complex_expr_1 tests @complex_expr_1 () -> void = {
    // 1 + 6 - 2 = 5
    assert_eq(actual: complex_expr_1(), expected: 5)
}

@complex_expr_2 () -> bool = 1 < 2 && 3 > 1 || false

@test_complex_expr_2 tests @complex_expr_2 () -> void = {
    assert(cond: complex_expr_2())
}

@complex_expr_3 () -> int = (1 + 2) * (3 + 4)

@test_complex_expr_3 tests @complex_expr_3 () -> void = {
    assert_eq(actual: complex_expr_3(), expected: 21)
}

@complex_expr_4 () -> int = ~0 & 0xFF

@test_complex_expr_4 tests @complex_expr_4 () -> void = {
    // ~0 = -1 (all 1s), -1 & 0xFF = 0xFF
    assert_eq(actual: complex_expr_4(), expected: 0xFF)
}

// =============================================================================
// Edge Cases
// =============================================================================

@edge_double_minus () -> int = 5 - -3

@test_edge_double_minus tests @edge_double_minus () -> void = {
    assert_eq(actual: edge_double_minus(), expected: 8)
}

@edge_not_eq () -> bool = !true == false

@test_edge_not_eq tests @edge_not_eq () -> void = {
    assert(cond: edge_not_eq())
}

@edge_chained_cmp () -> bool = 1 < 2 && 2 < 3 && 3 < 4

@test_edge_chained_cmp tests @edge_chained_cmp () -> void = {
    assert(cond: edge_chained_cmp())
}

// Zero operations
@edge_zero_ops () -> int = {
    let a = 0 + 0;
    let b = 0 * 100;
    let c = 0 / 1;
    let d = 0 % 5;
    a + b + c + d
}

@test_edge_zero_ops tests @edge_zero_ops () -> void = {
    assert_eq(actual: edge_zero_ops(), expected: 0)
}

// Identity operations
@edge_identity () -> int = {
    let a = 42 + 0;
    let b = 42 - 0;
    let c = 42 * 1;
    let d = 42 / 1;
    a + b + c + d - 42 * 3 // Should be 42
}

@test_edge_identity tests @edge_identity () -> void = {
    assert_eq(actual: edge_identity(), expected: 42)
}
