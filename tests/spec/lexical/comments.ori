// Spec: 03-lexical-elements.md § Comments
// Tests for comment parsing (grammar.ebnf § comment, doc_comment)

use std.testing { assert, assert_eq }

// =============================================================================
// Basic Line Comments
// =============================================================================

// Basic line comment - verifies comments don't affect parsing
@basic_comment () -> int = 42

@test_basic_comment tests @basic_comment () -> void = run(
    assert_eq(actual: basic_comment(), expected: 42),
)

// Comment with no content after //
@empty_comment () -> int = 100

@test_empty_comment tests @empty_comment () -> void = run(
    assert_eq(actual: empty_comment(), expected: 100),
)

// =============================================================================
// Doc Comments - Description
// =============================================================================

// This is a description doc comment
// It can span multiple lines
// And explains what the function does
@doc_description (x: int) -> int = x * 2

@test_doc_description tests @doc_description () -> void = run(
    assert_eq(actual: doc_description(x: 5), expected: 10),
)

// =============================================================================
// Doc Comments - Parameter Marker (*)
// =============================================================================

// Adds two numbers together
// * a: The first operand
// * b: The second operand
@doc_params (a: int, b: int) -> int = a + b

@test_doc_params tests @doc_params () -> void = run(
    assert_eq(actual: doc_params(a: 3, b: 4), expected: 7),
)

// =============================================================================
// Doc Comments - Warning Marker (!)
// =============================================================================

// Divides a by b
// ! Panics if b is zero
@doc_warning (a: int, b: int) -> int = a / b

@test_doc_warning tests @doc_warning () -> void = run(
    assert_eq(actual: doc_warning(a: 10, b: 2), expected: 5),
)

// =============================================================================
// Doc Comments - Example Marker (>)
// =============================================================================

// Squares a number
// > square(x: 3) -> 9
// > square(x: -2) -> 4
@doc_example (x: int) -> int = x * x

@test_doc_example tests @doc_example () -> void = run(
    assert_eq(actual: doc_example(x: 3), expected: 9),
    assert_eq(actual: doc_example(x: -2), expected: 4),
)

// =============================================================================
// Doc Comments - All Markers Combined
// =============================================================================

// Computes the factorial of n
// * n: A non-negative integer
// ! Panics if n is negative
// > factorial_doc(n: 0) -> 1
// > factorial_doc(n: 5) -> 120
@factorial_doc (n: int) -> int = if n <= 1 then 1 else n * factorial_doc(n: n - 1)

@test_factorial_doc tests @factorial_doc () -> void = run(
    assert_eq(actual: factorial_doc(n: 0), expected: 1),
    assert_eq(actual: factorial_doc(n: 5), expected: 120),
)

// =============================================================================
// Multiple Consecutive Comments
// =============================================================================

// Line 1 of comment block
// Line 2 of comment block
// Line 3 of comment block
// Line 4 of comment block
// Line 5 of comment block
@multi_line_comments () -> int = 100

@test_multi_line_comments tests @multi_line_comments () -> void = run(
    assert_eq(actual: multi_line_comments(), expected: 100),
)

// =============================================================================
// Inline Comments (End of Line)
// =============================================================================

@inline_comment_basic () -> int = run(
    let x = 10, // inline comment after binding
    x,
)

@test_inline_comment_basic tests @inline_comment_basic () -> void = run(
    assert_eq(actual: inline_comment_basic(), expected: 10),
)

@inline_comment_multi () -> int = run(
    let a = 1, // first
    let b = 2, // second
    let c = 3, // third
    a + b + c, // result
)

@test_inline_comment_multi tests @inline_comment_multi () -> void = run(
    assert_eq(actual: inline_comment_multi(), expected: 6),
)

// =============================================================================
// Comments Between Declarations
// =============================================================================

// First function
@comment_between_1 () -> int = 1

// Space for readability

// Second function
@comment_between_2 () -> int = 2

@test_comment_between tests @comment_between_1 tests @comment_between_2 () -> void = run(
    assert_eq(actual: comment_between_1(), expected: 1),
    assert_eq(actual: comment_between_2(), expected: 2),
)

// =============================================================================
// Comments with Special Characters
// =============================================================================

// Comment with symbols: !@#$%^&*()_+-={}[]|\:;"'<>,.?/~`
@comment_special_chars () -> int = 42

@test_comment_special_chars tests @comment_special_chars () -> void = run(
    assert_eq(actual: comment_special_chars(), expected: 42),
)

// Comment with unicode: café, 日本語, emoji test
@comment_unicode () -> int = 42

@test_comment_unicode tests @comment_unicode () -> void = run(
    assert_eq(actual: comment_unicode(), expected: 42),
)

// =============================================================================
// Non-Doc Comments (Separated by Blank Line)
// =============================================================================

// TODO: This is a non-doc comment (separated by blank line)
// FIXME: Another non-doc line

// This is the actual doc comment
@non_doc_separated () -> int = 42

@test_non_doc_separated tests @non_doc_separated () -> void = run(
    assert_eq(actual: non_doc_separated(), expected: 42),
)

// =============================================================================
// Comments in Various Contexts
// =============================================================================

@comment_in_list () -> int = run(
    let list = [
        1, // first element
        2, // second element
        3, // third element
    ],
    list.len(),
)

@test_comment_in_list tests @comment_in_list () -> void = run(
    assert_eq(actual: comment_in_list(), expected: 3),
)

type CommentStructPoint = { x: int, y: int }

@comment_in_struct () -> int = run(
    let p = CommentStructPoint {
        x: 10, // x coordinate
        y: 20, // y coordinate
    },
    p.x + p.y,
)

@test_comment_in_struct tests @comment_in_struct () -> void = run(
    assert_eq(actual: comment_in_struct(), expected: 30),
)

// =============================================================================
// Comments with Code-Like Content
// =============================================================================

// let x = 42 - this looks like code but is just a comment
// @func () -> int = 1 - also just a comment
@comment_code_like () -> int = 99

@test_comment_code_like tests @comment_code_like () -> void = run(
    assert_eq(actual: comment_code_like(), expected: 99),
)

// =============================================================================
// Long Comments
// =============================================================================

// This is a very long comment line that tests the lexer's ability to handle comments that extend for a significant length without any issues because comments can be arbitrarily long
@long_comment () -> int = 42

@test_long_comment tests @long_comment () -> void = run(
    assert_eq(actual: long_comment(), expected: 42),
)

// =============================================================================
// Empty Space After Comment Marker
// =============================================================================

//No space after //
@no_space_comment () -> int = 1

//   Multiple spaces after //
@multi_space_comment () -> int = 2

@test_comment_spacing tests @no_space_comment tests @multi_space_comment () -> void = run(
    assert_eq(actual: no_space_comment(), expected: 1),
    assert_eq(actual: multi_space_comment(), expected: 2),
)

// =============================================================================
// Comments at Different Indentation Levels
// =============================================================================

@comment_indentation () -> int = run(
    // Comment at first level
    let x = run(
        // Comment at second level
        let y = run(
            // Comment at third level
            42,
        ),
        y,
    ),
    x,
)

@test_comment_indentation tests @comment_indentation () -> void = run(
    assert_eq(actual: comment_indentation(), expected: 42),
)

// =============================================================================
// Comments Only (No Code After)
// =============================================================================

// This section has comments but the function below tests they don't interfere

@after_comment_only_section () -> int = 123

@test_after_comment_only tests @after_comment_only_section () -> void = run(
    assert_eq(actual: after_comment_only_section(), expected: 123),
)
