// Spec: 09-expressions.md ยง Binary Expressions, ยง Comparison Operators
// Tests for comparison operators: ==, !=, <, >, <=, >=

use std.testing { assert, assert_eq, assert_ne }

// =============================================================================
// Integer Equality
// =============================================================================

@test_int_eq_true tests @int_eq_true () -> void = run(
    assert(cond: int_eq_true()),
)

@int_eq_true () -> bool = 42 == 42

@test_int_eq_false tests @int_eq_false () -> void = run(
    assert(cond: !int_eq_false()),
)

@int_eq_false () -> bool = 42 == 43

@test_int_ne_true tests @int_ne_true () -> void = run(
    assert(cond: int_ne_true()),
)

@int_ne_true () -> bool = 42 != 43

@test_int_ne_false tests @int_ne_false () -> void = run(
    assert(cond: !int_ne_false()),
)

@int_ne_false () -> bool = 42 != 42

@test_int_eq_negative tests @int_eq_negative () -> void = run(
    assert(cond: int_eq_negative()),
)

@int_eq_negative () -> bool = -5 == -5

@test_int_eq_zero tests @int_eq_zero () -> void = run(
    assert(cond: int_eq_zero()),
)

@int_eq_zero () -> bool = 0 == 0

// =============================================================================
// Integer Ordering
// =============================================================================

@test_int_lt_true tests @int_lt_true () -> void = run(
    assert(cond: int_lt_true()),
)

@int_lt_true () -> bool = 5 < 10

@test_int_lt_false tests @int_lt_false () -> void = run(
    assert(cond: !int_lt_false()),
)

@int_lt_false () -> bool = 10 < 5

@test_int_lt_equal tests @int_lt_equal () -> void = run(
    assert(cond: !int_lt_equal()),
)

@int_lt_equal () -> bool = 5 < 5

@test_int_gt_true tests @int_gt_true () -> void = run(
    assert(cond: int_gt_true()),
)

@int_gt_true () -> bool = 10 > 5

@test_int_gt_false tests @int_gt_false () -> void = run(
    assert(cond: !int_gt_false()),
)

@int_gt_false () -> bool = 5 > 10

@test_int_gt_equal tests @int_gt_equal () -> void = run(
    assert(cond: !int_gt_equal()),
)

@int_gt_equal () -> bool = 5 > 5

@test_int_le_true tests @int_le_true () -> void = run(
    assert(cond: int_le_true()),
)

@int_le_true () -> bool = 5 <= 10

@test_int_le_equal tests @int_le_equal () -> void = run(
    assert(cond: int_le_equal()),
)

@int_le_equal () -> bool = 5 <= 5

@test_int_le_false tests @int_le_false () -> void = run(
    assert(cond: !int_le_false()),
)

@int_le_false () -> bool = 10 <= 5

@test_int_ge_true tests @int_ge_true () -> void = run(
    assert(cond: int_ge_true()),
)

@int_ge_true () -> bool = 10 >= 5

@test_int_ge_equal tests @int_ge_equal () -> void = run(
    assert(cond: int_ge_equal()),
)

@int_ge_equal () -> bool = 5 >= 5

@test_int_ge_false tests @int_ge_false () -> void = run(
    assert(cond: !int_ge_false()),
)

@int_ge_false () -> bool = 5 >= 10

// =============================================================================
// Integer Edge Cases
// =============================================================================

@test_int_compare_negatives tests @int_compare_negatives () -> void = run(
    assert(cond: -10 < -5),
    assert(cond: -5 > -10),
    assert(cond: -5 <= -5),
    assert(cond: -5 >= -5),
)

@int_compare_negatives () -> bool = -10 < -5

@test_int_compare_mixed_sign tests @int_compare_mixed_sign () -> void = run(
    assert(cond: -100 < 1),
    assert(cond: 0 > -1),
)

@int_compare_mixed_sign () -> bool = -100 < 1

// =============================================================================
// Float Equality
// =============================================================================

@test_float_eq_true tests @float_eq_true () -> void = run(
    assert(cond: float_eq_true()),
)

@float_eq_true () -> bool = 3.14 == 3.14

@test_float_eq_false tests @float_eq_false () -> void = run(
    assert(cond: !float_eq_false()),
)

@float_eq_false () -> bool = 3.14 == 3.15

@test_float_precision_issue tests @float_precision_issue () -> void = run(
    // 0.1 + 0.2 != 0.3 due to floating-point representation
    assert(cond: !float_precision_issue()),
)

@float_precision_issue () -> bool = 0.1 + 0.2 == 0.3

@test_float_nan_eq tests @float_nan_eq () -> void = run(
    // NaN != NaN per IEEE 754
    let nan = 0.0 / 0.0,
    assert(cond: !(nan == nan)),
)

@float_nan_eq () -> bool = run(
    let nan = 0.0 / 0.0,
    nan == nan,
)

@test_float_nan_ne tests @float_nan_ne () -> void = run(
    // NaN != NaN is true per IEEE 754
    let nan = 0.0 / 0.0,
    assert(cond: nan != nan),
)

@float_nan_ne () -> bool = run(
    let nan = 0.0 / 0.0,
    nan != nan,
)

// =============================================================================
// Float Ordering
// =============================================================================

@test_float_lt tests @float_lt () -> void = run(
    assert(cond: float_lt()),
)

@float_lt () -> bool = 1.5 < 2.5

@test_float_gt tests @float_gt () -> void = run(
    assert(cond: float_gt()),
)

@float_gt () -> bool = 2.5 > 1.5

@test_float_le tests @float_le () -> void = run(
    assert(cond: 1.5 <= 2.5),
    assert(cond: 1.5 <= 1.5),
)

@float_le () -> bool = 1.5 <= 2.5

@test_float_ge tests @float_ge () -> void = run(
    assert(cond: 2.5 >= 1.5),
    assert(cond: 2.5 >= 2.5),
)

@float_ge () -> bool = 2.5 >= 1.5

// =============================================================================
// String Equality
// =============================================================================

@test_str_eq_true tests @str_eq_true () -> void = run(
    assert(cond: str_eq_true()),
)

@str_eq_true () -> bool = "hello" == "hello"

@test_str_eq_false tests @str_eq_false () -> void = run(
    assert(cond: !str_eq_false()),
)

@str_eq_false () -> bool = "hello" == "world"

@test_str_ne_true tests @str_ne_true () -> void = run(
    assert(cond: str_ne_true()),
)

@str_ne_true () -> bool = "hello" != "world"

@test_str_empty tests @str_empty () -> void = run(
    assert(cond: "" == ""),
    assert(cond: !("" == "x")),
)

@str_empty () -> bool = "" == ""

@test_str_case_sensitive tests @str_case_sensitive () -> void = run(
    assert(cond: str_case_sensitive()),
)

@str_case_sensitive () -> bool = "Hello" != "hello"

// =============================================================================
// String Ordering (Lexicographic)
// =============================================================================

@test_str_lt tests @str_lt () -> void = run(
    assert(cond: str_lt()),
)

@str_lt () -> bool = "apple" < "banana"

@test_str_gt tests @str_gt () -> void = run(
    assert(cond: str_gt()),
)

@str_gt () -> bool = "banana" > "apple"

@test_str_le tests @str_le () -> void = run(
    assert(cond: "apple" <= "banana"),
    assert(cond: "apple" <= "apple"),
)

@str_le () -> bool = "apple" <= "banana"

@test_str_ge tests @str_ge () -> void = run(
    assert(cond: "banana" >= "apple"),
    assert(cond: "apple" >= "apple"),
)

@str_ge () -> bool = "banana" >= "apple"

@test_str_prefix tests @str_prefix () -> void = run(
    // "ab" < "abc" (prefix is less than longer string)
    assert(cond: "ab" < "abc"),
)

@str_prefix () -> bool = "ab" < "abc"

// =============================================================================
// Boolean Equality
// =============================================================================

@test_bool_eq tests @bool_eq () -> void = run(
    assert(cond: true == true),
    assert(cond: false == false),
    assert(cond: !(true == false)),
)

@bool_eq () -> bool = true == true

@test_bool_ne tests @bool_ne () -> void = run(
    assert(cond: true != false),
    assert(cond: !(true != true)),
)

@bool_ne () -> bool = true != false

// =============================================================================
// Char Equality
// =============================================================================

@test_char_eq tests @char_eq () -> void = run(
    assert(cond: char_eq()),
)

@char_eq () -> bool = 'a' == 'a'

@test_char_ne tests @char_ne () -> void = run(
    assert(cond: char_ne()),
)

@char_ne () -> bool = 'a' != 'b'

@test_char_lt tests @char_lt () -> void = run(
    assert(cond: char_lt()),
)

@char_lt () -> bool = 'a' < 'b'

@test_char_unicode tests @char_unicode () -> void = run(
    assert(cond: 'a' < 'z'),
    assert(cond: 'A' < 'a'), // ASCII: uppercase before lowercase
)

@char_unicode () -> bool = 'a' < 'z'

// =============================================================================
// Option Comparison
// =============================================================================

@test_option_eq_some tests @option_eq_some () -> void = run(
    assert(cond: option_eq_some()),
)

@option_eq_some () -> bool = Some(42) == Some(42)

@test_option_eq_none tests @option_eq_none () -> void = run(
    let a: Option<int> = None,
    let b: Option<int> = None,
    assert(cond: a == b),
)

@option_eq_none () -> bool = run(
    let a: Option<int> = None,
    let b: Option<int> = None,
    a == b,
)

@test_option_ne_some_none tests @option_ne_some_none () -> void = run(
    assert(cond: option_ne_some_none()),
)

@option_ne_some_none () -> bool = Some(42) != None

// STATUS: Lexer [OK], Parser [OK], Evaluator [BROKEN] - operator '<' not implemented for Option
@test_option_order tests @option_order () -> void = run(
    // None < Some(x) for all x
    let none: Option<int> = None,
    assert(cond: none < Some(0)),
    assert(cond: none < Some(-100)),
)

@option_order () -> bool = run(
    let none: Option<int> = None,
    none < Some(0),
)

// =============================================================================
// Result Comparison
// =============================================================================

@test_result_eq_ok tests @result_eq_ok () -> void = run(
    let a: Result<int, str> = Ok(42),
    let b: Result<int, str> = Ok(42),
    assert(cond: a == b),
)

@result_eq_ok () -> bool = run(
    let a: Result<int, str> = Ok(42),
    let b: Result<int, str> = Ok(42),
    a == b,
)

@test_result_eq_err tests @result_eq_err () -> void = run(
    let a: Result<int, str> = Err("error"),
    let b: Result<int, str> = Err("error"),
    assert(cond: a == b),
)

@result_eq_err () -> bool = run(
    let a: Result<int, str> = Err("error"),
    let b: Result<int, str> = Err("error"),
    a == b,
)

@test_result_ne tests @result_ne () -> void = run(
    let ok: Result<int, str> = Ok(42),
    let err: Result<int, str> = Err("error"),
    assert(cond: ok != err),
)

@result_ne () -> bool = run(
    let ok: Result<int, str> = Ok(42),
    let err: Result<int, str> = Err("error"),
    ok != err,
)

// =============================================================================
// List Equality
// =============================================================================

@test_list_eq tests @list_eq () -> void = run(
    assert(cond: list_eq()),
)

@list_eq () -> bool = [1, 2, 3] == [1, 2, 3]

@test_list_ne_values tests @list_ne_values () -> void = run(
    assert(cond: list_ne_values()),
)

@list_ne_values () -> bool = [1, 2, 3] != [1, 2, 4]

@test_list_ne_length tests @list_ne_length () -> void = run(
    assert(cond: list_ne_length()),
)

@list_ne_length () -> bool = [1, 2] != [1, 2, 3]

@test_list_empty_eq tests @list_empty_eq () -> void = run(
    let a: [int] = [],
    let b: [int] = [],
    assert(cond: a == b),
)

@list_empty_eq () -> bool = run(
    let a: [int] = [],
    let b: [int] = [],
    a == b,
)

// =============================================================================
// Struct Equality (with #derive(Eq))
// =============================================================================
//
// STATUS: Lexer [OK], Parser [OK], Evaluator [BROKEN] - cannot apply operator to struct
// #derive(Eq) not generating equality implementation for user-defined structs.

type Point = { x: int, y: int }
#derive(Eq) type PointEq = { x: int, y: int }

@test_struct_eq tests @struct_eq () -> void = run(
    let a = PointEq { x: 1, y: 2 },
    let b = PointEq { x: 1, y: 2 },
    assert(cond: a == b),
)

@struct_eq () -> bool = run(
    let a = PointEq { x: 1, y: 2 },
    let b = PointEq { x: 1, y: 2 },
    a == b,
)

@test_struct_ne tests @struct_ne () -> void = run(
    let a = PointEq { x: 1, y: 2 },
    let b = PointEq { x: 1, y: 3 },
    assert(cond: a != b),
)

@struct_ne () -> bool = run(
    let a = PointEq { x: 1, y: 2 },
    let b = PointEq { x: 1, y: 3 },
    a != b,
)

// =============================================================================
// Chained Comparisons (Not Supported - Must Use &&)
// =============================================================================

@test_chained_comparison tests @chained_comparison () -> void = run(
    // Ori does NOT support chained comparisons like 1 < 2 < 3
    // Must use && instead
    let x = 5,
    assert(cond: 0 < x && x < 10),
)

@chained_comparison () -> bool = run(
    let x = 5,
    0 < x && x < 10,
)

// =============================================================================
// Comparison with Expressions
// =============================================================================

@test_compare_expressions tests @compare_expressions () -> void = run(
    assert(cond: compare_expressions()),
)

@compare_expressions () -> bool = (2 + 3) == (1 + 4)

@test_compare_function_results tests @compare_function_results () -> void = run(
    assert(cond: compare_function_results()),
)

@double (x: int) -> int = x * 2

@compare_function_results () -> bool = double(x: 5) == 10
