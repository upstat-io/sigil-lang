// Spec: 09-expressions.md ยง Conversion Expressions
// Tests for type conversion: as (infallible) and as? (fallible)
//
// TODO: Type checker needs various features
// - `as` and `as?` conversion operators
// - Conversion functions (`int()`, `float()`, `str()`)
// - Method calls on converted values (`.unwrap_or`, `.truncate`)
// - Option<T> result from fallible conversions
//
// Uncomment when type checker supports these features.

// use std.testing { assert, assert_eq }
//
// // Type for as_after_field tests (moved outside - local type defs not supported)
// type ConvPoint = { x: int, y: int }
//
// @int_to_float () -> float = 42 as float
//
// @int_to_float_zero () -> float = 0 as float
//
// @int_to_float_negative () -> float = -100 as float
//
// @int_to_float_large () -> float = 1000000 as float
//
// @int_to_byte () -> byte = 255 as byte
//
// @int_to_byte_zero () -> byte = 0 as byte
//
// @byte_to_int () -> int = run(
//     let b = 42 as byte,
//     b as int,
// )
//
// @byte_to_int_max () -> int = run(
//     let b = 255 as byte,
//     b as int,
// )
//
// // ASCII 'A'
// @char_to_int () -> int = 'A' as int
//
// // ASCII 'a'
// @char_to_int_lowercase () -> int = 'a' as int
//
// // ASCII '0'
// @char_to_int_digit () -> int = '0' as int
//
// @int_to_char () -> char = 65 as char
//
// @int_to_char_lowercase () -> char = 97 as char
//
// @str_to_int_valid () -> Option<int> = "42" as? int
//
// @str_to_int_negative () -> Option<int> = "-100" as? int
//
// @str_to_int_zero () -> Option<int> = "0" as? int
//
// @str_to_int_invalid () -> Option<int> = "hello" as? int
//
// @str_to_int_empty () -> Option<int> = "" as? int
//
// @str_to_int_mixed () -> Option<int> = "42abc" as? int
//
// // Behavior depends on implementation - may or may not trim
// // Test that it returns Some or None consistently
// @str_to_int_whitespace () -> Option<int> = " 42 " as? int
//
// @str_to_float_valid () -> Option<float> = "3.14" as? float
//
// @str_to_float_int_format () -> Option<float> = "42" as? float
//
// @str_to_float_scientific () -> Option<float> = "1e10" as? float
//
// @str_to_float_invalid () -> Option<float> = "not a number" as? float
//
// @str_to_bool_true () -> Option<bool> = "true" as? bool
//
// @str_to_bool_false () -> Option<bool> = "false" as? bool
//
// @str_to_bool_invalid () -> Option<bool> = "yes" as? bool
//
// // int -> float, then use in expression
// @chain_conversions () -> float = 10 as float * 2.5
//
// // Postfix as/as? can chain with methods
// @as_then_method () -> int = "42" as? int.unwrap_or(default: 0)
//
// // Note: `as` binds tighter than `+`, so parentheses are needed
// // Without parens: 10 + (20 as float) = int + float (type error)
// // With parens: (10 + 20) as float = 30 as float = 30.0
// @convert_expression () -> float = (10 + 20) as float
//
// @convert_in_condition () -> str = run(
//     let input = "42",
//     if is_some(opt: input as? int) then "valid" else "invalid",
// )
//
// @fallible_with_coalesce () -> int = "not a number" as? int ?? 0
//
// @int_function () -> Option<int> = int("42")
//
// @float_function () -> float = float(42)
//
// @str_function () -> str = str(42)
//
// @str_from_bool () -> str = str(true)
//
// // Float to string representation
// @str_from_float () -> str = str(3.14)
//
// // as is postfix, binds tighter than arithmetic
// // 10 as float + 5.0 is (10 as float) + 5.0 = 15.0
// @as_binds_tight () -> float = 10 as float + 5.0
//
// // list[0] as float - postfix chains
// @as_after_index () -> float = [1, 2, 3][0] as float
//
// @as_after_field () -> float = run(
//     let p = ConvPoint { x: 5, y: 10 },
//     p.x as float,
// )
//
// @safe_parse () -> [int] = run(
//     let inputs = ["1", "2", "three", "4"],
//     for s in inputs yield s as? int ?? 0,
// )
//
// // Note: `as` binds tighter than `+`, so parentheses are needed
// // Without parens: ('A' as int) + (1 as char) = int + char (type error)
// // With parens: ('A' as int + 1) as char = (65 + 1) as char = 66 as char = 'B'
// @char_arithmetic () -> char = ('A' as int + 1) as char
//
// // Note: Large ints may lose precision
// @roundtrip_int_float () -> int = run(
//     let i = 42,
//     let f = i as float,
//     f.truncate(),
// )
//
// @parse_with_leading_zero () -> Option<int> = "007" as? int
//
// @negative_zero () -> Option<int> = "-0" as? int
//
// // =============================================================================
// // Infallible Conversions (as)
// // =============================================================================
// // int -> float
// @test_int_to_float tests @int_to_float () -> void = run(
//     let f = 42 as float,
//     assert(cond: f > 41.9),
//     assert(cond: f < 42.1),
// )
//
// @test_int_to_float_zero tests @int_to_float_zero () -> void = run(
//     let f = 0 as float,
//     assert_eq(actual: f, expected: 0.0),
// )
//
// @test_int_to_float_negative tests @int_to_float_negative () -> void = run(
//     let f = -100 as float,
//     assert(cond: f < -99.9),
//     assert(cond: f > -100.1),
// )
//
// @test_int_to_float_large tests @int_to_float_large () -> void = run(
//     let f = 1000000 as float,
//     assert(cond: f > 999999.0),
//     assert(cond: f < 1000001.0),
// )
//
// // int -> byte
// @test_int_to_byte tests @int_to_byte () -> void = run(
//     let b = 255 as byte,
//     assert_eq(actual: b as int, expected: 255),
// )
//
// @test_int_to_byte_zero tests @int_to_byte_zero () -> void = run(
//     let b = 0 as byte,
//     assert_eq(actual: b as int, expected: 0),
// )
//
// // byte -> int
// @test_byte_to_int tests @byte_to_int () -> void = run(
//     let b = 42 as byte,
//     let i = b as int,
//     assert_eq(actual: i, expected: 42),
// )
//
// @test_byte_to_int_max tests @byte_to_int_max () -> void = run(
//     let b = 255 as byte,
//     let i = b as int,
//     assert_eq(actual: i, expected: 255),
// )
//
// // char -> int
// @test_char_to_int tests @char_to_int () -> void = run(
//     let c = 'A',
//     let i = c as int,
//     assert_eq(actual: i, expected: 65),
// )
//
// @test_char_to_int_lowercase tests @char_to_int_lowercase () -> void = run(
//     let c = 'a',
//     let i = c as int,
//     assert_eq(actual: i, expected: 97),
// )
//
// @test_char_to_int_digit tests @char_to_int_digit () -> void = run(
//     let c = '0',
//     let i = c as int,
//     assert_eq(actual: i, expected: 48),
// )
//
// // int -> char
// @test_int_to_char tests @int_to_char () -> void = run(
//     let i = 65,
//     let c = i as char,
//     assert_eq(actual: c, expected: 'A'),
// )
//
// @test_int_to_char_lowercase tests @int_to_char_lowercase () -> void = run(
//     let i = 97,
//     let c = i as char,
//     assert_eq(actual: c, expected: 'a'),
// )
//
// // =============================================================================
// // Fallible Conversions (as?)
// // =============================================================================
// // str -> int
// @test_str_to_int_valid tests @str_to_int_valid () -> void = run(
//     let result = "42" as? int,
//     assert_eq(actual: result, expected: Some(42)),
// )
//
// @test_str_to_int_negative tests @str_to_int_negative () -> void = run(
//     let result = "-100" as? int,
//     assert_eq(actual: result, expected: Some(-100)),
// )
//
// @test_str_to_int_zero tests @str_to_int_zero () -> void = run(
//     let result = "0" as? int,
//     assert_eq(actual: result, expected: Some(0)),
// )
//
// @test_str_to_int_invalid tests @str_to_int_invalid () -> void = run(
//     let result = "hello" as? int,
//     assert_eq(actual: result, expected: None),
// )
//
// @test_str_to_int_empty tests @str_to_int_empty () -> void = run(
//     let result = "" as? int,
//     assert_eq(actual: result, expected: None),
// )
//
// @test_str_to_int_mixed tests @str_to_int_mixed () -> void = run(
//     let result = "42abc" as? int,
//     assert_eq(actual: result, expected: None),
// )
//
// @test_str_to_int_whitespace tests @str_to_int_whitespace () -> void = run(
//     let result = " 42 " as? int,
//     assert(cond: is_some(opt: result) || is_none(opt: result)),
// )
//
// // str -> float
// @test_str_to_float_valid tests @str_to_float_valid () -> void = run(
//     let result = "3.14" as? float,
//     assert(cond: is_some(opt: result)),
//     let value = result ?? 0.0,
//     assert(cond: value > 3.13),
//     assert(cond: value < 3.15),
// )
//
// @test_str_to_float_int_format tests @str_to_float_int_format () -> void = run(
//     let result = "42" as? float,
//     assert(cond: is_some(opt: result)),
//     let value = result ?? 0.0,
//     assert(cond: value > 41.9),
//     assert(cond: value < 42.1),
// )
//
// @test_str_to_float_scientific tests @str_to_float_scientific () -> void = run(
//     let result = "1e10" as? float,
//     assert(cond: is_some(opt: result)),
// )
//
// @test_str_to_float_invalid tests @str_to_float_invalid () -> void = run(
//     let result = "not a number" as? float,
//     assert_eq(actual: result, expected: None),
// )
//
// // str -> bool
// //
// // STATUS: Evaluator [BROKEN] - str to bool fallible conversion not implemented
// // "true" as? bool returns None instead of Some(true)
// #skip("str to bool fallible conversion not implemented")
// @test_str_to_bool_true tests @str_to_bool_true () -> void = run(
//     let result = "true" as? bool,
//     assert_eq(actual: result, expected: Some(true)),
// )
//
// #skip("str to bool fallible conversion not implemented")
// @test_str_to_bool_false tests @str_to_bool_false () -> void = run(
//     let result = "false" as? bool,
//     assert_eq(actual: result, expected: Some(false)),
// )
//
// @test_str_to_bool_invalid tests @str_to_bool_invalid () -> void = run(
//     let result = "yes" as? bool,
//     assert_eq(actual: result, expected: None),
// )
//
// // =============================================================================
// // Chained Conversions
// // =============================================================================
// @test_chain_conversions tests @chain_conversions () -> void = run(
//     let f = 10 as float,
//     let result = f * 2.5,
//     assert(cond: result > 24.9),
//     assert(cond: result < 25.1),
// )
//
// @test_as_then_method tests @as_then_method () -> void = run(
//     let opt = "42" as? int,
//     let value = opt.unwrap_or(default: 0),
//     assert_eq(actual: value, expected: 42),
// )
//
// // =============================================================================
// // Conversion with Expressions
// // =============================================================================
// @test_convert_expression tests @convert_expression () -> void = run(
//     let sum = (10 + 20) as float,
//     assert(cond: sum > 29.9),
//     assert(cond: sum < 30.1),
// )
//
// @test_convert_in_condition tests @convert_in_condition () -> void = run(
//     let input = "42",
//     let result = if is_some(opt: input as? int) then "valid" else "invalid",
//     assert_eq(actual: result, expected: "valid"),
// )
//
// @test_fallible_with_coalesce tests @fallible_with_coalesce () -> void = run(
//     let value = "not a number" as? int ?? 0,
//     assert_eq(actual: value, expected: 0),
// )
//
// // =============================================================================
// // Type Conversion Functions
// // =============================================================================
// //
// // STATUS: Evaluator [BROKEN] - int(str) conversion function not implemented
// #skip("int(str) conversion function not implemented")
// @test_int_function tests @int_function () -> void = run(
//     let s = "42",
//     let result = int(s),
//     assert(cond: is_some(opt: result)),
// )
//
// @test_float_function tests @float_function () -> void = run(
//     let i = 42,
//     let f = float(i),
//     assert(cond: f > 41.9),
//     assert(cond: f < 42.1),
// )
//
// @test_str_function tests @str_function () -> void = run(
//     let i = 42,
//     let s = str(i),
//     assert_eq(actual: s, expected: "42"),
// )
//
// @test_str_from_bool tests @str_from_bool () -> void = run(
//     assert_eq(actual: str(true), expected: "true"),
//     assert_eq(actual: str(false), expected: "false"),
// )
//
// @test_str_from_float tests @str_from_float () -> void = run(
//     let s = str(3.14),
//     assert(cond: s.len() > 0),
// )
//
// // =============================================================================
// // Precedence Tests
// // =============================================================================
// @test_as_binds_tight tests @as_binds_tight () -> void = run(
//     let result = 10 as float + 5.0,
//     assert(cond: result > 14.9),
//     assert(cond: result < 15.1),
// )
//
// @test_as_after_index tests @as_after_index () -> void = run(
//     let list = [1, 2, 3],
//     let f = list[0] as float,
//     assert(cond: f > 0.9),
//     assert(cond: f < 1.1),
// )
//
// @test_as_after_field tests @as_after_field () -> void = run(
//     let p = ConvPoint { x: 5, y: 10 },
//     let f = p.x as float,
//     assert(cond: f > 4.9),
//     assert(cond: f < 5.1),
// )
//
// // =============================================================================
// // Practical Patterns
// // =============================================================================
// @test_safe_parse tests @safe_parse () -> void = run(
//     let inputs = ["1", "2", "three", "4"],
//     let numbers = for s in inputs yield s as? int ?? 0,
//     assert_eq(actual: numbers, expected: [1, 2, 0, 4]),
// )
//
// @test_numeric_operations tests @test_numeric_operations () -> void = run(
//     let i = 10,
//     let f = 3.0,
//     let result = i as float / f,
//     assert(cond: result > 3.3),
//     assert(cond: result < 3.4),
// )
//
// // Mix int and float operations
// @test_numeric_operations () -> float = run(
//     let i = 10,
//     let f = 3.0,
//     i as float / f,
// )
//
// @test_char_arithmetic tests @char_arithmetic () -> void = run(
//     let c = 'A',
//     let i = c as int,
//     let next_char = (i + 1) as char,
//     assert_eq(actual: next_char, expected: 'B'),
// )
//
// // =============================================================================
// // Edge Cases
// // =============================================================================
// #skip("float.truncate() method not implemented")
// @test_roundtrip_int_float tests @roundtrip_int_float () -> void = run(
//     let i = 42,
//     let f = i as float,
//     let back = f.truncate(),
//     assert_eq(actual: back, expected: 42),
// )
//
// @test_parse_with_leading_zero tests @parse_with_leading_zero () -> void = run(
//     let result = "007" as? int,
//     assert_eq(actual: result, expected: Some(7)),
// )
//
// @test_negative_zero tests @negative_zero () -> void = run(
//     let result = "-0" as? int,
//     assert_eq(actual: result, expected: Some(0)),
// )
