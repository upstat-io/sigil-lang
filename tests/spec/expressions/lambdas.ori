// Spec: 09-expressions.md ยง Lambda

use std.testing { assert_eq }
// Tests for lambda expressions: simple, typed, closures, multi-param

// =============================================================================
// Simple Lambdas (Single Parameter, Untyped)
// =============================================================================

@test_simple_lambda tests @simple_lambda () -> void = {
    let f = x -> x + 1;
    assert_eq(actual: f(5), expected: 6)
}

@simple_lambda () -> int = {
    let f = x -> x + 1;
    f(5)
}

@test_simple_lambda_identity tests @simple_lambda_identity () -> void = {
    let f = x -> x;
    assert_eq(actual: f(42), expected: 42)
}

@simple_lambda_identity () -> int = {
    let f = x -> x;
    f(42)
}

@test_simple_lambda_multiply tests @simple_lambda_multiply () -> void = {
    let double = x -> x * 2;
    assert_eq(actual: double(5), expected: 10)
}

@simple_lambda_multiply () -> int = {
    let double = x -> x * 2;
    double(5)
}

@test_simple_lambda_negative tests @simple_lambda_negative () -> void = {
    let negate = x -> -x;
    assert_eq(actual: negate(5), expected: -5)
}

@simple_lambda_negative () -> int = {
    let negate = x -> -x;
    negate(5)
}

// =============================================================================
// Multi-Parameter Lambdas (Untyped)
// =============================================================================

@test_multi_param_lambda tests @multi_param_lambda () -> void = {
    let add = (a, b) -> a + b;
    assert_eq(actual: add(3, 4), expected: 7)
}

@multi_param_lambda () -> int = {
    let add = (a, b) -> a + b;
    add(3, 4)
}

@test_three_param_lambda tests @three_param_lambda () -> void = {
    let sum3 = (a, b, c) -> a + b + c;
    assert_eq(actual: sum3(1, 2, 3), expected: 6)
}

@three_param_lambda () -> int = {
    let sum3 = (a, b, c) -> a + b + c;
    sum3(1, 2, 3)
}

@test_multi_param_order tests @multi_param_order () -> void = {
    let sub = (a, b) -> a - b;
    assert_eq(actual: sub(10, 3), expected: 7);
    assert_eq(actual: sub(3, 10), expected: -7)
}

@multi_param_order () -> int = {
    let sub = (a, b) -> a - b;
    sub(10, 3)
}

// =============================================================================
// No-Parameter Lambdas
// =============================================================================

@test_no_param_lambda tests @no_param_lambda () -> void = {
    let f = () -> 42;
    assert_eq(actual: f(), expected: 42)
}

@no_param_lambda () -> int = {
    let f = () -> 42;
    f()
}

@test_no_param_lambda_expression tests @no_param_lambda_expression () -> void = {
    let f = () -> 1 + 2 + 3;
    assert_eq(actual: f(), expected: 6)
}

@no_param_lambda_expression () -> int = {
    let f = () -> 1 + 2 + 3;
    f()
}

// =============================================================================
// Typed Lambda Parameters
// =============================================================================

@test_typed_lambda tests @typed_lambda () -> void = {
    let f = (x: int) -> x * 2;
    assert_eq(actual: f(x: 5), expected: 10)
}

@typed_lambda () -> int = {
    let f = (x: int) -> x * 2;
    f(x: 5)
}

@test_multi_typed_lambda tests @multi_typed_lambda () -> void = {
    let f = (a: int, b: int) -> a - b;
    assert_eq(actual: f(a: 10, b: 3), expected: 7)
}

@multi_typed_lambda () -> int = {
    let f = (a: int, b: int) -> a - b;
    f(a: 10, b: 3)
}

// =============================================================================
// Lambda with Explicit Return Type
// =============================================================================

@test_lambda_return_type tests @lambda_return_type () -> void = {
    let f = (x: int) -> int = x + 1;
    assert_eq(actual: f(x: 5), expected: 6)
}

@lambda_return_type () -> int = {
    let f = (x: int) -> int = x + 1;
    f(x: 5)
}

@test_no_param_typed_return tests @no_param_typed_return () -> void = {
    let f = () -> int = 100;
    assert_eq(actual: f(), expected: 100)
}

@no_param_typed_return () -> int = {
    let f = () -> int = 100;
    f()
}

// =============================================================================
// Closures (Capturing Variables)
// =============================================================================

@test_closure_capture tests @closure_capture () -> void = {
    let x = 10;
    let f = y -> x + y;
    assert_eq(actual: f(5), expected: 15)
}

@closure_capture () -> int = {
    let x = 10;
    let f = y -> x + y;
    f(5)
}

@test_closure_capture_multiple tests @closure_capture_multiple () -> void = {
    let a = 10;
    let b = 20;
    let f = x -> a + b + x;
    assert_eq(actual: f(5), expected: 35)
}

@closure_capture_multiple () -> int = {
    let a = 10;
    let b = 20;
    let f = x -> a + b + x;
    f(5)
}

@test_closure_nested tests @closure_nested () -> void = {
    let x = 1;
    let f = a -> {
        let y = 2;
        let g = b -> x + y + a + b;
        g(4)
    };
    assert_eq(actual: f(3), expected: 10)
}

@closure_nested () -> int = {
    let x = 1;
    let f = a -> {
        let y = 2;
        let g = b -> x + y + a + b;
        g(4)
    };
    f(3)
}

// =============================================================================
// Lambdas as Arguments (to for yield)
// =============================================================================

@test_lambda_to_for tests @lambda_to_for () -> void = {
    let double = x -> x * 2;
    let result = for x in [1, 2, 3] yield double(x);
    assert_eq(actual: result[0], expected: 2);
    assert_eq(actual: result[1], expected: 4);
    assert_eq(actual: result[2], expected: 6)
}

@lambda_to_for () -> [int] = {
    let double = x -> x * 2;
    for x in [1, 2, 3] yield double(x)
}

@test_inline_lambda_in_for tests @inline_lambda_in_for () -> void = {
    let result = for x in [1, 2, 3] yield (y -> y * 2)(x);
    assert_eq(actual: result[0], expected: 2);
    assert_eq(actual: result[1], expected: 4)
}

@inline_lambda_in_for () -> [int] = for x in [1, 2, 3] yield (y -> y * 2)(x);

// =============================================================================
// Immediately Invoked Lambdas
// =============================================================================

@test_iife tests @iife () -> void = {
    let result = (x -> x * 2)(5);
    assert_eq(actual: result, expected: 10)
}

@iife () -> int = (x -> x * 2)(5);

@test_iife_no_params tests @iife_no_params () -> void = {
    let result = (() -> 42)();
    assert_eq(actual: result, expected: 42)
}

@iife_no_params () -> int = (() -> 42)();

@test_iife_multi_param tests @iife_multi_param () -> void = {
    let result = ((a, b) -> a + b)(3, 4);
    assert_eq(actual: result, expected: 7)
}

@iife_multi_param () -> int = ((a, b) -> a + b)(3, 4);

// =============================================================================
// Lambda in Different Contexts
// =============================================================================

@test_lambda_in_let tests @lambda_in_let () -> void = {
    let f = x -> x + 1;
    let g = f;
    assert_eq(actual: g(5), expected: 6)
}

@lambda_in_let () -> int = {
    let f = x -> x + 1;
    let g = f;
    g(5)
}

@test_lambda_in_conditional tests @lambda_in_conditional () -> void = {
    let use_add = true;
    let f = if use_add then (a, b) -> a + b else (a, b) -> a - b;
    assert_eq(actual: f(10, 3), expected: 13)
}

@lambda_in_conditional () -> int = {
    let use_add = true;
    let f = if use_add then (a, b) -> a + b else (a, b) -> a - b;
    f(10, 3)
}

// =============================================================================
// Lambda with Complex Bodies
// =============================================================================

@test_lambda_with_run tests @lambda_with_run () -> void = {
    let f = x -> {
        let doubled = x * 2;
        let tripled = x * 3;
        doubled + tripled
    };
    assert_eq(actual: f(5), expected: 25)
}

@lambda_with_run () -> int = {
    let f = x -> {
        let doubled = x * 2;
        let tripled = x * 3;
        doubled + tripled
    };
    f(5)
}

@test_lambda_with_conditional tests @lambda_with_conditional () -> void = {
    let abs = x -> if x < 0 then -x else x;
    assert_eq(actual: abs(5), expected: 5);
    assert_eq(actual: abs(-5), expected: 5)
}

@lambda_with_conditional () -> int = {
    let abs = x -> if x < 0 then -x else x;
    abs(-5)
}

// =============================================================================
// Lambda Type Inference
// =============================================================================

@test_lambda_infer_from_use tests @lambda_infer_from_use () -> void = {
    let f = x -> x + 1;
    let result: int = f(5);
    assert_eq(actual: result, expected: 6)
}

@lambda_infer_from_use () -> int = {
    let f = x -> x + 1;
    f(5)
}

// =============================================================================
// Higher-Order Function Patterns
// =============================================================================

@apply_fn (f: (int) -> int, x: int) -> int = f(x);

@test_pass_lambda_to_function tests @pass_lambda_to_function () -> void = {
    let result = apply_fn(f: x -> x * 2, x: 5);
    assert_eq(actual: result, expected: 10)
}

@pass_lambda_to_function () -> int = apply_fn(f: x -> x * 2, x: 5);

// =============================================================================
// Edge Cases
// =============================================================================

@test_lambda_single_char_param tests @lambda_single_char_param () -> void = {
    let f = a -> a;
    assert_eq(actual: f(42), expected: 42)
}

@lambda_single_char_param () -> int = {
    let f = a -> a;
    f(42)
}

@test_lambda_returns_lambda tests @lambda_returns_lambda () -> void = {
    let curried_add = a -> b -> a + b;
    let add5 = curried_add(5);
    assert_eq(actual: add5(3), expected: 8)
}

@lambda_returns_lambda () -> int = {
    let curried_add = a -> b -> a + b;
    curried_add(5)(3)
}
