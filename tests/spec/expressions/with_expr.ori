// Spec: 09-expressions.md ยง With Expression
// Spec: 14-capabilities.md ยง Capability Provision
// Tests for capability provision with...in expressions

use std.testing { assert, assert_eq }

// =============================================================================
// Basic With Expression
// =============================================================================

// Define a simple capability trait
trait Counter {
    @increment (self) -> int
    @get (self) -> int
}

// A mock implementation
type MockCounter = { value: int }

impl Counter for MockCounter {
    @increment (self) -> int = self.value + 1

    @get (self) -> int = self.value
}

// A function that uses the capability
@use_counter () -> int uses Counter = run(
    let c = MockCounter { value: 0 },
    c.increment(),
)

// SKIP: Capability provision to called functions not yet implemented.
// The `with Counter = mock` binding doesn't propagate to use_counter().
#skip("capability provision to called functions not implemented")
@test_basic_with tests @basic_with () -> void = run(
    let mock = MockCounter { value: 10 },
    let result = with Counter = mock in use_counter(),
    assert_eq(actual: result, expected: 11),
)

@basic_with () -> int = run(
    let mock = MockCounter { value: 10 },
    with Counter = mock in use_counter(),
)

// =============================================================================
// With Expression Returns Value
// =============================================================================

@test_with_returns_value tests @with_returns_value () -> void = run(
    let mock = MockCounter { value: 5 },
    let result = with Counter = mock in mock.get(),
    assert_eq(actual: result, expected: 5),
)

@with_returns_value () -> int = run(
    let mock = MockCounter { value: 5 },
    with Counter = mock in mock.get(),
)

// This test expects mock.increment() to return sequential values (1, then 2),
// but MockCounter.increment returns self.value + 1 which is always 1 for value: 0.
// The test design assumes mutable state which Counter doesn't provide.
#skip("test expects mutable state but Counter.increment is pure")
@test_with_expression_body tests @with_expression_body () -> void = run(
    let mock = MockCounter { value: 0 },
    let result = with Counter = mock in run(
        let a = mock.increment(),
        let b = mock.increment(),
        a + b,
    ),
    assert_eq(actual: result, expected: 3), // 1 + 2
)

@with_expression_body () -> int = run(
    let mock = MockCounter { value: 0 },
    with Counter = mock in run(
        let a = mock.increment(),
        let b = mock.increment(),
        a + b,
    ),
)

// =============================================================================
// Multiple Capabilities
// =============================================================================

trait Logger {
    @log (self, msg: str) -> void
}

type MockLogger = { messages: [str] }

impl Logger for MockLogger {
    @log (self, msg: str) -> void = ()
}

@use_both () -> int uses Counter, Logger = run(
    let c = MockCounter { value: 0 },
    c.increment(),
)

// SKIP: Same issue as test_basic_with - capability provision to called functions not implemented.
#skip("capability provision to called functions not implemented")
@test_multiple_capabilities tests @multiple_capabilities () -> void = run(
    let counter = MockCounter { value: 10 },
    let logger = MockLogger { messages: [] },
    // Note: Multiple capabilities require nested with expressions
    let result = with Counter = counter in with Logger = logger in use_both(),
    assert_eq(actual: result, expected: 11),
)

@multiple_capabilities () -> int = run(
    let counter = MockCounter { value: 10 },
    let logger = MockLogger { messages: [] },
    with Counter = counter in with Logger = logger in use_both(),
)

// =============================================================================
// Nested With Expressions
// =============================================================================

@test_nested_with tests @nested_with () -> void = run(
    let outer_counter = MockCounter { value: 100 },
    let inner_counter = MockCounter { value: 1 },

    let result = with Counter = outer_counter in run(
        let outer_val = outer_counter.get(),
        let inner_val = with Counter = inner_counter in inner_counter.get(),
        outer_val + inner_val,
    ),
    assert_eq(actual: result, expected: 101),
)

@nested_with () -> int = run(
    let outer_counter = MockCounter { value: 100 },
    let inner_counter = MockCounter { value: 1 },

    with Counter = outer_counter in run(
        let outer_val = outer_counter.get(),
        let inner_val = with Counter = inner_counter in inner_counter.get(),
        outer_val + inner_val,
    ),
)

// =============================================================================
// With in Different Contexts
// =============================================================================

@test_with_in_conditional tests @with_in_conditional () -> void = run(
    let mock = MockCounter { value: 42 },
    let result = if true then with Counter = mock in mock.get() else 0,
    assert_eq(actual: result, expected: 42),
)

@with_in_conditional () -> int = run(
    let mock = MockCounter { value: 42 },
    if true then with Counter = mock in mock.get() else 0,
)

@test_with_in_loop tests @with_in_loop () -> void = run(
    let mock = MockCounter { value: 0 },
    let mut sum = 0,
    for i in [1, 2, 3] do run(
        let val = with Counter = mock in mock.get(),
        sum = sum + val + i,
    ),
    assert_eq(actual: sum, expected: 6), // (0+1) + (0+2) + (0+3)
)

@with_in_loop () -> int = run(
    let mock = MockCounter { value: 0 },
    let mut sum = 0,
    for i in [1, 2, 3] do run(
        let val = with Counter = mock in mock.get(),
        sum = sum + val + i,
    ),
    sum,
)

// =============================================================================
// With Expression Scoping
// =============================================================================

@test_with_scope_limited tests @with_scope_limited () -> void = run(
    let mock = MockCounter { value: 10 },
    let result = with Counter = mock in mock.get(),
    // After with...in, capability is no longer provided
    // This tests that the value is correctly returned
    assert_eq(actual: result, expected: 10),
)

@with_scope_limited () -> int = run(
    let mock = MockCounter { value: 10 },
    with Counter = mock in mock.get(),
)

// =============================================================================
// With Expression with Complex Bodies
// =============================================================================

@test_with_let_binding tests @with_let_binding () -> void = run(
    let mock = MockCounter { value: 5 },
    let result = with Counter = mock in run(
        let x = mock.get(),
        let y = x * 2,
        y + 1,
    ),
    assert_eq(actual: result, expected: 11),
)

@with_let_binding () -> int = run(
    let mock = MockCounter { value: 5 },
    with Counter = mock in run(
        let x = mock.get(),
        let y = x * 2,
        y + 1,
    ),
)

@test_with_for_yield tests @with_for_yield () -> void = run(
    let mock = MockCounter { value: 1 },
    let result = with Counter = mock in run(
        for i in [1, 2, 3] yield mock.get() + i,
    ),
    assert_eq(actual: result, expected: [2, 3, 4]),
)

@with_for_yield () -> [int] = run(
    let mock = MockCounter { value: 1 },
    with Counter = mock in run(
        for i in [1, 2, 3] yield mock.get() + i,
    ),
)

// =============================================================================
// With Expression Chaining
// =============================================================================

@test_sequential_with tests @sequential_with () -> void = run(
    let counter1 = MockCounter { value: 10 },
    let counter2 = MockCounter { value: 20 },

    let val1 = with Counter = counter1 in counter1.get(),
    let val2 = with Counter = counter2 in counter2.get(),

    assert_eq(actual: val1 + val2, expected: 30),
)

@sequential_with () -> int = run(
    let counter1 = MockCounter { value: 10 },
    let counter2 = MockCounter { value: 20 },

    let val1 = with Counter = counter1 in counter1.get(),
    let val2 = with Counter = counter2 in counter2.get(),
    val1 + val2,
)

// =============================================================================
// With Expression Type Inference
// =============================================================================

@test_with_type_inferred tests @with_type_inferred () -> void = run(
    let mock = MockCounter { value: 42 },
    // Type should be inferred from the body expression
    let result = with Counter = mock in mock.get(),
    assert_eq(actual: result, expected: 42),
)

@with_type_inferred () -> int = run(
    let mock = MockCounter { value: 42 },
    with Counter = mock in mock.get(),
)

// =============================================================================
// With Expression and Functions
// =============================================================================

@helper_get_value () -> int uses Counter = run(
    let mock = MockCounter { value: 0 },
    mock.get(),
)

@test_with_function_call tests @with_function_call () -> void = run(
    let mock = MockCounter { value: 99 },
    let result = with Counter = mock in helper_get_value(),
    assert_eq(actual: result, expected: 0), // Function uses its own mock
)

@with_function_call () -> int = run(
    let mock = MockCounter { value: 99 },
    with Counter = mock in helper_get_value(),
)

// =============================================================================
// Edge Cases
// =============================================================================

@test_with_void_body tests @with_void_body () -> void = run(
    let mock = MockCounter { value: 0 },
    with Counter = mock in (),
    assert(cond: true), // Just verify it compiles
)

@with_void_body () -> void = run(
    let mock = MockCounter { value: 0 },
    with Counter = mock in (),
)

@test_with_immediate_value tests @with_immediate_value () -> void = run(
    let mock = MockCounter { value: 0 },
    let result = with Counter = mock in 42,
    assert_eq(actual: result, expected: 42),
)

@with_immediate_value () -> int = run(
    let mock = MockCounter { value: 0 },
    with Counter = mock in 42,
)
