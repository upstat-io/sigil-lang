// Spec: 09-expressions.md ยง For Expression, ยง Loop Expression
// Spec: 19-control-flow.md ยง Loop Control, ยง Labeled Loops
// Tests for for/do, for/yield, loop(), break, continue, labels

use std.testing { assert, assert_eq }

// =============================================================================
// For-Do Basic
// =============================================================================

@test_for_do_basic tests @for_do_basic () -> void = run(
    let mut sum = 0,
    for x in [1, 2, 3] do sum = sum + x,
    assert_eq(actual: sum, expected: 6),
)

@for_do_basic () -> int = run(
    let mut sum = 0,
    for x in [1, 2, 3] do sum = sum + x,
    sum,
)

@test_for_do_empty tests @for_do_empty () -> void = run(
    let mut called = false,
    let empty: [int] = [],
    for x in empty do called = true,
    assert(cond: !called),
)

@for_do_empty () -> bool = run(
    let mut called = false,
    let empty: [int] = [],
    for x in empty do called = true,
    called,
)

@test_for_do_returns_void tests @for_do_returns_void () -> void = run(
    for x in [1, 2, 3] do (),
    assert(cond: true), // Just verify it compiles as void
)

@for_do_returns_void () -> void = for x in [1] do ()

// =============================================================================
// For-Do with Guard
// =============================================================================

@test_for_do_with_guard tests @for_do_with_guard () -> void = run(
    let mut sum = 0,
    for x in [1, 2, 3, 4, 5] if x % 2 == 0 do sum = sum + x,
    assert_eq(actual: sum, expected: 6), // 2 + 4
)

@for_do_with_guard () -> int = run(
    let mut sum = 0,
    for x in [1, 2, 3, 4, 5] if x % 2 == 0 do sum = sum + x,
    sum,
)

@test_for_do_guard_all_filtered tests @for_do_guard_all_filtered () -> void = run(
    let mut count = 0,
    for x in [1, 3, 5] if x % 2 == 0 do count = count + 1,
    assert_eq(actual: count, expected: 0),
)

@for_do_guard_all_filtered () -> int = run(
    let mut count = 0,
    for x in [1, 3, 5] if x % 2 == 0 do count = count + 1,
    count,
)

// =============================================================================
// For-Yield Basic
// =============================================================================

@test_for_yield_basic tests @for_yield_basic () -> void = run(
    let result = for x in [1, 2, 3] yield x * 2,
    assert_eq(actual: result, expected: [2, 4, 6]),
)

@for_yield_basic () -> [int] = for x in [1, 2, 3] yield x * 2

@test_for_yield_empty tests @for_yield_empty () -> void = run(
    let empty: [int] = [],
    let result = for x in empty yield x * 2,
    assert_eq(actual: result, expected: []),
)

@for_yield_empty () -> [int] = run(
    let empty: [int] = [],
    for x in empty yield x * 2,
)

@test_for_yield_identity tests @for_yield_identity () -> void = run(
    let result = for x in [1, 2, 3] yield x,
    assert_eq(actual: result, expected: [1, 2, 3]),
)

@for_yield_identity () -> [int] = for x in [1, 2, 3] yield x

// =============================================================================
// For-Yield with Guard
// =============================================================================

@test_for_yield_with_guard tests @for_yield_with_guard () -> void = run(
    let result = for x in [1, 2, 3, 4, 5] if x % 2 == 0 yield x,
    assert_eq(actual: result, expected: [2, 4]),
)

@for_yield_with_guard () -> [int] = for x in [1, 2, 3, 4, 5] if x % 2 == 0 yield x

@test_for_yield_guard_transform tests @for_yield_guard_transform () -> void = run(
    let result = for x in [1, 2, 3, 4, 5] if x > 2 yield x * 10,
    assert_eq(actual: result, expected: [30, 40, 50]),
)

@for_yield_guard_transform () -> [int] = for x in [1, 2, 3, 4, 5] if x > 2 yield x * 10

// =============================================================================
// For with Destructuring
// =============================================================================

@test_for_tuple_destructure tests @for_tuple_destructure () -> void = run(
    let pairs = [(1, "a"), (2, "b"), (3, "c")],
    let mut sum = 0,
    for pair in pairs do run(
        let (n, s) = pair,
        sum = sum + n,
    ),
    assert_eq(actual: sum, expected: 6),
)

@for_tuple_destructure () -> int = run(
    let pairs = [(1, "a"), (2, "b")],
    let mut sum = 0,
    for pair in pairs do run(
        let (n, s) = pair,
        sum = sum + n,
    ),
    sum,
)

type Point = { x: int, y: int }

@test_for_struct_destructure tests @for_struct_destructure () -> void = run(
    let points = [Point { x: 1, y: 2 }, Point { x: 3, y: 4 }],
    let xs = for p in points yield p.x,
    assert_eq(actual: xs, expected: [1, 3]),
)

@for_struct_destructure () -> [int] = run(
    let points = [Point { x: 1, y: 2 }, Point { x: 3, y: 4 }],
    for p in points yield p.x,
)

// =============================================================================
// Nested For
// =============================================================================

@test_nested_for_do tests @nested_for_do () -> void = run(
    let mut sum = 0,
    for x in [1, 2] do
        for y in [10, 20] do
            sum = sum + x * y,
    assert_eq(actual: sum, expected: 90), // 1*10 + 1*20 + 2*10 + 2*20
)

@nested_for_do () -> int = run(
    let mut sum = 0,
    for x in [1, 2] do
        for y in [10, 20] do
            sum = sum + x * y,
    sum,
)

@test_nested_for_yield tests @nested_for_yield () -> void = run(
    let result = for x in [1, 2] yield for y in [10, 20] yield x + y,
    assert_eq(actual: result, expected: [[11, 21], [12, 22]]),
)

@nested_for_yield () -> [[int]] = for x in [1, 2] yield for y in [10, 20] yield x + y

// =============================================================================
// Loop Basic
// =============================================================================

@test_loop_with_break tests @loop_with_break () -> void = run(
    let mut count = 0,
    loop(run(
        count = count + 1,
        if count >= 5 then break,
    )),
    assert_eq(actual: count, expected: 5),
)

@loop_with_break () -> int = run(
    let mut count = 0,
    loop(run(
        count = count + 1,
        if count >= 5 then break,
    )),
    count,
)

@test_loop_break_value tests @loop_break_value () -> void = run(
    let result = loop(run(
        let x = 42,
        break x,
    )),
    assert_eq(actual: result, expected: 42),
)

@loop_break_value () -> int = loop(run(
    let x = 42,
    break x,
))

@test_loop_conditional_break tests @loop_conditional_break () -> void = run(
    let mut n = 0,
    let result = loop(run(
        n = n + 1,
        if n > 10 then break n * 2,
    )),
    assert_eq(actual: result, expected: 22), // 11 * 2
)

@loop_conditional_break () -> int = run(
    let mut n = 0,
    loop(run(
        n = n + 1,
        if n > 10 then break n * 2,
    )),
)

// =============================================================================
// Loop with Continue
// =============================================================================

@test_loop_continue tests @loop_continue () -> void = run(
    let mut count = 0,
    let mut sum = 0,
    loop(run(
        count = count + 1,
        if count > 10 then break,
        if count % 2 == 0 then continue, // Skip even numbers
        sum = sum + count,
    )),
    assert_eq(actual: sum, expected: 25), // 1 + 3 + 5 + 7 + 9
)

@loop_continue () -> int = run(
    let mut count = 0,
    let mut sum = 0,
    loop(run(
        count = count + 1,
        if count > 10 then break,
        if count % 2 == 0 then continue,
        sum = sum + count,
    )),
    sum,
)

// =============================================================================
// For with Break
// =============================================================================

@test_for_do_break tests @for_do_break () -> void = run(
    let mut sum = 0,
    for x in [1, 2, 3, 4, 5] do run(
        if x == 4 then break,
        sum = sum + x,
    ),
    assert_eq(actual: sum, expected: 6), // 1 + 2 + 3
)

@for_do_break () -> int = run(
    let mut sum = 0,
    for x in [1, 2, 3, 4, 5] do run(
        if x == 4 then break,
        sum = sum + x,
    ),
    sum,
)

@test_for_yield_break tests @for_yield_break () -> void = run(
    let result = for x in [1, 2, 3, 4, 5] yield run(
        if x == 4 then break,
        x * 2,
    ),
    assert_eq(actual: result, expected: [2, 4, 6]),
)

@for_yield_break () -> [int] = for x in [1, 2, 3, 4, 5] yield run(
    if x == 4 then break,
    x * 2,
)

@test_for_yield_break_value tests @for_yield_break_value () -> void = run(
    let result = for x in [1, 2, 3, 4, 5] yield run(
        if x == 4 then break 99,
        x,
    ),
    // Break adds final element
    assert_eq(actual: result, expected: [1, 2, 3, 99]),
)

@for_yield_break_value () -> [int] = for x in [1, 2, 3, 4, 5] yield run(
    if x == 4 then break 99,
    x,
)

// =============================================================================
// For with Continue
// =============================================================================

@test_for_do_continue tests @for_do_continue () -> void = run(
    let mut sum = 0,
    for x in [1, 2, 3, 4, 5] do run(
        if x == 3 then continue,
        sum = sum + x,
    ),
    assert_eq(actual: sum, expected: 12), // 1 + 2 + 4 + 5
)

@for_do_continue () -> int = run(
    let mut sum = 0,
    for x in [1, 2, 3, 4, 5] do run(
        if x == 3 then continue,
        sum = sum + x,
    ),
    sum,
)

@test_for_yield_continue tests @for_yield_continue () -> void = run(
    let result = for x in [1, 2, 3, 4, 5] yield run(
        if x == 3 then continue,
        x,
    ),
    assert_eq(actual: result, expected: [1, 2, 4, 5]),
)

@for_yield_continue () -> [int] = for x in [1, 2, 3, 4, 5] yield run(
    if x == 3 then continue,
    x,
)

@test_for_yield_continue_value tests @for_yield_continue_value () -> void = run(
    let result = for x in [1, 2, 3, 4, 5] yield run(
        if x == 3 then continue 0,
        x,
    ),
    assert_eq(actual: result, expected: [1, 2, 0, 4, 5]),
)

@for_yield_continue_value () -> [int] = for x in [1, 2, 3, 4, 5] yield run(
    if x == 3 then continue 0,
    x,
)

// =============================================================================
// Labeled Loops (NOT YET IMPLEMENTED)
// =============================================================================

// Note: Labeled loops (loop:name, for:name, break:name, continue:name) are
// specified but not yet implemented in the compiler. These tests are
// commented out until the feature is available.

// When implemented, tests should cover:
// - loop:name with break:name
// - loop:name with break:name value
// - for:name with continue:name
// - Nested labeled loops

// =============================================================================
// Loop Type Inference
// =============================================================================

@test_loop_void tests @loop_void () -> void = run(
    let mut count = 0,
    loop(run(
        count = count + 1,
        if count >= 3 then break,
    )),
    // No value from break, loop is void
    assert_eq(actual: count, expected: 3),
)

@loop_void () -> void = run(
    let mut count = 0,
    loop(run(
        count = count + 1,
        if count >= 3 then break,
    )),
)

@test_loop_int tests @loop_int () -> void = run(
    let result: int = loop(break 42),
    assert_eq(actual: result, expected: 42),
)

@loop_int () -> int = loop(break 42)

// =============================================================================
// Complex Patterns
// =============================================================================
//
// STATUS: Lexer [OK], Parser [OK], Evaluator [NEEDS LABELED BREAKS]
// break x inside a for loop only breaks from the for, not the enclosing loop.
// This test requires labeled breaks (break:name) which are not yet implemented.

#skip("requires labeled breaks (loop:name, break:name) - see line 361")
@test_find_first tests @find_first () -> void = run(
    let items = [1, 3, 5, 8, 10],
    let first_even = loop(run(
        for x in items do run(
            if x % 2 == 0 then break x,
        ),
        break 0, // Not found
    )),
    assert_eq(actual: first_even, expected: 8),
)

@find_first () -> int = run(
    let items = [1, 3, 5, 8, 10],
    loop(run(
        for x in items do run(
            if x % 2 == 0 then break x,
        ),
        break 0,
    )),
)

@test_flatten_with_break tests @flatten_with_break () -> void = run(
    let matrix = [[1, 2], [3, 4], [5, 6]],
    let mut count = 0,
    for row in matrix do run(
        for x in row do run(
            if x == 4 then break,
            count = count + x,
        ),
    ),
    // Breaks inner loop at 4, continues to next row
    // 1 + 2 + 3 + 5 + 6 = 17
    assert_eq(actual: count, expected: 17),
)

@flatten_with_break () -> int = run(
    let matrix = [[1, 2], [3, 4], [5, 6]],
    let mut count = 0,
    for row in matrix do run(
        for x in row do run(
            if x == 4 then break,
            count = count + x,
        ),
    ),
    count,
)

@test_accumulate_until tests @accumulate_until () -> void = run(
    let mut sum = 0,
    let limit = 10,
    let mut i = 0,
    loop(run(
        sum = sum + i,
        i = i + 1,
        if sum >= limit then break,
    )),
    // 0 + 1 + 2 + 3 + 4 = 10 >= 10, break
    assert(cond: sum >= limit),
)

@accumulate_until () -> int = run(
    let mut sum = 0,
    let mut i = 0,
    loop(run(
        sum = sum + i,
        i = i + 1,
        if sum >= 10 then break,
    )),
    sum,
)
