// Spec: 09-expressions.md ยง Index Access

use std.testing { assert_eq, assert }
// Tests for list indexing, map indexing, and # length placeholder

// =============================================================================
// List Indexing - Basic
// =============================================================================

@test_list_index_first tests @list_index_first () -> void = {
    let list = [10, 20, 30];
    assert_eq(actual: list[0], expected: 10)
}

@list_index_first () -> int = [10, 20, 30][0];

@test_list_index_middle tests @list_index_middle () -> void = {
    let list = [10, 20, 30];
    assert_eq(actual: list[1], expected: 20)
}

@list_index_middle () -> int = [10, 20, 30][1];

@test_list_index_last tests @list_index_last () -> void = {
    let list = [10, 20, 30];
    assert_eq(actual: list[2], expected: 30)
}

@list_index_last () -> int = [10, 20, 30][2];

@test_list_single_element tests @list_single_element () -> void = {
    let list = [42];
    assert_eq(actual: list[0], expected: 42)
}

@list_single_element () -> int = [42][0];

// =============================================================================
// List Indexing - With Variables
// =============================================================================

@test_list_index_var tests @list_index_var () -> void = {
    let list = [1, 2, 3, 4, 5];
    let i = 2;
    assert_eq(actual: list[i], expected: 3)
}

@list_index_var () -> int = {
    let list = [1, 2, 3, 4, 5];
    let i = 2;
    list[i]
}

@test_list_index_expression tests @list_index_expression () -> void = {
    let list = [10, 20, 30, 40];
    assert_eq(actual: list[1 + 1], expected: 30)
}

@list_index_expression () -> int = {
    let list = [10, 20, 30, 40];
    list[1 + 1]
}

// =============================================================================
// List Indexing - # Length Placeholder
// =============================================================================

@test_hash_last tests @hash_last () -> void = {
    let list = [10, 20, 30];
    assert_eq(actual: list[# - 1], expected: 30)
}

@hash_last () -> int = {
    let list = [10, 20, 30];
    list[# - 1]
}

@test_hash_second_last tests @hash_second_last () -> void = {
    let list = [10, 20, 30, 40];
    assert_eq(actual: list[# - 2], expected: 30)
}

@hash_second_last () -> int = {
    let list = [10, 20, 30, 40];
    list[# - 2]
}

@test_hash_first tests @hash_first () -> void = {
    let list = [10, 20, 30];
    assert_eq(actual: list[# - #], expected: 10)
}

@hash_first () -> int = {
    let list = [10, 20, 30];
    list[# - #]
}

@test_hash_middle tests @hash_middle () -> void = {
    let list = [10, 20, 30, 40, 50];
    assert_eq(actual: list[# / 2], expected: 30)
}

@hash_middle () -> int = {
    let list = [10, 20, 30, 40, 50];
    list[# / 2]
}

@test_hash_arithmetic tests @hash_arithmetic () -> void = {
    let list = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];
    assert_eq(actual: list[# - 5], expected: 5)
}

@hash_arithmetic () -> int = {
    let list = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];
    list[# - 5]
}

// =============================================================================
// Map Indexing - Basic
// =============================================================================
//
// STATUS: Lexer [OK], Parser [OK], Evaluator [BROKEN] - map returns value, not Option
// Per spec, map["key"] should return Option<V>, but evaluator returns V and panics on missing.
// Also needs ?? operator (see coalesce.ori).

@test_map_index_found tests @map_index_found () -> void = {
    let map = {"a": 1, "b": 2, "c": 3};
    assert_eq(actual: map["a"] ?? 0, expected: 1);
    assert_eq(actual: map["b"] ?? 0, expected: 2);
    assert_eq(actual: map["c"] ?? 0, expected: 3)
}

@map_index_found () -> int = { {"a": 1, "b": 2, "c": 3}["a"] ?? 0 }

@test_map_index_not_found tests @map_index_not_found () -> void = {
    let map = {"a": 1, "b": 2};
    assert(cond: is_none(opt: map["missing"]))
}

@map_index_not_found () -> Option<int> = { {"a": 1}["missing"] }

@test_map_empty tests @map_empty () -> void = {
    let map: {str: int} = {};
    assert(cond: is_none(opt: map["any"]))
}

@map_empty () -> Option<int> = {
    let map: {str: int} = {};
    map["any"]
}

// =============================================================================
// Map Indexing - With Variables
// =============================================================================

@test_map_index_var tests @map_index_var () -> void = {
    let map = {"key": 42};
    let k = "key";
    assert_eq(actual: map[k] ?? 0, expected: 42)
}

@map_index_var () -> int = {
    let map = {"key": 42};
    let k = "key";
    map[k] ?? 0
}

@test_map_index_concatenated tests @map_index_concatenated () -> void = {
    let map = {"prefix_suffix": 99};
    let result = map["prefix" + "_" + "suffix"];
    assert_eq(actual: result ?? 0, expected: 99)
}

@map_index_concatenated () -> int = {
    let map = {"prefix_suffix": 99};
    map["prefix" + "_" + "suffix"] ?? 0
}

// =============================================================================
// Map Indexing - With Coalesce
// =============================================================================

@test_map_coalesce_found tests @map_coalesce_found () -> void = {
    let map = {"key": 42};
    let value = map["key"] ?? 0;
    assert_eq(actual: value, expected: 42)
}

@map_coalesce_found () -> int = { {"key": 42}["key"] ?? 0 }

@test_map_coalesce_missing tests @map_coalesce_missing () -> void = {
    let map = {"key": 42};
    let value = map["missing"] ?? 99;
    assert_eq(actual: value, expected: 99)
}

@map_coalesce_missing () -> int = { {"key": 42}["missing"] ?? 99 }

// =============================================================================
// String Indexing
// =============================================================================
//
// STATUS: Lexer [OK], Parser [OK], Evaluator [BROKEN] - returns char, should return str
// Per spec, str[i] should return single-codepoint str, but evaluator returns char.

@test_str_index_first tests @str_index_first () -> void = {
    let s = "hello";
    assert_eq(actual: s[0], expected: "h")
}

@str_index_first () -> str = "hello"[0];

@test_str_index_last tests @str_index_last () -> void = {
    let s = "hello";
    assert_eq(actual: s[# - 1], expected: "o")
}

@str_index_last () -> str = {
    let s = "hello";
    s[# - 1]
}

@test_str_index_middle tests @str_index_middle () -> void = {
    let s = "hello";
    assert_eq(actual: s[2], expected: "l")
}

@str_index_middle () -> str = "hello"[2];

// =============================================================================
// Nested Indexing
// =============================================================================

@test_nested_list tests @nested_list () -> void = {
    let matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]];
    assert_eq(actual: matrix[0][0], expected: 1);
    assert_eq(actual: matrix[1][1], expected: 5);
    assert_eq(actual: matrix[2][2], expected: 9)
}

@nested_list () -> int = [[1, 2, 3], [4, 5, 6], [7, 8, 9]][1][1];

@test_list_of_maps tests @list_of_maps () -> void = {
    let records = [{"name": "Alice"}, {"name": "Bob"}];
    assert_eq(actual: records[0]["name"] ?? "", expected: "Alice");
    assert_eq(actual: records[1]["name"] ?? "", expected: "Bob")
}

@list_of_maps () -> str = {
    let records = [{"name": "Alice"}, {"name": "Bob"}];
    records[0]["name"] ?? ""
}

// =============================================================================
// Index with Struct Fields
// =============================================================================

type Container = { items: [int] }

@test_field_then_index tests @field_then_index () -> void = {
    let c = Container { items: [10, 20, 30] };
    assert_eq(actual: c.items[0], expected: 10)
}

@field_then_index () -> int = {
    let c = Container { items: [10, 20, 30] };
    c.items[1]
}

// =============================================================================
// Index Result Used in Expressions
// =============================================================================

@test_index_in_arithmetic tests @index_in_arithmetic () -> void = {
    let list = [10, 20, 30];
    let sum = list[0] + list[1] + list[2];
    assert_eq(actual: sum, expected: 60)
}

@index_in_arithmetic () -> int = {
    let list = [10, 20, 30];
    list[0] + list[1] + list[2]
}

@test_index_in_comparison tests @index_in_comparison () -> void = {
    let list = [5, 10, 15];
    assert(cond: list[0] < list[1]);
    assert(cond: list[1] < list[2])
}

@index_in_comparison () -> bool = {
    let list = [5, 10, 15];
    list[0] < list[1]
}

@test_index_in_condition tests @index_in_condition () -> void = {
    let list = [1, 2, 3];
    let result = if list[0] > 0 then "positive" else "non-positive";
    assert_eq(actual: result, expected: "positive")
}

@index_in_condition () -> str = {
    let list = [1, 2, 3];
    if list[0] > 0 then "positive" else "non-positive"
}

// =============================================================================
// Index with Function Results
// =============================================================================

@get_list () -> [int] = [100, 200, 300];

@test_func_result_index tests @func_result_index () -> void = {
    let value = get_list()[1];
    assert_eq(actual: value, expected: 200)
}

@func_result_index () -> int = get_list()[1];

@get_index () -> int = 2;

@test_func_index tests @func_index () -> void = {
    let list = [10, 20, 30, 40];
    let value = list[get_index()];
    assert_eq(actual: value, expected: 30)
}

@func_index () -> int = {
    let list = [10, 20, 30, 40];
    list[get_index()]
}

// =============================================================================
// Chained Indexing
// =============================================================================

@test_chain_list_index tests @chain_list_index () -> void = {
    let list = [[1, 2], [3, 4], [5, 6]];
    let value = list[1][0];
    assert_eq(actual: value, expected: 3)
}

@chain_list_index () -> int = [[1, 2], [3, 4], [5, 6]][1][0];

@test_triple_nested tests @triple_nested () -> void = {
    let data = [[[1, 2], [3, 4]], [[5, 6], [7, 8]]];
    assert_eq(actual: data[0][0][0], expected: 1);
    assert_eq(actual: data[1][1][1], expected: 8)
}

@triple_nested () -> int = [[[1, 2], [3, 4]], [[5, 6], [7, 8]]][1][1][1];

// =============================================================================
// Index Assignment
// =============================================================================
// SKIP: Index assignment (list[i] = x) not currently supported. Pending design proposal
// for copy-on-write index assignment (see errata on index-trait-proposal.md).

#skip("index assignment not supported - pending design proposal")
@test_list_assign tests @list_assign () -> void = {
    let list = [1, 2, 3];
    list[1] = 99;
    assert_eq(actual: list[1], expected: 99)
}

@list_assign () -> int = {
    let list = [1, 2, 3];
    list[1] = 99;
    list[1]
}

// =============================================================================
// Edge Cases
// =============================================================================

@test_single_element_hash tests @single_element_hash () -> void = {
    let list = [42];
    assert_eq(actual: list[# - 1], expected: 42)
}

@single_element_hash () -> int = {
    let list = [42];
    list[# - 1]
}

@test_computed_index tests @computed_index () -> void = {
    let list = [0, 1, 2, 3, 4];
    let offset = 2;
    let multiplier = 2;
    let index = offset * multiplier;
    assert_eq(actual: list[index], expected: 4)
}

@computed_index () -> int = {
    let list = [0, 1, 2, 3, 4];
    list[2 * 2]
}

@test_map_int_key tests @map_int_key () -> void = {
    let map = {1: "one", 2: "two", 3: "three"};
    assert_eq(actual: map[1] ?? "", expected: "one");
    assert_eq(actual: map[2] ?? "", expected: "two");
    assert(cond: is_none(opt: map[99]))
}

@map_int_key () -> str = { {1: "one", 2: "two"}[1] ?? "" }
