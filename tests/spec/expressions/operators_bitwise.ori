// Spec: 09-expressions.md ยง Binary Expressions, ยง Bitwise Operators
// Tests for bitwise operators: &, |, ^, ~, <<, >>

use std.testing { assert, assert_eq, assert_panics }

// =============================================================================
// Bitwise AND (&)
// =============================================================================

@test_bitand_basic tests @bitand_basic () -> void = run(
    // 0b1100 & 0b1010 = 0b1000 = 8
    assert_eq(actual: bitand_basic(), expected: 8),
)

@bitand_basic () -> int = 12 & 10

@test_bitand_zero tests @bitand_zero () -> void = run(
    assert_eq(actual: bitand_zero(), expected: 0),
)

@bitand_zero () -> int = 255 & 0

@test_bitand_identity tests @bitand_identity () -> void = run(
    // x & -1 = x (all bits set)
    assert_eq(actual: bitand_identity(), expected: 42),
)

@bitand_identity () -> int = 42 & -1

@test_bitand_self tests @bitand_self () -> void = run(
    assert_eq(actual: bitand_self(), expected: 42),
)

@bitand_self () -> int = run(
    let x = 42,
    x & x,
)

@test_bitand_mask tests @bitand_mask () -> void = run(
    // Extract lower 4 bits
    assert_eq(actual: bitand_mask(), expected: 5),
)

@bitand_mask () -> int = 0xFF5 & 0xF

// =============================================================================
// Bitwise OR (|)
// =============================================================================

@test_bitor_basic tests @bitor_basic () -> void = run(
    // 0b1100 | 0b1010 = 0b1110 = 14
    assert_eq(actual: bitor_basic(), expected: 14),
)

@bitor_basic () -> int = 12 | 10

@test_bitor_zero tests @bitor_zero () -> void = run(
    assert_eq(actual: bitor_zero(), expected: 255),
)

@bitor_zero () -> int = 255 | 0

@test_bitor_self tests @bitor_self () -> void = run(
    assert_eq(actual: bitor_self(), expected: 42),
)

@bitor_self () -> int = run(
    let x = 42,
    x | x,
)

@test_bitor_combine tests @bitor_combine () -> void = run(
    // Set bits from both operands
    assert_eq(actual: bitor_combine(), expected: 0xFF),
)

@bitor_combine () -> int = 0xF0 | 0x0F

// =============================================================================
// Bitwise XOR (^)
// =============================================================================

@test_bitxor_basic tests @bitxor_basic () -> void = run(
    // 0b1100 ^ 0b1010 = 0b0110 = 6
    assert_eq(actual: bitxor_basic(), expected: 6),
)

@bitxor_basic () -> int = 12 ^ 10

@test_bitxor_zero tests @bitxor_zero () -> void = run(
    assert_eq(actual: bitxor_zero(), expected: 255),
)

@bitxor_zero () -> int = 255 ^ 0

@test_bitxor_self tests @bitxor_self () -> void = run(
    // x ^ x = 0
    assert_eq(actual: bitxor_self(), expected: 0),
)

@bitxor_self () -> int = run(
    let x = 42,
    x ^ x,
)

@test_bitxor_inverse tests @bitxor_inverse () -> void = run(
    // x ^ -1 = ~x
    let x = 42,
    assert_eq(actual: x ^ -1, expected: ~x),
)

@bitxor_inverse () -> int = 42 ^ -1

@test_bitxor_toggle tests @bitxor_toggle () -> void = run(
    // Toggle specific bit
    let value = 0b1000,
    let toggled = value ^ 0b1000,
    assert_eq(actual: toggled, expected: 0),
    let toggled_back = toggled ^ 0b1000,
    assert_eq(actual: toggled_back, expected: 0b1000),
)

@bitxor_toggle () -> int = 0b1000 ^ 0b1000

// =============================================================================
// Bitwise NOT (~)
// =============================================================================

@test_bitnot_zero tests @bitnot_zero () -> void = run(
    // ~0 = -1 (all bits set)
    assert_eq(actual: bitnot_zero(), expected: -1),
)

@bitnot_zero () -> int = ~0

@test_bitnot_minus_one tests @bitnot_minus_one () -> void = run(
    // ~(-1) = 0
    assert_eq(actual: bitnot_minus_one(), expected: 0),
)

@bitnot_minus_one () -> int = ~(-1)

@test_bitnot_positive tests @bitnot_positive () -> void = run(
    // ~x = -(x + 1)
    assert_eq(actual: bitnot_positive(), expected: -6),
)

@bitnot_positive () -> int = ~5

@test_bitnot_double tests @bitnot_double () -> void = run(
    // ~~x = x
    assert_eq(actual: bitnot_double(), expected: 42),
)

@bitnot_double () -> int = ~~42

// =============================================================================
// Left Shift (<<)
// =============================================================================

@test_shl_basic tests @shl_basic () -> void = run(
    // 1 << 3 = 8
    assert_eq(actual: shl_basic(), expected: 8),
)

@shl_basic () -> int = 1 << 3

@test_shl_zero tests @shl_zero () -> void = run(
    assert_eq(actual: shl_zero(), expected: 42),
)

@shl_zero () -> int = 42 << 0

@test_shl_multiply tests @shl_multiply () -> void = run(
    // x << n = x * 2^n
    assert_eq(actual: shl_multiply(), expected: 80),
)

@shl_multiply () -> int = 5 << 4

@test_shl_negative_value tests @shl_negative_value () -> void = run(
    // Left shift of negative value
    assert_eq(actual: shl_negative_value(), expected: -16),
)

@shl_negative_value () -> int = -2 << 3

// STATUS: Lexer [OK], Parser [OK], Evaluator [BROKEN] - shift overflow does not panic
// Per spec, 1 << 63 should panic due to overflow but evaluator succeeds silently.
#skip("catch pattern not yet implemented (roadmap Section 10.7)")
@test_shl_overflow_panic tests @shl_overflow_panic () -> void = run(
    // Shift that causes overflow should panic
    assert_panics(f: () -> 1 << 63),
)

@shl_overflow_panic () -> int = 1 << 63

#skip("catch pattern not yet implemented (roadmap Section 10.7)")
@test_shl_bit_width_panic tests @shl_bit_width_panic () -> void = run(
    // Shift count >= bit width should panic
    assert_panics(f: () -> 1 << 64),
)

@shl_bit_width_panic () -> int = 1 << 64

#skip("catch pattern not yet implemented (roadmap Section 10.7)")
@test_shl_negative_count_panic tests @shl_negative_count_panic () -> void = run(
    // Negative shift count should panic
    assert_panics(f: () -> 1 << -1),
)

@shl_negative_count_panic () -> int = 1 << -1

// =============================================================================
// Right Shift (>>)
// =============================================================================

@test_shr_basic tests @shr_basic () -> void = run(
    // 8 >> 3 = 1
    assert_eq(actual: shr_basic(), expected: 1),
)

@shr_basic () -> int = 8 >> 3

@test_shr_zero tests @shr_zero () -> void = run(
    assert_eq(actual: shr_zero(), expected: 42),
)

@shr_zero () -> int = 42 >> 0

@test_shr_divide tests @shr_divide () -> void = run(
    // x >> n = x / 2^n (for positive x)
    assert_eq(actual: shr_divide(), expected: 5),
)

@shr_divide () -> int = 80 >> 4

@test_shr_negative_value tests @shr_negative_value () -> void = run(
    // Arithmetic right shift preserves sign
    assert_eq(actual: shr_negative_value(), expected: -2),
)

@shr_negative_value () -> int = -16 >> 3

#skip("catch pattern not yet implemented (roadmap Section 10.7)")
@test_shr_bit_width_panic tests @shr_bit_width_panic () -> void = run(
    // Shift count >= bit width should panic
    assert_panics(f: () -> 1 >> 64),
)

@shr_bit_width_panic () -> int = 1 >> 64

#skip("catch pattern not yet implemented (roadmap Section 10.7)")
@test_shr_negative_count_panic tests @shr_negative_count_panic () -> void = run(
    // Negative shift count should panic
    assert_panics(f: () -> 1 >> -1),
)

@shr_negative_count_panic () -> int = 1 >> -1

// =============================================================================
// Byte Operations (requires `as` conversion - NOT YET IMPLEMENTED)
// =============================================================================

// Note: The `as` type conversion operator is not yet implemented in the parser.
// Byte bitwise operation tests are commented out until `as` is available.

// When implemented, tests should cover:
// - byte & byte
// - byte | byte
// - byte ^ byte
// - ~byte
// - byte << int
// - byte >> int

// =============================================================================
// Precedence
// =============================================================================

@test_and_before_or tests @and_before_or () -> void = run(
    // & has higher precedence than |
    // 0b1100 | 0b1010 & 0b0011 = 0b1100 | (0b1010 & 0b0011) = 0b1100 | 0b0010 = 0b1110 = 14
    assert_eq(actual: and_before_or(), expected: 14),
)

@and_before_or () -> int = 0b1100 | 0b1010 & 0b0011

@test_xor_between_and_or tests @xor_between_and_or () -> void = run(
    // Precedence: & > ^ > |
    // 0b1111 | 0b1100 ^ 0b1010 & 0b0011
    // = 0b1111 | (0b1100 ^ (0b1010 & 0b0011))
    // = 0b1111 | (0b1100 ^ 0b0010)
    // = 0b1111 | 0b1110
    // = 0b1111 = 15
    assert_eq(actual: xor_between_and_or(), expected: 15),
)

@xor_between_and_or () -> int = 0b1111 | 0b1100 ^ 0b1010 & 0b0011

@test_shift_before_bitwise tests @shift_before_bitwise () -> void = run(
    // << and >> have higher precedence than &
    // 1 << 2 & 0xF = (1 << 2) & 0xF = 4 & 0xF = 4
    assert_eq(actual: shift_before_bitwise(), expected: 4),
)

@shift_before_bitwise () -> int = 1 << 2 & 0xF

// =============================================================================
// Chained Operations
// =============================================================================

@test_chain_and tests @chain_and () -> void = run(
    assert_eq(actual: chain_and(), expected: 0),
)

@chain_and () -> int = 0xFF & 0xF0 & 0x0F

@test_chain_or tests @chain_or () -> void = run(
    assert_eq(actual: chain_or(), expected: 0xFF),
)

@chain_or () -> int = 0xF0 | 0x0F | 0x00

@test_chain_xor tests @chain_xor () -> void = run(
    // 0b1100 ^ 0b1010 ^ 0b0110 = 0b0110 ^ 0b0110 = 0
    assert_eq(actual: chain_xor(), expected: 0),
)

@chain_xor () -> int = 0b1100 ^ 0b1010 ^ 0b0110

// =============================================================================
// Common Patterns
// =============================================================================

@test_check_bit tests @check_bit () -> void = run(
    let value = 0b1010,
    // Check if bit 1 is set
    let bit1_set = (value & 0b0010) != 0,
    assert(cond: bit1_set),
    // Check if bit 0 is set
    let bit0_set = (value & 0b0001) != 0,
    assert(cond: !bit0_set),
)

@check_bit () -> bool = run(
    let value = 0b1010,
    (value & 0b0010) != 0,
)

@test_set_bit tests @set_bit () -> void = run(
    let value = 0b1000,
    let with_bit1 = value | 0b0010,
    assert_eq(actual: with_bit1, expected: 0b1010),
)

@set_bit () -> int = 0b1000 | 0b0010

@test_clear_bit tests @clear_bit () -> void = run(
    let value = 0b1010,
    let without_bit1 = value & ~0b0010,
    assert_eq(actual: without_bit1, expected: 0b1000),
)

@clear_bit () -> int = 0b1010 & ~0b0010

@test_toggle_bit tests @toggle_bit () -> void = run(
    let value = 0b1010,
    let toggled = value ^ 0b0010,
    assert_eq(actual: toggled, expected: 0b1000),
)

@toggle_bit () -> int = 0b1010 ^ 0b0010

@test_is_power_of_two tests @is_power_of_two () -> void = run(
    // n is power of 2 if n > 0 && (n & (n - 1)) == 0
    let n = 8,
    assert(cond: n > 0 && (n & (n - 1)) == 0),
    let m = 7,
    assert(cond: !(m > 0 && (m & (m - 1)) == 0)),
)

@is_power_of_two () -> bool = run(
    let n = 8,
    n > 0 && (n & (n - 1)) == 0,
)

@test_swap_without_temp tests @swap_without_temp () -> void = run(
    let mut a = 5,
    let mut b = 10,
    a = a ^ b,
    b = a ^ b,
    a = a ^ b,
    assert_eq(actual: a, expected: 10),
    assert_eq(actual: b, expected: 5),
)

@swap_without_temp () -> int = run(
    let mut a = 5,
    let mut b = 10,
    a = a ^ b,
    b = a ^ b,
    a = a ^ b,
    a,
)
