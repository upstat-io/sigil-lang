// Spec: 09-expressions.md ยง Binary Expressions, ยง Bitwise Operators
// Tests for bitwise operators: &, |, ^, ~, <<, >>

use std.testing { assert, assert_eq, assert_panics }

// =============================================================================
// Bitwise AND (&)
// =============================================================================

@test_bitand_basic tests @bitand_basic () -> void = {
    // 0b1100 & 0b1010 = 0b1000 = 8
    assert_eq(actual: bitand_basic(), expected: 8)
}

@bitand_basic () -> int = 12 & 10

@test_bitand_zero tests @bitand_zero () -> void = {
    assert_eq(actual: bitand_zero(), expected: 0)
}

@bitand_zero () -> int = 255 & 0

@test_bitand_identity tests @bitand_identity () -> void = {
    // x & -1 = x (all bits set)
    assert_eq(actual: bitand_identity(), expected: 42)
}

@bitand_identity () -> int = 42 & -1

@test_bitand_self tests @bitand_self () -> void = {
    assert_eq(actual: bitand_self(), expected: 42)
}

@bitand_self () -> int = {
    let x = 42;
    x & x
}

@test_bitand_mask tests @bitand_mask () -> void = {
    // Extract lower 4 bits
    assert_eq(actual: bitand_mask(), expected: 5)
}

@bitand_mask () -> int = 0xFF5 & 0xF

// =============================================================================
// Bitwise OR (|)
// =============================================================================

@test_bitor_basic tests @bitor_basic () -> void = {
    // 0b1100 | 0b1010 = 0b1110 = 14
    assert_eq(actual: bitor_basic(), expected: 14)
}

@bitor_basic () -> int = 12 | 10

@test_bitor_zero tests @bitor_zero () -> void = {
    assert_eq(actual: bitor_zero(), expected: 255)
}

@bitor_zero () -> int = 255 | 0

@test_bitor_self tests @bitor_self () -> void = {
    assert_eq(actual: bitor_self(), expected: 42)
}

@bitor_self () -> int = {
    let x = 42;
    x | x
}

@test_bitor_combine tests @bitor_combine () -> void = {
    // Set bits from both operands
    assert_eq(actual: bitor_combine(), expected: 0xFF)
}

@bitor_combine () -> int = 0xF0 | 0x0F

// =============================================================================
// Bitwise XOR (^)
// =============================================================================

@test_bitxor_basic tests @bitxor_basic () -> void = {
    // 0b1100 ^ 0b1010 = 0b0110 = 6
    assert_eq(actual: bitxor_basic(), expected: 6)
}

@bitxor_basic () -> int = 12 ^ 10

@test_bitxor_zero tests @bitxor_zero () -> void = {
    assert_eq(actual: bitxor_zero(), expected: 255)
}

@bitxor_zero () -> int = 255 ^ 0

@test_bitxor_self tests @bitxor_self () -> void = {
    // x ^ x = 0
    assert_eq(actual: bitxor_self(), expected: 0)
}

@bitxor_self () -> int = {
    let x = 42;
    x ^ x
}

@test_bitxor_inverse tests @bitxor_inverse () -> void = {
    // x ^ -1 = ~x
    let x = 42;
    assert_eq(actual: x ^ -1, expected: ~x)
}

@bitxor_inverse () -> int = 42 ^ -1

@test_bitxor_toggle tests @bitxor_toggle () -> void = {
    // Toggle specific bit
    let value = 0b1000;
    let toggled = value ^ 0b1000;
    assert_eq(actual: toggled, expected: 0);
    let toggled_back = toggled ^ 0b1000;
    assert_eq(actual: toggled_back, expected: 0b1000)
}

@bitxor_toggle () -> int = 0b1000 ^ 0b1000

// =============================================================================
// Bitwise NOT (~)
// =============================================================================

@test_bitnot_zero tests @bitnot_zero () -> void = {
    // ~0 = -1 (all bits set)
    assert_eq(actual: bitnot_zero(), expected: -1)
}

@bitnot_zero () -> int = ~0

@test_bitnot_minus_one tests @bitnot_minus_one () -> void = {
    // ~(-1) = 0
    assert_eq(actual: bitnot_minus_one(), expected: 0)
}

@bitnot_minus_one () -> int = ~(-1)

@test_bitnot_positive tests @bitnot_positive () -> void = {
    // ~x = -(x + 1)
    assert_eq(actual: bitnot_positive(), expected: -6)
}

@bitnot_positive () -> int = ~5

@test_bitnot_double tests @bitnot_double () -> void = {
    // ~~x = x
    assert_eq(actual: bitnot_double(), expected: 42)
}

@bitnot_double () -> int = ~~42

// =============================================================================
// Left Shift (<<)
// =============================================================================

@test_shl_basic tests @shl_basic () -> void = {
    // 1 << 3 = 8
    assert_eq(actual: shl_basic(), expected: 8)
}

@shl_basic () -> int = 1 << 3

@test_shl_zero tests @shl_zero () -> void = {
    assert_eq(actual: shl_zero(), expected: 42)
}

@shl_zero () -> int = 42 << 0

@test_shl_multiply tests @shl_multiply () -> void = {
    // x << n = x * 2^n
    assert_eq(actual: shl_multiply(), expected: 80)
}

@shl_multiply () -> int = 5 << 4

@test_shl_negative_value tests @shl_negative_value () -> void = {
    // Left shift of negative value
    assert_eq(actual: shl_negative_value(), expected: -16)
}

@shl_negative_value () -> int = -2 << 3

// Per spec, shift overflow panics (e.g. 1 << 63 overflows into sign bit).
@test_shl_overflow_panic tests @shl_overflow_panic () -> void = {
    // Shift that causes overflow should panic
    assert_panics(f: () -> 1 << 63)
}

@shl_overflow_panic () -> int = 1 << 63

@test_shl_bit_width_panic tests @shl_bit_width_panic () -> void = {
    // Shift count >= bit width should panic
    assert_panics(f: () -> 1 << 64)
}

@shl_bit_width_panic () -> int = 1 << 64

@test_shl_negative_count_panic tests @shl_negative_count_panic () -> void = {
    // Negative shift count should panic
    assert_panics(f: () -> 1 << -1)
}

@shl_negative_count_panic () -> int = 1 << -1

// =============================================================================
// Right Shift (>>)
// =============================================================================

@test_shr_basic tests @shr_basic () -> void = {
    // 8 >> 3 = 1
    assert_eq(actual: shr_basic(), expected: 1)
}

@shr_basic () -> int = 8 >> 3

@test_shr_zero tests @shr_zero () -> void = {
    assert_eq(actual: shr_zero(), expected: 42)
}

@shr_zero () -> int = 42 >> 0

@test_shr_divide tests @shr_divide () -> void = {
    // x >> n = x / 2^n (for positive x)
    assert_eq(actual: shr_divide(), expected: 5)
}

@shr_divide () -> int = 80 >> 4

@test_shr_negative_value tests @shr_negative_value () -> void = {
    // Arithmetic right shift preserves sign
    assert_eq(actual: shr_negative_value(), expected: -2)
}

@shr_negative_value () -> int = -16 >> 3

@test_shr_bit_width_panic tests @shr_bit_width_panic () -> void = {
    // Shift count >= bit width should panic
    assert_panics(f: () -> 1 >> 64)
}

@shr_bit_width_panic () -> int = 1 >> 64

@test_shr_negative_count_panic tests @shr_negative_count_panic () -> void = {
    // Negative shift count should panic
    assert_panics(f: () -> 1 >> -1)
}

@shr_negative_count_panic () -> int = 1 >> -1

// =============================================================================
// Byte Operations (requires `as` conversion - NOT YET IMPLEMENTED)
// =============================================================================

// Note: The `as` type conversion operator is not yet implemented in the parser.
// Byte bitwise operation tests are commented out until `as` is available.

// When implemented, tests should cover:
// - byte & byte
// - byte | byte
// - byte ^ byte
// - ~byte
// - byte << int
// - byte >> int

// =============================================================================
// Precedence
// =============================================================================

@test_and_before_or tests @and_before_or () -> void = {
    // & has higher precedence than |
    // 0b1100 | 0b1010 & 0b0011 = 0b1100 | (0b1010 & 0b0011) = 0b1100 | 0b0010 = 0b1110 = 14
    assert_eq(actual: and_before_or(), expected: 14)
}

@and_before_or () -> int = 0b1100 | 0b1010 & 0b0011

@test_xor_between_and_or tests @xor_between_and_or () -> void = {
    // Precedence: & > ^ > |
    // 0b1111 | 0b1100 ^ 0b1010 & 0b0011
    // = 0b1111 | (0b1100 ^ (0b1010 & 0b0011))
    // = 0b1111 | (0b1100 ^ 0b0010)
    // = 0b1111 | 0b1110
    // = 0b1111 = 15
    assert_eq(actual: xor_between_and_or(), expected: 15)
}

@xor_between_and_or () -> int = 0b1111 | 0b1100 ^ 0b1010 & 0b0011

@test_shift_before_bitwise tests @shift_before_bitwise () -> void = {
    // << and >> have higher precedence than &
    // 1 << 2 & 0xF = (1 << 2) & 0xF = 4 & 0xF = 4
    assert_eq(actual: shift_before_bitwise(), expected: 4)
}

@shift_before_bitwise () -> int = 1 << 2 & 0xF

// =============================================================================
// Chained Operations
// =============================================================================

@test_chain_and tests @chain_and () -> void = {
    assert_eq(actual: chain_and(), expected: 0)
}

@chain_and () -> int = 0xFF & 0xF0 & 0x0F

@test_chain_or tests @chain_or () -> void = {
    assert_eq(actual: chain_or(), expected: 0xFF)
}

@chain_or () -> int = 0xF0 | 0x0F | 0x00

@test_chain_xor tests @chain_xor () -> void = {
    // 0b1100 ^ 0b1010 ^ 0b0110 = 0b0110 ^ 0b0110 = 0
    assert_eq(actual: chain_xor(), expected: 0)
}

@chain_xor () -> int = 0b1100 ^ 0b1010 ^ 0b0110

// =============================================================================
// Common Patterns
// =============================================================================

@test_check_bit tests @check_bit () -> void = {
    let value = 0b1010;
    // Check if bit 1 is set
    let bit1_set = (value & 0b0010) != 0;
    assert(cond: bit1_set);
    // Check if bit 0 is set
    let bit0_set = (value & 0b0001) != 0;
    assert(cond: !bit0_set)
}

@check_bit () -> bool = {
    let value = 0b1010;
    (value & 0b0010) != 0
}

@test_set_bit tests @set_bit () -> void = {
    let value = 0b1000;
    let with_bit1 = value | 0b0010;
    assert_eq(actual: with_bit1, expected: 0b1010)
}

@set_bit () -> int = 0b1000 | 0b0010

@test_clear_bit tests @clear_bit () -> void = {
    let value = 0b1010;
    let without_bit1 = value & ~0b0010;
    assert_eq(actual: without_bit1, expected: 0b1000)
}

@clear_bit () -> int = 0b1010 & ~0b0010

@test_toggle_bit tests @toggle_bit () -> void = {
    let value = 0b1010;
    let toggled = value ^ 0b0010;
    assert_eq(actual: toggled, expected: 0b1000)
}

@toggle_bit () -> int = 0b1010 ^ 0b0010

@test_is_power_of_two tests @is_power_of_two () -> void = {
    // n is power of 2 if n > 0 && (n & (n - 1)) == 0
    let n = 8;
    assert(cond: n > 0 && (n & (n - 1)) == 0);
    let m = 7;
    assert(cond: !(m > 0 && (m & (m - 1)) == 0))
}

@is_power_of_two () -> bool = {
    let n = 8;
    n > 0 && (n & (n - 1)) == 0
}

@test_swap_without_temp tests @swap_without_temp () -> void = {
    let a = 5;
    let b = 10;
    a = a ^ b;
    b = a ^ b;
    a = a ^ b;
    assert_eq(actual: a, expected: 10);
    assert_eq(actual: b, expected: 5)
}

@swap_without_temp () -> int = {
    let a = 5;
    let b = 10;
    a = a ^ b;
    b = a ^ b;
    a = a ^ b;
    a
}
