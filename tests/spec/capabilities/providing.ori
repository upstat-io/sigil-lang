// Spec: 14-capabilities.md ยง Providing Capabilities
//
// TODO: Type checker needs capability support
// - `with ... in` expression (capability provision)
// - Capability scoping and shadowing
// - `uses` clause on functions
// - Capability lookup in expressions
//
// Uncomment when type checker supports capabilities.

// use std.testing { assert_eq }
// // Tests for with...in expression (capability provision)
//
// // =============================================================================
// // Basic Capability Provision
// // =============================================================================
//
// // Simple with...in expression
// @test_basic_provision () -> void = run(
//     let result = with Http = "mock_http" in Http,
//     assert_eq(
//         actual: result,
//         expected: "mock_http",
//     ),
// )
//
// // With struct provider
// type MockHttp = { base_url: str }
//
// @test_struct_provider () -> void = run(
//     let result = with Http = MockHttp { base_url: "https://api.example.com" } in Http.base_url,
//     assert_eq(
//         actual: result,
//         expected: "https://api.example.com",
//     ),
// )
//
// // =============================================================================
// // Capability Scoping
// // =============================================================================
//
// // Capability is only available in body
// @test_scoping () -> void = run(
//     let outer = "outer",
//     let inner = with Http = "http" in Http,
//     assert_eq(actual: outer, expected: "outer"),
//     assert_eq(actual: inner, expected: "http"),
// )
//
// // =============================================================================
// // Nested Capability Provision
// // =============================================================================
//
// // Multiple capabilities via nesting
// @test_nested_provision () -> void = run(
//     let result = with Http = "http" in
//         with Cache = "cache" in
//             Http + "-" + Cache,
//     assert_eq(
//         actual: result,
//         expected: "http-cache",
//     ),
// )
//
// // Inner shadows outer
// @test_shadowing () -> void = run(
//     let result = with Http = "outer" in
//         with Http = "inner" in Http,
//     assert_eq(
//         actual: result,
//         expected: "inner",
//     ),
// )
//
// // =============================================================================
// // With Expression Returns Body Value
// // =============================================================================
//
// @test_returns_body_value () -> void = run(
//     let result = with Http = "unused" in 42,
//     assert_eq(
//         actual: result,
//         expected: 42,
//     ),
// )
//
// @test_complex_body () -> void = run(
//     let result = with Logger = "log" in run(
//         let x = 10,
//         let y = 20,
//         x + y,
//     ),
//     assert_eq(
//         actual: result,
//         expected: 30,
//     ),
// )
//
// // =============================================================================
// // Extended Capability Tests
// // =============================================================================
//
// // Test capability with different types
// @test_int_capability () -> void = run(
//     let result = with Counter = 42 in Counter + 1,
//     assert_eq(actual: result, expected: 43),
// )
//
// @test_bool_capability () -> void = run(
//     let result = with Debug = true in if Debug then "on" else "off",
//     assert_eq(actual: result, expected: "on"),
// )
//
// // Test capability with list value
// type MockDataStore = { data: [int] }
//
// @test_list_capability () -> void = run(
//     let store = MockDataStore { data: [1, 2, 3] },
//     let result = with DataStore = store in DataStore.data[0],
//     assert_eq(actual: result, expected: 1),
// )
//
// // Test capability used in conditional
// @test_capability_in_conditional () -> void = run(
//     let result = with Debug = true in
//         if Debug then "debug mode" else "release mode",
//     assert_eq(actual: result, expected: "debug mode"),
// )
//
// // Test capability with multiple uses in body
// @test_multiple_uses () -> void = run(
//     let result = with Value = 10 in Value + Value + Value,
//     assert_eq(actual: result, expected: 30),
// )
//
// // Test deeply nested capabilities (three levels)
// @test_three_level_nesting () -> void = run(
//     let result = with A = 1 in
//         with B = 2 in
//             with C = 3 in
//                 A + B + C,
//     assert_eq(actual: result, expected: 6),
// )
//
// // Test capability with closure that doesn't capture it
// @test_capability_not_in_closure () -> void = run(
//     let f = (x: int) -> x * 2,
//     let result = with Logger = "log" in f(5),
//     assert_eq(actual: result, expected: 10),
// )
//
// // Test capability visible in let binding
// @test_capability_in_let () -> void = run(
//     let result = with X = 100 in run(
//         let y = X / 10,
//         y,
//     ),
//     assert_eq(actual: result, expected: 10),
// )
//
// // Test capability with struct method access
// type Config = { name: str, port: int }
//
// impl Config {
//     @get_address (self) -> str = self.name + ":" + str(self.port)
// }
//
// @test_capability_method_call () -> void = run(
//     let cfg = Config { name: "localhost", port: 8080 },
//     let result = with Cfg = cfg in Cfg.get_address(),
//     assert_eq(actual: result, expected: "localhost:8080"),
// )
//
// // Test capability preserves through function call
// @uses_cap () -> int uses Value = Value
//
// @test_capability_through_function () -> void = run(
//     let result = with Value = 42 in uses_cap(),
//     assert_eq(actual: result, expected: 42),
// )
