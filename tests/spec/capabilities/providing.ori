// Spec: 14-capabilities.md ยง Providing Capabilities

use std.testing { assert_eq }
// Tests for with...in expression (capability provision)

// =============================================================================
// Basic Capability Provision
// =============================================================================

// Simple with...in expression
@test_basic_provision () -> void = {
    let result = with Http = "mock_http" in Http;
    assert_eq(
        actual: result,
        expected: "mock_http",
    )
}

// With struct provider
type MockHttp = { base_url: str }

@test_struct_provider () -> void = {
    let result = with Http = MockHttp { base_url: "https://api.example.com" } in Http.base_url;
    assert_eq(
        actual: result,
        expected: "https://api.example.com",
    )
}

// =============================================================================
// Capability Scoping
// =============================================================================

// Capability is only available in body
@test_scoping () -> void = {
    let outer = "outer";
    let inner = with Http = "http" in Http;
    assert_eq(actual: outer, expected: "outer");
    assert_eq(actual: inner, expected: "http")
}

// =============================================================================
// Nested Capability Provision
// =============================================================================

// Multiple capabilities via nesting
@test_nested_provision () -> void = {
    let result = with Http = "http" in
        with Cache = "cache" in
            Http + "-" + Cache;
    assert_eq(
        actual: result,
        expected: "http-cache",
    )
}

// Inner shadows outer
@test_shadowing () -> void = {
    let result = with Http = "outer" in
        with Http = "inner" in Http;
    assert_eq(
        actual: result,
        expected: "inner",
    )
}

// =============================================================================
// With Expression Returns Body Value
// =============================================================================

@test_returns_body_value () -> void = {
    let result = with Http = "unused" in 42;
    assert_eq(
        actual: result,
        expected: 42,
    )
}

@test_complex_body () -> void = {
    let result = with Logger = "log" in {
        let x = 10;
        let y = 20;
        x + y
    };
    assert_eq(
        actual: result,
        expected: 30,
    )
}

// =============================================================================
// Extended Capability Tests
// =============================================================================

// Test capability with different types
@test_int_capability () -> void = {
    let result = with Counter = 42 in Counter + 1;
    assert_eq(actual: result, expected: 43)
}

@test_bool_capability () -> void = {
    let result = with Debug = true in if Debug then "on" else "off";
    assert_eq(actual: result, expected: "on")
}

// Test capability with list value
type MockDataStore = { data: [int] }

@test_list_capability () -> void = {
    let store = MockDataStore { data: [1, 2, 3] };
    let result = with DataStore = store in DataStore.data[0];
    assert_eq(actual: result, expected: 1)
}

// Test capability used in conditional
@test_capability_in_conditional () -> void = {
    let result = with Debug = true in
        if Debug then "debug mode" else "release mode";
    assert_eq(actual: result, expected: "debug mode")
}

// Test capability with multiple uses in body
@test_multiple_uses () -> void = {
    let result = with Value = 10 in Value + Value + Value;
    assert_eq(actual: result, expected: 30)
}

// Test deeply nested capabilities (three levels)
@test_three_level_nesting () -> void = {
    let result = with A = 1 in
        with B = 2 in
            with C = 3 in
                A + B + C;
    assert_eq(actual: result, expected: 6)
}

// Test capability with closure that doesn't capture it
@test_capability_not_in_closure () -> void = {
    let f = (x: int) -> x * 2;
    let result = with Logger = "log" in f(5);
    assert_eq(actual: result, expected: 10)
}

// Test capability visible in let binding
@test_capability_in_let () -> void = {
    let result = with X = 100 in {
        let y = X / 10;
        y
    };
    assert_eq(actual: result, expected: 10)
}

// Test capability with struct method access
type Config = { name: str, port: int }

impl Config {
    @get_address (self) -> str = self.name + ":" + str(self.port);
}

@test_capability_method_call () -> void = {
    let cfg = Config { name: "localhost", port: 8080 };
    let result = with Cfg = cfg in Cfg.get_address();
    assert_eq(actual: result, expected: "localhost:8080")
}

// Test capability preserves through function call
@uses_cap () -> int uses Value = Value;

@test_capability_through_function () -> void = {
    let result = with Value = 42 in uses_cap();
    assert_eq(actual: result, expected: 42)
}
