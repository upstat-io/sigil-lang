// Spec: 10-patterns.md ยง Pattern Syntax
// Tests for pattern syntax parsing (grammar.ebnf ยง PATTERNS)

use std.testing { assert, assert_eq }

// =============================================================================
// Run Pattern
// =============================================================================

@run_basic () -> int = {
    let x = 1;
    let y = 2;
    x + y
}

@test_run_basic tests @run_basic () -> void = {
    assert_eq(actual: run_basic(), expected: 3)
}

// =============================================================================
// Match Pattern - Literal
// =============================================================================

@match_literal () -> int = {
    let x = 2;
    match x {
        1 -> 10,
        2 -> 20,
        _ -> 0
    }
}

@test_match_literal tests @match_literal () -> void = {
    assert_eq(actual: match_literal(), expected: 20)
}

// =============================================================================
// Match Pattern - Wildcard
// =============================================================================

@match_wildcard () -> int = {
    let x = 99;
    match x {
        1 -> 10,
        _ -> 0
    }
}

@test_match_wildcard tests @match_wildcard () -> void = {
    assert_eq(actual: match_wildcard(), expected: 0)
}

// =============================================================================
// Match Pattern - Binding
// =============================================================================

@match_binding () -> int = {
    let opt = Some(42);
    match opt {
        Some(v) -> v,
        None -> 0
    }
}

@test_match_binding tests @match_binding () -> void = {
    assert_eq(actual: match_binding(), expected: 42)
}

// =============================================================================
// Match Pattern - Variant
// =============================================================================

type Status = Active | Inactive | Pending(count: int);

@match_variant () -> int = {
    let s = Pending(count: 5);
    match s {
        Active -> 1,
        Inactive -> 0,
        Pending(count) -> count
    }
}

@test_match_variant tests @match_variant () -> void = {
    assert_eq(actual: match_variant(), expected: 5)
}

// =============================================================================
// Match Pattern - Tuple
// =============================================================================

@match_tuple () -> int = {
    let t = (1, 2);
    match t {
        (a, b) -> a + b
    }
}

@test_match_tuple tests @match_tuple () -> void = {
    assert_eq(actual: match_tuple(), expected: 3)
}

// =============================================================================
// Match Pattern - List
// =============================================================================

@match_list () -> int = {
    let list = [1, 2, 3];
    match list {
        [a, b, c] -> a + b + c,
        _ -> 0
    }
}

@test_match_list tests @match_list () -> void = {
    assert_eq(actual: match_list(), expected: 6)
}

// =============================================================================
// Binding Pattern - Tuple Destructure
// =============================================================================

@bind_tuple () -> int = {
    let t = (10, 20);
    let (a, b) = t;
    a + b
}

@test_bind_tuple tests @bind_tuple () -> void = {
    assert_eq(actual: bind_tuple(), expected: 30)
}

// =============================================================================
// Binding Pattern - Struct Destructure
// =============================================================================

type Point = { x: int, y: int }

@bind_struct () -> int = {
    let p = Point { x: 5, y: 10 };
    let { x, y } = p;
    x + y
}

@test_bind_struct tests @bind_struct () -> void = {
    assert_eq(actual: bind_struct(), expected: 15)
}

// =============================================================================
// Binding Pattern - List Destructure
// =============================================================================

@bind_list () -> int = {
    let list = [1, 2, 3];
    let [a, b, c] = list;
    a + b + c
}

@test_bind_list tests @bind_list () -> void = {
    assert_eq(actual: bind_list(), expected: 6)
}

// =============================================================================
// Binding Pattern - List with Rest
// =============================================================================

@bind_list_rest () -> int = {
    let list = [1, 2, 3, 4, 5];
    let [head, ..tail] = list;
    head + tail.len()
}

@test_bind_list_rest tests @bind_list_rest () -> void = {
    assert_eq(actual: bind_list_rest(), expected: 5) // 1 + 4
}
