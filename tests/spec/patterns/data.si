// Spec: spec/10-patterns.md § Data Transformation Patterns
// Design: design/02-syntax/04-patterns-reference.md § Data Transformation
//
// Tests for map, filter, fold, collect, find patterns

// Helper function for tests
@identity (x: int) -> int = x

// =============================================================================
// map - Transform each element in a collection
// =============================================================================

// Test: .over property accepts list
// Spec: spec/10-patterns.md § map - Properties
// Design: design/02-syntax/04-patterns-reference.md § map - .over Property
@test_map_over_list tests @identity () -> void = run(
    let nums = [1, 2, 3],
    let doubled = map(.over: nums, .transform: x -> x * 2),
    assert_eq(doubled, [2, 4, 6]),
)

// Test: .transform applies to each element
// Spec: spec/10-patterns.md § map - Semantics
// Design: design/02-syntax/04-patterns-reference.md § map - .transform Property
@test_map_transform_each tests @identity () -> void = run(
    let items = [1, 2, 3, 4, 5],
    let squared = map(.over: items, .transform: x -> x * x),
    assert_eq(squared, [1, 4, 9, 16, 25]),
)

// Test: Return type is [U]
// Spec: spec/10-patterns.md § map - Type Signature
// Design: design/02-syntax/04-patterns-reference.md § map - Return Type
@test_map_return_type tests @identity () -> void = run(
    let nums = [1, 2, 3],
    let strings = map(.over: nums, .transform: x -> str(x)),
    assert_eq(len(strings), 3),
)

// Test: Empty list returns empty list
// Spec: spec/10-patterns.md § map - Semantics
// Design: design/02-syntax/04-patterns-reference.md § map - Edge Cases
@test_map_empty_list tests @identity () -> void = run(
    let empty: [int] = [],
    let result = map(.over: empty, .transform: x -> x * 2),
    assert_eq(len(result), 0),
)

// =============================================================================
// filter - Select elements matching a predicate
// =============================================================================

// Test: .over property accepts list
// Spec: spec/10-patterns.md § filter - Properties
// Design: design/02-syntax/04-patterns-reference.md § filter - .over Property
@test_filter_over_list tests @identity () -> void = run(
    let nums = [1, 2, 3, 4, 5],
    let evens = filter(.over: nums, .predicate: x -> x % 2 == 0),
    assert_eq(evens, [2, 4]),
)

// Test: .predicate selects matching elements
// Spec: spec/10-patterns.md § filter - Semantics
// Design: design/02-syntax/04-patterns-reference.md § filter - .predicate Property
@test_filter_predicate tests @identity () -> void = run(
    let nums = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10],
    let big = filter(.over: nums, .predicate: x -> x > 5),
    assert_eq(big, [6, 7, 8, 9, 10]),
)

// Test: Return type is [T]
// Spec: spec/10-patterns.md § filter - Type Signature
// Design: design/02-syntax/04-patterns-reference.md § filter - Return Type
@test_filter_return_type tests @identity () -> void = run(
    let nums = [1, 2, 3, 4, 5],
    let result = filter(.over: nums, .predicate: x -> x > 0),
    assert_eq(result, [1, 2, 3, 4, 5]),
)

// Test: No matches returns empty list
// Spec: spec/10-patterns.md § filter - Semantics
// Design: design/02-syntax/04-patterns-reference.md § filter - Edge Cases
@test_filter_no_matches tests @identity () -> void = run(
    let nums = [1, 2, 3],
    let result = filter(.over: nums, .predicate: x -> x > 100),
    assert_eq(len(result), 0),
)

// Test: Empty list returns empty list
// Spec: spec/10-patterns.md § filter - Semantics
// Design: design/02-syntax/04-patterns-reference.md § filter - Edge Cases
@test_filter_empty_list tests @identity () -> void = run(
    let empty: [int] = [],
    let result = filter(.over: empty, .predicate: x -> x > 0),
    assert_eq(len(result), 0),
)

// =============================================================================
// fold - Reduce a collection to a single value
// =============================================================================

// Test: .init is initial accumulator
// Spec: spec/10-patterns.md § fold - Properties
// Design: design/02-syntax/04-patterns-reference.md § fold - .init Property
@test_fold_init tests @identity () -> void = run(
    let nums = [1, 2, 3, 4, 5],
    let sum = fold(.over: nums, .init: 0, .op: (acc, x) -> acc + x),
    assert_eq(sum, 15),
)

// Test: .op combines accumulator and element
// Spec: spec/10-patterns.md § fold - Semantics
// Design: design/02-syntax/04-patterns-reference.md § fold - .op Property
@test_fold_op tests @identity () -> void = run(
    let nums = [1, 2, 3, 4],
    let product = fold(.over: nums, .init: 1, .op: (acc, x) -> acc * x),
    assert_eq(product, 24),
)

// Test: Reduce logic
// Spec: spec/10-patterns.md § fold - Semantics
// Design: design/02-syntax/04-patterns-reference.md § fold - Reduction
@test_fold_reduce tests @identity () -> void = run(
    let words = ["a", "b", "c"],
    let concat = fold(.over: words, .init: "", .op: (acc, w) -> acc + w),
    assert_eq(concat, "abc"),
)

// Test: Return type is U
// Spec: spec/10-patterns.md § fold - Type Signature
// Design: design/02-syntax/04-patterns-reference.md § fold - Return Type
@test_fold_return_type tests @identity () -> void = run(
    let nums = [1, 2, 3],
    let count = fold(.over: nums, .init: 0, .op: (acc, _) -> acc + 1),
    assert_eq(count, 3),
)

// Test: Empty list returns init
// Spec: spec/10-patterns.md § fold - Semantics
// Design: design/02-syntax/04-patterns-reference.md § fold - Edge Cases
@test_fold_empty_list tests @identity () -> void = run(
    let empty: [int] = [],
    let result = fold(.over: empty, .init: 42, .op: (acc, x) -> acc + x),
    assert_eq(result, 42),
)

// =============================================================================
// collect - Build a list from a range
// =============================================================================

// Test: .range property accepts range
// Spec: spec/10-patterns.md § collect - Properties
// Design: design/02-syntax/04-patterns-reference.md § collect - .range Property
@test_collect_range tests @identity () -> void = run(
    let result = collect(.range: 1..4, .transform: x -> x),
    assert_eq(result, [1, 2, 3]),
)

// Test: .transform applies to each value
// Spec: spec/10-patterns.md § collect - Semantics
// Design: design/02-syntax/04-patterns-reference.md § collect - .transform Property
@test_collect_transform tests @identity () -> void = run(
    let squares = collect(.range: 1..5, .transform: x -> x * x),
    assert_eq(squares, [1, 4, 9, 16]),
)

// Test: Return type is [T]
// Spec: spec/10-patterns.md § collect - Type Signature
// Design: design/02-syntax/04-patterns-reference.md § collect - Return Type
@test_collect_return_type tests @identity () -> void = run(
    let strings = collect(.range: 1..4, .transform: x -> str(x)),
    assert_eq(len(strings), 3),
)

// Test: Empty range returns empty list
// Spec: spec/10-patterns.md § collect - Semantics
// Design: design/02-syntax/04-patterns-reference.md § collect - Edge Cases
@test_collect_empty_range tests @identity () -> void = run(
    let result = collect(.range: 5..5, .transform: x -> x),
    assert_eq(len(result), 0),
)

// =============================================================================
// find - Find the first element matching a predicate
// =============================================================================

// Test: .over property accepts list
// Spec: spec/10-patterns.md § find - Properties
// Design: design/02-syntax/04-patterns-reference.md § find - .over Property
@test_find_over_list tests @identity () -> void = run(
    let nums = [1, 2, 3, 4, 5],
    let result = find(.over: nums, .where: x -> x > 3),
    assert_eq(result, Some(4)),
)

// Test: .where predicate finds first match
// Spec: spec/10-patterns.md § find - Semantics
// Design: design/02-syntax/04-patterns-reference.md § find - .where Property
@test_find_first_match tests @identity () -> void = run(
    let nums = [1, 2, 3, 4, 5],
    let result = find(.over: nums, .where: x -> x % 2 == 0),
    assert_eq(result, Some(2)),
)

// Test: Returns None when not found
// Spec: spec/10-patterns.md § find - Return Value
// Design: design/02-syntax/04-patterns-reference.md § find - Not Found
@test_find_not_found tests @identity () -> void = run(
    let nums = [1, 2, 3],
    let result = find(.over: nums, .where: x -> x > 100),
    assert_eq(result, None),
)

// Test: .default provides fallback
// Spec: spec/10-patterns.md § find - Properties
// Design: design/02-syntax/04-patterns-reference.md § find - .default Property
@test_find_with_default tests @identity () -> void = run(
    let nums = [1, 2, 3],
    let result = find(.over: nums, .where: x -> x > 100, .default: 0),
    assert_eq(result, 0),
)

// Test: Return type Option<T> without default
// Spec: spec/10-patterns.md § find - Type Signature
// Design: design/02-syntax/04-patterns-reference.md § find - Return Type
@test_find_return_option tests @identity () -> void = run(
    let nums = [1, 2, 3],
    let result = find(.over: nums, .where: x -> x == 2),
    assert_some(result),
)

// Test: Return type T with default
// Spec: spec/10-patterns.md § find - Type Signature
// Design: design/02-syntax/04-patterns-reference.md § find - Return Type with Default
@test_find_return_t_with_default tests @identity () -> void = run(
    let nums = [1, 2, 3],
    let result = find(.over: nums, .where: x -> x == 2, .default: -1),
    assert_eq(result, 2),
)

// Test: Empty list returns None
// Spec: spec/10-patterns.md § find - Semantics
// Design: design/02-syntax/04-patterns-reference.md § find - Edge Cases
@test_find_empty_list tests @identity () -> void = run(
    let empty: [int] = [],
    let result = find(.over: empty, .where: x -> x > 0),
    assert_eq(result, None),
)

// =============================================================================
// Combined patterns test
// Spec: spec/10-patterns.md § Data Transformation Patterns
// Design: design/02-syntax/04-patterns-reference.md § Pattern Composition
// =============================================================================

@test_combined_map_filter_fold tests @identity () -> void = run(
    let nums = [1, 2, 3, 4, 5],
    let doubled = map(.over: nums, .transform: x -> x * 2),
    let filtered = filter(.over: doubled, .predicate: x -> x > 5),
    let sum = fold(.over: filtered, .init: 0, .op: (acc, x) -> acc + x),
    assert_eq(sum, 24),
)
