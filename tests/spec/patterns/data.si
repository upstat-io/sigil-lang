// Spec: 10-patterns.md ยง Data Transformation Patterns
// Design: 02-syntax/04-patterns-reference.md ยง map, filter, fold

use std.testing { assert, assert_eq, assert_ne }

// =============================================================================
// map Pattern
// =============================================================================

@test_map_double tests @map_double () -> void = run(
    let result = map(
        over: [1, 2, 3],
        transform: x -> x * 2,
    ),
    assert_eq(
        actual: result[0],
        expected: 2,
    ),
    assert_eq(
        actual: result[1],
        expected: 4,
    ),
    assert_eq(
        actual: result[2],
        expected: 6,
    ),
)

@map_double () -> int = run(
    let result = map(
        over: [1, 2, 3],
        transform: x -> x * 2,
    ),
    result[0],
)

@test_map_to_string tests @map_to_string () -> void = run(
    let nums = [1, 2, 3],
    let strs = map(
        over: nums,
        transform: x -> str(x),
    ),
    assert_eq(
        actual: strs[0],
        expected: "1",
    ),
)

@map_to_string () -> str = run(
    let nums = [1, 2, 3],
    let strs = map(
        over: nums,
        transform: x -> str(x),
    ),
    strs[0],
)

// =============================================================================
// filter Pattern
// =============================================================================

@test_filter_positive tests @filter_positive () -> void = run(
    let nums = [1, -2, 3, -4, 5],
    let positive = filter(
        over: nums,
        predicate: x -> x > 0,
    ),
    assert_eq(
        actual: len(collection: positive),
        expected: 3,
    ),
    assert_eq(
        actual: positive[0],
        expected: 1,
    ),
    assert_eq(
        actual: positive[1],
        expected: 3,
    ),
    assert_eq(
        actual: positive[2],
        expected: 5,
    ),
)

@filter_positive () -> int = run(
    let nums = [1, -2, 3, -4, 5],
    let positive = filter(
        over: nums,
        predicate: x -> x > 0,
    ),
    len(collection: positive),
)

@test_filter_even tests @filter_even () -> void = run(
    let nums = [1, 2, 3, 4, 5, 6],
    let evens = filter(
        over: nums,
        predicate: x -> x % 2 == 0,
    ),
    assert_eq(
        actual: len(collection: evens),
        expected: 3,
    ),
)

@filter_even () -> int = run(
    let nums = [1, 2, 3, 4, 5, 6],
    let evens = filter(
        over: nums,
        predicate: x -> x % 2 == 0,
    ),
    len(collection: evens),
)

// =============================================================================
// fold Pattern
// =============================================================================

@test_fold_sum tests @fold_sum () -> void = run(
    let nums = [1, 2, 3, 4, 5],
    let sum = fold(
        over: nums,
        init: 0,
        op: (acc, x) -> acc + x,
    ),
    assert_eq(
        actual: sum,
        expected: 15,
    ),
)

@fold_sum () -> int = run(
    let nums = [1, 2, 3, 4, 5],
    fold(
        over: nums,
        init: 0,
        op: (acc, x) -> acc + x,
    ),
)

@test_fold_product tests @fold_product () -> void = run(
    let nums = [1, 2, 3, 4],
    let product = fold(
        over: nums,
        init: 1,
        op: (acc, x) -> acc * x,
    ),
    assert_eq(
        actual: product,
        expected: 24,
    ),
)

@fold_product () -> int = run(
    let nums = [1, 2, 3, 4],
    fold(
        over: nums,
        init: 1,
        op: (acc, x) -> acc * x,
    ),
)

// =============================================================================
// Combined Patterns
// =============================================================================

@test_map_filter_chain tests @map_filter_chain () -> void = run(
    let nums = [1, 2, 3, 4, 5],
    // Double all numbers
    let doubled = map(
        over: nums,
        transform: x -> x * 2,
    ),
    // Keep only those > 5
    let big = filter(
        over: doubled,
        predicate: x -> x > 5,
    ),
    assert_eq(
        actual: len(collection: big),
        expected: 3,
    ),
)

@map_filter_chain () -> int = run(
    let nums = [1, 2, 3, 4, 5],
    let doubled = map(
        over: nums,
        transform: x -> x * 2,
    ),
    let big = filter(
        over: doubled,
        predicate: x -> x > 5,
    ),
    len(collection: big),
)

@test_filter_map_fold tests @filter_map_fold () -> void = run(
    let nums = [1, 2, 3, 4, 5, 6],
    // Keep evens
    let evens = filter(
        over: nums,
        predicate: x -> x % 2 == 0,
    ),
    // Square them
    let squared = map(
        over: evens,
        transform: x -> x * x,
    ),
    // Sum
    let sum = fold(
        over: squared,
        init: 0,
        op: (acc, x) -> acc + x,
    ),
    // 4 + 16 + 36 = 56
    assert_eq(
        actual: sum,
        expected: 56,
    ),
)

@filter_map_fold () -> int = run(
    let nums = [1, 2, 3, 4, 5, 6],
    let evens = filter(
        over: nums,
        predicate: x -> x % 2 == 0,
    ),
    let squared = map(
        over: evens,
        transform: x -> x * x,
    ),
    fold(
        over: squared,
        init: 0,
        op: (acc, x) -> acc + x,
    ),
)

// =============================================================================
// find Pattern
// =============================================================================

@test_find_first_match tests @find_first_match () -> void = run(
    let nums = [1, 2, 3, 4, 5],
    let found = find(
        over: nums,
        where: x -> x > 2,
    ),
    assert(
        cond: is_some(opt: found),
    ),
)

@find_first_match () = run(
    let nums = [1, 2, 3, 4, 5],
    find(
        over: nums,
        where: x -> x > 2,
    ),
)

@test_find_no_match tests @find_no_match () -> void = run(
    let nums = [1, 2, 3],
    let found = find(
        over: nums,
        where: x -> x > 10,
    ),
    assert(
        cond: is_none(opt: found),
    ),
)

@find_no_match () = run(
    let nums = [1, 2, 3],
    find(
        over: nums,
        where: x -> x > 10,
    ),
)

@test_find_with_default tests @find_with_default () -> void = run(
    let nums = [1, 2, 3],
    let found = find(
        over: nums,
        where: x -> x > 10,
        default: 99,
    ),
    assert_eq(
        actual: found,
        expected: 99,
    ),
)

@find_with_default () -> int = run(
    let nums = [1, 2, 3],
    find(
        over: nums,
        where: x -> x > 10,
        default: 99,
    ),
)

// =============================================================================
// find_map Pattern (find with .map instead of .where)
// =============================================================================

// Helper to simulate Option-returning transformation
@try_parse_positive (x: int) = run(
    if x > 0 then Some(x * 10) else None,
)

@test_find_map_found tests @find_map_found () -> void = run(
    let nums = [-1, -2, 3, -4, 5],
    let found = find(
        over: nums,
        map: x -> try_parse_positive(x),
    ),
    // Should find 3, transform to 30
    assert(
        cond: is_some(opt: found),
    ),
)

@find_map_found () = run(
    let nums = [-1, -2, 3, -4, 5],
    find(
        over: nums,
        map: x -> try_parse_positive(x),
    ),
)

@test_find_map_not_found tests @find_map_not_found () -> void = run(
    let nums = [-1, -2, -3],
    let found = find(
        over: nums,
        map: x -> try_parse_positive(x),
    ),
    // All negative, no Some found
    assert(
        cond: is_none(opt: found),
    ),
)

@find_map_not_found () = run(
    let nums = [-1, -2, -3],
    find(
        over: nums,
        map: x -> try_parse_positive(x),
    ),
)

// =============================================================================
// collect Pattern
// =============================================================================

@test_collect_range tests @collect_range () -> void = run(
    let result = collect(
        range: 0..5,
        transform: x -> x * 2,
    ),
    assert_eq(
        actual: len(collection: result),
        expected: 5,
    ),
    assert_eq(
        actual: result[0],
        expected: 0,
    ),
    assert_eq(
        actual: result[4],
        expected: 8,
    ),
)

@collect_range () = run(
    collect(
        range: 0..5,
        transform: x -> x * 2,
    ),
)

@test_collect_inclusive tests @collect_inclusive () -> void = run(
    let result = collect(
        range: 1..=3,
        transform: x -> x,
    ),
    assert_eq(
        actual: len(collection: result),
        expected: 3,
    ),
    assert_eq(
        actual: result[0],
        expected: 1,
    ),
    assert_eq(
        actual: result[2],
        expected: 3,
    ),
)

@collect_inclusive () = run(
    collect(
        range: 1..=3,
        transform: x -> x,
    ),
)
