// Spec Tests: 10-patterns.md ยง Data Transformation Patterns
// Tests are the source of truth - the compiler must conform to these tests

// =============================================================================
// Map Pattern (Spec: Transform each element in a collection)
// =============================================================================

@map_double (items: [int]) -> [int] = map(
    .over: items,
    .transform: x -> x * 2,
)

@test_map_double tests @map_double () -> void = run(
    // Spec: .over: [T], .transform: T -> U, Result: [U]
    assert(map_double([1, 2, 3]) == [2, 4, 6]),
    assert(map_double([]) == []),
)

@map_to_string (items: [int]) -> [str] = map(
    .over: items,
    .transform: x -> str(x),
)

@test_map_type_change tests @map_to_string () -> void = run(
    // Spec: map can change element type
    assert(map_to_string([1, 2, 3]) == ["1", "2", "3"]),
)

// =============================================================================
// Filter Pattern (Spec: Select elements matching a predicate)
// =============================================================================

@filter_positive (items: [int]) -> [int] = filter(
    .over: items,
    .predicate: x -> x > 0,
)

@test_filter_positive tests @filter_positive () -> void = run(
    // Spec: .over: [T], .predicate: T -> bool, Result: [T]
    assert(filter_positive([1, -2, 3, -4, 5]) == [1, 3, 5]),
    assert(filter_positive([-1, -2]) == []),
    assert(filter_positive([1, 2, 3]) == [1, 2, 3]),
)

@filter_even (items: [int]) -> [int] = filter(
    .over: items,
    .predicate: x -> x % 2 == 0,
)

@test_filter_even tests @filter_even () -> void = run(
    assert(filter_even([1, 2, 3, 4, 5, 6]) == [2, 4, 6]),
    assert(filter_even([1, 3, 5]) == []),
)

// =============================================================================
// Fold Pattern (Spec: Reduce a collection to a single value)
// =============================================================================

@fold_sum (items: [int]) -> int = fold(
    .over: items,
    .init: 0,
    .op: (acc, x) -> acc + x,
)

@test_fold_sum tests @fold_sum () -> void = run(
    // Spec: .over: [T], .init: U, .op: (U, T) -> U, Result: U
    assert(fold_sum([1, 2, 3, 4, 5]) == 15),
    assert(fold_sum([]) == 0),
    assert(fold_sum([10]) == 10),
)

@fold_product (items: [int]) -> int = fold(
    .over: items,
    .init: 1,
    .op: (acc, x) -> acc * x,
)

@test_fold_product tests @fold_product () -> void = run(
    assert(fold_product([1, 2, 3, 4]) == 24),
    assert(fold_product([]) == 1),
)

@fold_max (items: [int]) -> int = fold(
    .over: items,
    .init: 0,
    .op: (acc, x) -> if x > acc then x else acc,
)

@test_fold_max tests @fold_max () -> void = run(
    assert(fold_max([3, 1, 4, 1, 5, 9, 2, 6]) == 9),
)

// =============================================================================
// Collect Pattern (Spec: Build a list from a range)
// =============================================================================

@collect_squares () -> [int] = collect(
    .range: 1..=5,
    .transform: x -> x * x,
)

@test_collect_squares tests @collect_squares () -> void = run(
    // Spec: .range: Range, .transform: int -> T, Result: [T]
    assert(collect_squares() == [1, 4, 9, 16, 25]),
)

@collect_range () -> [int] = collect(
    .range: 0..5,
    .transform: x -> x,
)

@test_collect_range tests @collect_range () -> void = run(
    // Spec: 0..5 is exclusive (0, 1, 2, 3, 4)
    assert(collect_range() == [0, 1, 2, 3, 4]),
)

// =============================================================================
// Find Pattern (Spec: Find the first element matching a predicate)
// =============================================================================

@find_first_positive (items: [int]) -> Option<int> = find(
    .over: items,
    .where: x -> x > 0,
)

@test_find_first tests @find_first_positive () -> void = run(
    // Spec: .over: [T], .where: T -> bool, Result: Option<T>
    assert(find_first_positive([-1, -2, 3, 4]) == Some(3)),
    assert(find_first_positive([-1, -2]) == None),
)

@find_with_default (items: [int]) -> int = find(
    .over: items,
    .where: x -> x > 100,
    .default: 0,
)

@test_find_default tests @find_with_default () -> void = run(
    // Spec: With .default, Result: T (not Option<T>)
    assert(find_with_default([1, 2, 3]) == 0),
    assert(find_with_default([1, 200, 3]) == 200),
)

// =============================================================================
// Recurse Pattern (Spec: Define a recursive function)
// =============================================================================

@factorial (n: int) -> int = recurse(
    .cond: n <= 1,
    .base: 1,
    .step: n * self(n - 1),
)

@test_factorial tests @factorial () -> void = run(
    // Spec: .cond: bool, .base: T, .step: T (uses self())
    assert(factorial(0) == 1),
    assert(factorial(1) == 1),
    assert(factorial(5) == 120),
)

@fibonacci (n: int) -> int = recurse(
    .cond: n <= 1,
    .base: n,
    .step: self(n - 1) + self(n - 2),
    .memo: true,
)

@test_fibonacci tests @fibonacci () -> void = run(
    // Spec: .memo: true enables memoization
    assert(fibonacci(0) == 0),
    assert(fibonacci(1) == 1),
    assert(fibonacci(10) == 55),
)

// =============================================================================
// Pattern Chaining (Map -> Filter -> Fold)
// =============================================================================

@sum_of_squares_of_evens (items: [int]) -> int = run(
    let evens = filter(.over: items, .predicate: x -> x % 2 == 0),
    let squares = map(.over: evens, .transform: x -> x * x),
    fold(.over: squares, .init: 0, .op: (a, b) -> a + b),
)

@test_chained tests @sum_of_squares_of_evens () -> void = run(
    // 2^2 + 4^2 = 4 + 16 = 20
    assert(sum_of_squares_of_evens([1, 2, 3, 4, 5]) == 20),
)
