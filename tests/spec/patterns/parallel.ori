// Spec: 10-patterns.md ยง parallel
// Tests for parallel() with tasks, max_concurrent, timeout

use std.testing { assert, assert_eq }

// =============================================================================
// Basic parallel Pattern
// =============================================================================

// NOTE: Concurrency patterns require async/Suspend capability and may not be
// fully implemented. These tests are designed to expose missing features.

// Simple task that returns immediately
@simple_task (n: int) -> int uses Suspend = n * 2

// @test_parallel_basic tests @parallel_basic () -> void = run(
//     let results = parallel(tasks: [
//         () -> simple_task(n: 1),
//         () -> simple_task(n: 2),
//         () -> simple_task(n: 3),
//     ]),
//     assert_eq(actual: results.len(), expected: 3),
//     // All should be Ok
//     for r in results do assert(cond: is_ok(r: r)),
// )

// @parallel_basic () -> [Result<int, CancellationError>] = parallel(tasks: [
//     () -> simple_task(n: 1),
//     () -> simple_task(n: 2),
//     () -> simple_task(n: 3),
// ])

// =============================================================================
// parallel with Empty Task List
// =============================================================================

// @test_parallel_empty tests @parallel_empty () -> void = run(
//     let results = parallel(tasks: []),
//     assert_eq(actual: results.len(), expected: 0),
// )

// @parallel_empty () -> [Result<void, CancellationError>] = parallel(tasks: [])

// =============================================================================
// parallel with max_concurrent
// =============================================================================

// @test_parallel_max_concurrent tests @parallel_max_concurrent () -> void = run(
//     let results = parallel(
//         tasks: [
//             () -> simple_task(n: 1),
//             () -> simple_task(n: 2),
//             () -> simple_task(n: 3),
//             () -> simple_task(n: 4),
//             () -> simple_task(n: 5),
//         ],
//         max_concurrent: Some(2),
//     ),
//     assert_eq(actual: results.len(), expected: 5),
// )

// @parallel_max_concurrent () -> [Result<int, CancellationError>] = parallel(
//     tasks: [
//         () -> simple_task(n: 1),
//         () -> simple_task(n: 2),
//         () -> simple_task(n: 3),
//     ],
//     max_concurrent: Some(1),
// )

// =============================================================================
// parallel with timeout
// =============================================================================

// @slow_task () -> int uses Suspend = run(
//     // Simulate slow operation
//     sleep(duration: 10s),
//     42,
// )

// @test_parallel_timeout tests @parallel_timeout () -> void = run(
//     let results = parallel(
//         tasks: [() -> slow_task()],
//         timeout: Some(1ms),
//     ),
//     // Should timeout
//     assert(cond: is_err(r: results[0])),
// )

// =============================================================================
// parallel Preserves Result Order
// =============================================================================

// @test_parallel_order tests @parallel_order () -> void = run(
//     // Even if tasks complete out of order, results should be in task order
//     let results = parallel(tasks: [
//         () -> 1,
//         () -> 2,
//         () -> 3,
//     ]),
//     match(results[0],
//         Ok(v) -> assert_eq(actual: v, expected: 1),
//         Err(_) -> assert(cond: false),
//     ),
//     match(results[1],
//         Ok(v) -> assert_eq(actual: v, expected: 2),
//         Err(_) -> assert(cond: false),
//     ),
//     match(results[2],
//         Ok(v) -> assert_eq(actual: v, expected: 3),
//         Err(_) -> assert(cond: false),
//     ),
// )

// =============================================================================
// parallel with Failures
// =============================================================================

// @failing_task () -> int uses Suspend = panic(msg: "task failed")

// @test_parallel_with_failure tests @parallel_with_failure () -> void = run(
//     // One failure should not stop other tasks
//     let results = parallel(tasks: [
//         () -> simple_task(n: 1),
//         () -> failing_task(),
//         () -> simple_task(n: 3),
//     ]),
//     assert_eq(actual: results.len(), expected: 3),
//     assert(cond: is_ok(r: results[0])),
//     assert(cond: is_err(r: results[1])),
//     assert(cond: is_ok(r: results[2])),
// )

// =============================================================================
// Fallback: Sequential Execution Tests
// =============================================================================

// These tests verify basic functionality without requiring async runtime

@compute_square (n: int) -> int = n * n

@test_compute_tasks tests @compute_tasks () -> void = run(
    let tasks = [1, 2, 3, 4, 5],
    let results = for t in tasks yield compute_square(n: t),
    assert_eq(actual: results, expected: [1, 4, 9, 16, 25]),
)

@compute_tasks () -> [int] = for t in [1, 2, 3, 4, 5] yield compute_square(n: t)

@test_task_list tests @task_list () -> void = run(
    // Build a list of functions and evaluate them
    let fns: [() -> int] = [() -> 1, () -> 2, () -> 3],
    let results = for f in fns yield f(),
    assert_eq(actual: results, expected: [1, 2, 3]),
)

@task_list () -> [int] = run(
    let fns: [() -> int] = [() -> 1, () -> 2, () -> 3],
    for f in fns yield f(),
)

// =============================================================================
// Testing Task Result Collection
// =============================================================================

@process_item (n: int) -> Result<int, str> = run(
    if n < 0 then Err("negative") else Ok(n * 2),
)

@test_task_results tests @task_results () -> void = run(
    let items = [1, -2, 3, -4, 5],
    let results = for n in items yield process_item(n: n),
    assert_eq(actual: results.len(), expected: 5),
    assert(cond: is_ok(r: results[0])),
    assert(cond: is_err(r: results[1])),
    assert(cond: is_ok(r: results[2])),
    assert(cond: is_err(r: results[3])),
    assert(cond: is_ok(r: results[4])),
)

@task_results () -> [Result<int, str>] = for n in [1, -2, 3] yield process_item(n: n)

// =============================================================================
// spawn Pattern (Fire-and-Forget)
// =============================================================================

// @test_spawn_basic tests @spawn_basic () -> void = run(
//     // spawn returns immediately, tasks run in background
//     spawn(tasks: [
//         () -> simple_task(n: 1),
//         () -> simple_task(n: 2),
//     ]),
//     assert(cond: true),
// )

// @spawn_basic () -> void = spawn(tasks: [
//     () -> simple_task(n: 1),
// ])

// =============================================================================
// timeout Pattern
// =============================================================================

// @test_timeout_success tests @timeout_success () -> void = run(
//     let result = timeout(op: simple_task(n: 5), after: 1s),
//     assert(cond: is_ok(r: result)),
//     match(result,
//         Ok(v) -> assert_eq(actual: v, expected: 10),
//         Err(_) -> assert(cond: false),
//     ),
// )

// @timeout_success () -> Result<int, CancellationError> = timeout(
//     op: simple_task(n: 5),
//     after: 1s,
// )

// @test_timeout_expires tests @timeout_expires () -> void = run(
//     let result = timeout(op: slow_task(), after: 1ms),
//     assert(cond: is_err(r: result)),
// )

// =============================================================================
// Simulated Concurrency Tests (Single-Threaded)
// =============================================================================

// These tests verify the semantics without actual parallelism

@accumulate_results (items: [int]) -> [int] = for item in items yield item * 2

@test_accumulate tests @accumulate () -> void = run(
    let result = accumulate_results(items: [1, 2, 3, 4, 5]),
    assert_eq(actual: result, expected: [2, 4, 6, 8, 10]),
)

@accumulate () -> [int] = accumulate_results(items: [1, 2, 3, 4, 5])

// Test that errors don't prevent other results
@test_collect_all_semantics tests @collect_all_semantics () -> void = run(
    let items = [1, 0, 3, 0, 5],
    let results = for n in items yield if n == 0 then Err("zero") else Ok(n * 2),
    let oks = for r in results if is_ok(r: r) yield match(r, Ok(v) -> v, Err(_) -> 0),
    assert_eq(actual: oks, expected: [2, 6, 10]),
)

@collect_all_semantics () -> [Result<int, str>] = for n in [1, 0, 3] yield
    if n == 0 then Err("zero") else Ok(n * 2)
