// Spec: 07-properties-of-types.md ยง Traceable
// ? operator injects trace entries

use std.testing { assert_eq, assert }

// Helper that always fails
@fail () -> Result<int, Error> =
    Err(Error("fail"));

// Single ? adds one trace entry
@one_hop () -> Result<int, Error> = {
    let x = fail()?;
    Ok(x)
}

@test_has tests @has () -> void = {
    let r = one_hop();
    assert(cond: r.has_trace())
}

@has () -> bool = {
    let r = one_hop();
    r.has_trace()
}

@test_count tests @count () -> void = {
    let r = one_hop();
    assert_eq(
        actual: r.trace_entries().len(),
        expected: 1,
    )
}

@count () -> int = {
    let r = one_hop();
    r.trace_entries().len()
}

@test_tr tests @tr () -> void = {
    let r = one_hop();
    assert(cond: r.trace() != "")
}

@tr () -> bool = {
    let r = one_hop();
    r.trace() != ""
}

// Chained: two ? sites = two entries
@inner () -> Result<int, Error> = {
    let x = fail()?;
    Ok(x)
}

@outer () -> Result<int, Error> = {
    let x = inner()?;
    Ok(x)
}

@test_chain tests @chain () -> void = {
    let r = outer();
    assert_eq(
        actual: r.trace_entries().len(),
        expected: 2,
    )
}

@chain () -> int = {
    let r = outer();
    r.trace_entries().len()
}

@test_chain_has tests @chain_has () -> void = {
    let r = outer();
    assert(cond: r.has_trace())
}

@chain_has () -> bool = {
    let r = outer();
    r.has_trace()
}

// Ok values pass through ? untouched
@ok () -> Result<int, Error> = Ok(42);

@ok_hop () -> Result<int, Error> = {
    let x = ok()?;
    Ok(x)
}

@test_ok_clean tests @ok_clean () -> void = {
    let r = ok_hop();
    assert_eq(
        actual: r.has_trace(),
        expected: false,
    )
}

@ok_clean () -> bool = {
    let r = ok_hop();
    r.has_trace()
}
