// Spec: 07-properties-of-types.md § Printable Trait — Derivation
// Tests for #[derive(Printable)] format: "TypeName(val1, val2)"

use std.testing { assert_eq }

// =============================================================================
// Basic Derived Printable
// =============================================================================

#[derive(Printable)]
type Point = { x: int, y: int }

@test_derived_printable_basic tests @derived_basic () -> void = {
    let p = Point { x: 1, y: 2 };
    assert_eq(actual: p.to_str(), expected: "Point(1, 2)")
}

@derived_basic () -> str = Point { x: 1, y: 2 }.to_str()

// =============================================================================
// Single Field Struct
// =============================================================================

#[derive(Printable)]
type Wrapper = { value: int }

@test_derived_single_field tests @derived_single () -> void = {
    let w = Wrapper { value: 42 };
    assert_eq(actual: w.to_str(), expected: "Wrapper(42)")
}

@derived_single () -> str = Wrapper { value: 42 }.to_str()

// =============================================================================
// Multiple Field Types
// =============================================================================

#[derive(Printable)]
type Person = { name: str, age: int, active: bool }

@test_derived_mixed_types tests @derived_mixed () -> void = {
    let p = Person { name: "Alice", age: 30, active: true };
    assert_eq(actual: p.to_str(), expected: "Person(Alice, 30, true)")
}

@derived_mixed () -> str = Person { name: "Alice", age: 30, active: true }.to_str()

// =============================================================================
// Nested Derived Printable
// =============================================================================

#[derive(Printable)]
type Line = { start: Point, end: Point }

@test_derived_nested tests @derived_nested () -> void = {
    let l = Line {
        start: Point { x: 0, y: 0 },
        end: Point { x: 10, y: 20 }
    };
    assert_eq(actual: l.to_str(), expected: "Line(Point(0, 0), Point(10, 20))")
}

@derived_nested () -> str = {
    Line {
        start: Point { x: 0, y: 0 },
        end: Point { x: 10, y: 20 }
    }.to_str()
}

// =============================================================================
// Many Fields
// =============================================================================

#[derive(Printable)]
type Config = { name: str, port: int, debug: bool, host: str }

@test_derived_many_fields tests @derived_many () -> void = {
    let c = Config { name: "app", port: 8080, debug: true, host: "localhost" };
    assert_eq(actual: c.to_str(), expected: "Config(app, 8080, true, localhost)")
}

@derived_many () -> str = {
    Config { name: "app", port: 8080, debug: true, host: "localhost" }.to_str()
}

// =============================================================================
// Printable vs Debug Distinction for Derived Types
// =============================================================================

// Debug shows field names: "Point { x: 1, y: 2 }"
// Printable shows values only: "Point(1, 2)"

#[derive(Printable, Debug)]
type Color = { r: int, g: int, b: int }

@test_printable_vs_debug tests @printable_vs_debug () -> void = {
    let c = Color { r: 255, g: 128, b: 0 };
    let printable = c.to_str();
    let debug_str = c.debug();
    // Printable: compact, values-only
    assert_eq(actual: printable, expected: "Color(255, 128, 0)");
    // Debug: structural, with field names
    assert_eq(actual: debug_str, expected: "Color { r: 255, g: 128, b: 0 }")
}

@printable_vs_debug () -> str = Color { r: 255, g: 128, b: 0 }.to_str()

// =============================================================================
// String Interpolation with Derived Printable
// =============================================================================

@test_derived_interpolation tests @derived_interp () -> void = {
    let p = Point { x: 5, y: 10 };
    let s = `point: {p}`;
    assert_eq(actual: s, expected: "point: Point(5, 10)")
}

@derived_interp () -> str = {
    let p = Point { x: 5, y: 10 };
    `point: {p}`
}

@main () -> void = print(msg: "Printable derive tests")
