// Test user-defined operator implementations
// Spec: 09-expressions.md ยง Operator Traits
//
// TODO: Type checker needs various features
// - `impl` blocks for trait implementations
// - Associated type syntax (`type Output = Point`)
// - Operator trait dispatch (Add, Sub, Neg, Mul)
// - `self` parameter in impl methods
// - Generic impl blocks (`impl Mul<int> for Point`)
//
// Uncomment when type checker supports these features.

// // Define a simple 2D point type
// type Point = { x: int, y: int }
//
// // Implement Add trait for Point
// impl Add for Point {
//     type Output = Point
//     @add (self, rhs: Point) -> Point = Point {
//         x: self.x + rhs.x,
//         y: self.y + rhs.y,
//     }
// }
//
// // Helper function to test addition
// @point_add () -> Point = run(
//     let a = Point { x: 1, y: 2 },
//     let b = Point { x: 3, y: 4 },
//     a + b
// )
//
// // Test that + operator works on Point
// #skip("LLVM backend does not yet support user-defined operator dispatch")
// @test_point_add tests @point_add () -> void = run(
//     let result = point_add(),
//     assert_eq(actual: result.x, expected: 4),
//     assert_eq(actual: result.y, expected: 6),
// )
//
// // Implement Sub trait for Point
// impl Sub for Point {
//     type Output = Point
//     @subtract (self, rhs: Point) -> Point = Point {
//         x: self.x - rhs.x,
//         y: self.y - rhs.y,
//     }
// }
//
// @point_sub () -> Point = run(
//     let a = Point { x: 5, y: 8 },
//     let b = Point { x: 2, y: 3 },
//     a - b
// )
//
// #skip("LLVM backend does not yet support user-defined operator dispatch")
// @test_point_sub tests @point_sub () -> void = run(
//     let result = point_sub(),
//     assert_eq(actual: result.x, expected: 3),
//     assert_eq(actual: result.y, expected: 5),
// )
//
// // Implement Neg trait for Point (unary negation)
// impl Neg for Point {
//     type Output = Point
//     @negate (self) -> Point = Point {
//         x: -self.x,
//         y: -self.y,
//     }
// }
//
// @point_neg () -> Point = run(
//     let p = Point { x: 3, y: -4 },
//     -p
// )
//
// #skip("LLVM backend does not yet support user-defined operator dispatch")
// @test_point_neg tests @point_neg () -> void = run(
//     let result = point_neg(),
//     assert_eq(actual: result.x, expected: -3),
//     assert_eq(actual: result.y, expected: 4),
// )
//
// // Implement Mul with scalar (int)
// impl Mul<int> for Point {
//     type Output = Point
//     @multiply (self, scalar: int) -> Point = Point {
//         x: self.x * scalar,
//         y: self.y * scalar,
//     }
// }
//
// @point_mul_scalar () -> Point = run(
//     let p = Point { x: 2, y: 3 },
//     p * 4
// )
//
// #skip("LLVM backend does not yet support user-defined operator dispatch")
// @test_point_mul_scalar tests @point_mul_scalar () -> void = run(
//     let result = point_mul_scalar(),
//     assert_eq(actual: result.x, expected: 8),
//     assert_eq(actual: result.y, expected: 12),
// )
