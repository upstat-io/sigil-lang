// Spec: 08-declarations.md ยง Associated Types
// Tests for associated type declarations and definitions

use std.testing { assert, assert_eq }

// =============================================================================
// Trait with Associated Type
// =============================================================================

// Iterator trait with associated Item type
trait Container {
    type Item
    @first (self) -> Option<Self.Item>
}

// =============================================================================
// Implementation with Associated Type Definition
// =============================================================================

type IntBox = { value: int }

impl Container for IntBox {
    type Item = int;
    @first (self) -> Option<Self.Item> = Some(self.value);
}

type StrBox = { text: str }

impl Container for StrBox {
    type Item = str;
    @first (self) -> Option<Self.Item> = Some(self.text);
}

// =============================================================================
// Tests
// =============================================================================

@test_int_box_first tests @first () -> void = {
    let box = IntBox { value: 42 };
    let result = box.first();
    assert(cond: result.is_some());
    assert_eq(actual: result.unwrap(), expected: 42)
}

@test_str_box_first tests @first () -> void = {
    let box = StrBox { text: "hello" };
    let result = box.first();
    assert(cond: result.is_some());
    assert_eq(actual: result.unwrap(), expected: "hello")
}

// =============================================================================
// Associated Type Constraints (where T.Item: Trait)
// =============================================================================

// A function that requires the container's Item type to be Eq
@needs_eq_item<C: Container> (c: C) -> bool where C.Item: Eq = true;

@test_needs_eq_item () -> void = {
    // IntBox.Item = int, and int: Eq, so this should work
    let box = IntBox { value: 42 };
    assert(cond: needs_eq_item(c: box))
}

// Type with a non-Eq associated type (lambdas don't implement Eq)
type FnBox = { func: () -> int }

impl Container for FnBox {
    type Item = () -> int;
    @first (self) -> Option<Self.Item> = Some(self.func);
}

// This should fail: FnBox.Item = () -> int, and functions don't implement Eq
#[compile_fail("does not satisfy trait bound `Eq`")]
@test_fnbox_fails_eq_constraint () -> void = {
    let box = FnBox { func: () -> 42 };
    needs_eq_item(c: box)
}

