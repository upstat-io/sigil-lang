// Spec: Section 3.8 — Iterator Traits in Prelude
// Conformance: Iterator, DoubleEndedIterator, Iterable, and Collect traits
// are defined in the prelude and available without explicit imports.
// The repeat() function is also in the prelude.

use std.testing { assert_eq }

// =============================================================================
// Iterator<T> type annotation
// =============================================================================

// repeat() produces a plain Iterator (not DoubleEndedIterator)
@repeat_is_iterator () -> int = run(
    let it: Iterator<int> = repeat(42),
    let (val, _rest) = it.next(),
    match(val,
        Some(n) -> n,
        None -> 0,
    ),
)

@test_repeat_is_iterator tests @repeat_is_iterator () -> void = run(
    assert_eq(actual: repeat_is_iterator(), expected: 42),
)

// =============================================================================
// DoubleEndedIterator<T> type annotation
// =============================================================================

// List.iter() produces a DoubleEndedIterator
@list_is_dei () -> [int] = run(
    let it: DoubleEndedIterator<int> = [3, 1, 2].iter(),
    it.rev().collect(),
)

@test_list_is_dei tests @list_is_dei () -> void = run(
    assert_eq(actual: list_is_dei(), expected: [2, 1, 3]),
)

// Range.iter() produces a DoubleEndedIterator
@range_is_dei () -> [int] = run(
    let it: DoubleEndedIterator<int> = (0..3).iter(),
    it.rev().collect(),
)

@test_range_is_dei tests @range_is_dei () -> void = run(
    assert_eq(actual: range_is_dei(), expected: [2, 1, 0]),
)

// =============================================================================
// Iterator methods work without any trait imports
// =============================================================================

// map/filter/fold chain — all from prelude
@chain_without_imports () -> int = run(
    [1, 2, 3, 4, 5]
        .iter()
        .filter((n) -> n % 2 == 0)
        .map((n) -> n * 10)
        .fold(0, (acc, n) -> acc + n),
)

@test_chain_without_imports tests @chain_without_imports () -> void = run(
    assert_eq(actual: chain_without_imports(), expected: 60),
)

// collect — exercises the Collect trait implicitly
@collect_without_imports () -> [int] = run(
    [1, 2, 3].iter().map((n) -> n + 1).collect(),
)

@test_collect_without_imports tests @collect_without_imports () -> void = run(
    assert_eq(actual: collect_without_imports(), expected: [2, 3, 4]),
)

// =============================================================================
// repeat() is in prelude
// =============================================================================

@repeat_in_prelude () -> [str] = run(
    repeat("hello").take(3).collect(),
)

@test_repeat_in_prelude tests @repeat_in_prelude () -> void = run(
    assert_eq(actual: repeat_in_prelude(), expected: ["hello", "hello", "hello"]),
)

// =============================================================================
// for loop works with Iterable types (desugared to .iter())
// =============================================================================

@for_loop_iterable () -> int = run(
    let mut sum = 0,
    for x in [10, 20, 30] do sum = sum + x,
    sum,
)

@test_for_loop_iterable tests @for_loop_iterable () -> void = run(
    assert_eq(actual: for_loop_iterable(), expected: 60),
)

// for-yield exercises both Iterable and Collect
@for_yield_iterable () -> [int] = run(
    for x in [1, 2, 3] yield x * x,
)

@test_for_yield_iterable tests @for_yield_iterable () -> void = run(
    assert_eq(actual: for_yield_iterable(), expected: [1, 4, 9]),
)
