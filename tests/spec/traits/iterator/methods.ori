// Spec: Section 3.8 â€” Iterator Traits (Phase 2)
// Tests for iterator consumer methods and lazy adapter methods.

use std.testing { assert, assert_eq }

// =============================================================================
// Consumer Methods
// =============================================================================

// fold: accumulate values
@iter_fold () -> int = run(
    [1, 2, 3].iter().fold(initial: 0, op: (acc, x) -> acc + x),
)

@test_iter_fold tests @iter_fold () -> void = run(
    assert_eq(actual: iter_fold(), expected: 6),
)

// count: number of elements
@iter_count () -> int = run(
    [1, 2, 3].iter().count(),
)

@test_iter_count tests @iter_count () -> void = run(
    assert_eq(actual: iter_count(), expected: 3),
)

// find: first matching element
@iter_find () -> int = run(
    let result = [1, 2, 3].iter().find(predicate: x -> x > 1),
    match(result, Some(v) -> v, None -> -1),
)

@test_iter_find tests @iter_find () -> void = run(
    assert_eq(actual: iter_find(), expected: 2),
)

// find: no match returns None
@iter_find_none () -> bool = run(
    let result = [1, 2, 3].iter().find(predicate: x -> x > 10),
    match(result, Some(_) -> false, None -> true),
)

@test_iter_find_none tests @iter_find_none () -> void = run(
    assert(cond: iter_find_none()),
)

// any: true if any element matches
@iter_any_true () -> bool = run(
    [1, 2, 3].iter().any(predicate: x -> x == 2),
)

@test_iter_any_true tests @iter_any_true () -> void = run(
    assert(cond: iter_any_true()),
)

// any: false if no element matches
@iter_any_false () -> bool = run(
    [1, 2, 3].iter().any(predicate: x -> x == 10),
)

@test_iter_any_false tests @iter_any_false () -> void = run(
    assert(cond: !iter_any_false()),
)

// all: true if all match
@iter_all_true () -> bool = run(
    [1, 2, 3].iter().all(predicate: x -> x > 0),
)

@test_iter_all_true tests @iter_all_true () -> void = run(
    assert(cond: iter_all_true()),
)

// all: false if any fails
@iter_all_false () -> bool = run(
    [1, 2, 3].iter().all(predicate: x -> x > 1),
)

@test_iter_all_false tests @iter_all_false () -> void = run(
    assert(cond: !iter_all_false()),
)

// for_each: verify it runs and returns void
@iter_for_each () -> void = run(
    [1, 2, 3].iter().for_each(f: x -> x + 1),
)

@test_iter_for_each tests @iter_for_each () -> void = run(
    iter_for_each(),
)

// collect: gather all elements into a list
@iter_collect () -> [int] = run(
    [1, 2, 3].iter().collect(),
)

@test_iter_collect tests @iter_collect () -> void = run(
    assert_eq(actual: iter_collect(), expected: [1, 2, 3]),
)

// =============================================================================
// Lazy Adapter Methods
// =============================================================================

// map: transform each element
@iter_map () -> [int] = run(
    [1, 2, 3].iter().map(transform: x -> x * 2).collect(),
)

@test_iter_map tests @iter_map () -> void = run(
    assert_eq(actual: iter_map(), expected: [2, 4, 6]),
)

// filter: keep only matching elements
@iter_filter () -> [int] = run(
    [1, 2, 3, 4, 5].iter().filter(predicate: x -> x > 2).collect(),
)

@test_iter_filter tests @iter_filter () -> void = run(
    assert_eq(actual: iter_filter(), expected: [3, 4, 5]),
)

// take: limit to first N elements
@iter_take () -> [int] = run(
    [1, 2, 3, 4, 5].iter().take(count: 3).collect(),
)

@test_iter_take tests @iter_take () -> void = run(
    assert_eq(actual: iter_take(), expected: [1, 2, 3]),
)

// take more than available: yields all
@iter_take_excess () -> [int] = run(
    [1, 2].iter().take(count: 10).collect(),
)

@test_iter_take_excess tests @iter_take_excess () -> void = run(
    assert_eq(actual: iter_take_excess(), expected: [1, 2]),
)

// skip: skip first N elements
@iter_skip () -> [int] = run(
    [1, 2, 3, 4, 5].iter().skip(count: 2).collect(),
)

@test_iter_skip tests @iter_skip () -> void = run(
    assert_eq(actual: iter_skip(), expected: [3, 4, 5]),
)

// skip more than available: yields empty
@iter_skip_excess () -> [int] = run(
    [1, 2].iter().skip(count: 10).collect(),
)

@test_iter_skip_excess tests @iter_skip_excess () -> void = run(
    assert_eq(actual: iter_skip_excess(), expected: []),
)

// =============================================================================
// Chained Adapters
// =============================================================================

// filter + map + collect
@iter_chain_filter_map () -> [int] = run(
    [1, 2, 3, 4, 5].iter()
        .filter(predicate: x -> x > 2)
        .map(transform: x -> x * 10)
        .collect(),
)

@test_iter_chain_filter_map tests @iter_chain_filter_map () -> void = run(
    assert_eq(actual: iter_chain_filter_map(), expected: [30, 40, 50]),
)

// filter + map + fold
@iter_chain_fold () -> int = run(
    [1, 2, 3, 4, 5].iter()
        .filter(predicate: x -> x > 2)
        .map(transform: x -> x * 10)
        .fold(initial: 0, op: (acc, x) -> acc + x),
)

@test_iter_chain_fold tests @iter_chain_fold () -> void = run(
    assert_eq(actual: iter_chain_fold(), expected: 120),
)

// take + skip combined
@iter_skip_take () -> [int] = run(
    [1, 2, 3, 4, 5].iter()
        .skip(count: 1)
        .take(count: 3)
        .collect(),
)

@test_iter_skip_take tests @iter_skip_take () -> void = run(
    assert_eq(actual: iter_skip_take(), expected: [2, 3, 4]),
)

// map + count
@iter_map_count () -> int = run(
    [1, 2, 3].iter()
        .map(transform: x -> x * 2)
        .count(),
)

@test_iter_map_count tests @iter_map_count () -> void = run(
    assert_eq(actual: iter_map_count(), expected: 3),
)

// filter + any
@iter_filter_any () -> bool = run(
    [1, 2, 3, 4, 5].iter()
        .filter(predicate: x -> x > 3)
        .any(predicate: x -> x == 5),
)

@test_iter_filter_any tests @iter_filter_any () -> void = run(
    assert(cond: iter_filter_any()),
)

// =============================================================================
// Empty Iterator Edge Cases
// =============================================================================

// empty list iterator
@iter_empty_count () -> int = run(
    let empty: [int] = [],
    empty.iter().count(),
)

@test_iter_empty_count tests @iter_empty_count () -> void = run(
    assert_eq(actual: iter_empty_count(), expected: 0),
)

@iter_empty_collect () -> [int] = run(
    let empty: [int] = [],
    empty.iter().collect(),
)

@test_iter_empty_collect tests @iter_empty_collect () -> void = run(
    assert_eq(actual: iter_empty_collect(), expected: []),
)

@iter_empty_any () -> bool = run(
    let empty: [int] = [],
    empty.iter().any(predicate: x -> x > 0),
)

@test_iter_empty_any tests @iter_empty_any () -> void = run(
    assert(cond: !iter_empty_any()),
)

@iter_empty_all () -> bool = run(
    let empty: [int] = [],
    empty.iter().all(predicate: x -> x > 0),
)

@test_iter_empty_all tests @iter_empty_all () -> void = run(
    assert(cond: iter_empty_all()),
)

// =============================================================================
// Range Iterator Methods
// =============================================================================

// Range collect via iterator
@range_iter_collect () -> [int] = run(
    (0..5).iter().collect(),
)

@test_range_iter_collect tests @range_iter_collect () -> void = run(
    assert_eq(actual: range_iter_collect(), expected: [0, 1, 2, 3, 4]),
)

// Range map via iterator
@range_iter_map () -> [int] = run(
    (1..=3).iter().map(transform: x -> x * x).collect(),
)

@test_range_iter_map tests @range_iter_map () -> void = run(
    assert_eq(actual: range_iter_map(), expected: [1, 4, 9]),
)

// Range filter via iterator
@range_iter_filter () -> [int] = run(
    (0..10).iter().filter(predicate: x -> x % 2 == 0).collect(),
)

@test_range_iter_filter tests @range_iter_filter () -> void = run(
    assert_eq(actual: range_iter_filter(), expected: [0, 2, 4, 6, 8]),
)

// Range fold via iterator
@range_iter_fold () -> int = run(
    (1..=10).iter().fold(initial: 0, op: (acc, x) -> acc + x),
)

@test_range_iter_fold tests @range_iter_fold () -> void = run(
    assert_eq(actual: range_iter_fold(), expected: 55),
)

// =============================================================================
// String Iterator Methods
// =============================================================================

@str_iter_collect () -> [char] = run(
    "abc".iter().collect(),
)

@test_str_iter_collect tests @str_iter_collect () -> void = run(
    assert_eq(actual: str_iter_collect(), expected: ['a', 'b', 'c']),
)

@str_iter_count () -> int = run(
    "hello".iter().count(),
)

@test_str_iter_count tests @str_iter_count () -> void = run(
    assert_eq(actual: str_iter_count(), expected: 5),
)
