// Spec: Section 3.8 — For Loop Desugaring to Iterable.iter() + next()
// Tests that `for` loops route through the functional iterator infrastructure
// (IteratorValue + eval_iter_next) and support all iterable types.

use std.testing { assert, assert_eq }

// =============================================================================
// List iteration (basic regression)
// =============================================================================

@for_yield_list () -> [int] = for x in [1, 2, 3] yield x * 2

@test_for_yield_list tests @for_yield_list () -> void = run(
    assert_eq(actual: for_yield_list(), expected: [2, 4, 6]),
)

@for_yield_list_empty () -> [int] = for x in [] yield x * 2

@test_for_yield_list_empty tests @for_yield_list_empty () -> void = run(
    assert_eq(actual: for_yield_list_empty(), expected: []),
)

// =============================================================================
// Range iteration (basic regression)
// =============================================================================

@for_yield_range () -> [int] = for x in 0..5 yield x

@test_for_yield_range tests @for_yield_range () -> void = run(
    assert_eq(actual: for_yield_range(), expected: [0, 1, 2, 3, 4]),
)

@for_yield_range_inclusive () -> [int] = for x in 1..=3 yield x

@test_for_yield_range_inclusive tests @for_yield_range_inclusive () -> void = run(
    assert_eq(actual: for_yield_range_inclusive(), expected: [1, 2, 3]),
)

// =============================================================================
// String iteration (basic regression)
// =============================================================================

@for_yield_str () -> [char] = for c in "hi" yield c

@test_for_yield_str tests @for_yield_str () -> void = run(
    assert_eq(actual: for_yield_str(), expected: ['h', 'i']),
)

// =============================================================================
// Set iteration (NEW — previously unsupported)
// =============================================================================

@for_set_count () -> int = run(
    let s: Set<int> = [10, 20, 30].iter().collect(),
    let count = 0,
    for x in s do count = count + 1,
    count,
)

@test_for_set_count tests @for_set_count () -> void = run(
    assert_eq(actual: for_set_count(), expected: 3),
)

// =============================================================================
// Option iteration (NEW — previously unsupported)
// =============================================================================

@for_option_some () -> int = run(
    let opt = Some(42),
    let result = 0,
    for x in opt do result = x,
    result,
)

@test_for_option_some tests @for_option_some () -> void = run(
    assert_eq(actual: for_option_some(), expected: 42),
)

@for_option_none () -> int = run(
    let opt: Option<int> = None,
    let result = 0,
    for x in opt do result = x,
    result,
)

@test_for_option_none tests @for_option_none () -> void = run(
    assert_eq(actual: for_option_none(), expected: 0),
)

@for_option_yield_some () -> [int] = run(
    let opt = Some(99),
    for x in opt yield x,
)

@test_for_option_yield_some tests @for_option_yield_some () -> void = run(
    assert_eq(actual: for_option_yield_some(), expected: [99]),
)

@for_option_yield_none () -> [int] = run(
    let opt: Option<int> = None,
    for x in opt yield x,
)

@test_for_option_yield_none tests @for_option_yield_none () -> void = run(
    assert_eq(actual: for_option_yield_none(), expected: []),
)

// =============================================================================
// Iterator pass-through (iterating over .iter() result)
// =============================================================================

@for_iter_passthrough () -> [int] = for x in [1, 2, 3].iter() yield x * 10

@test_for_iter_passthrough tests @for_iter_passthrough () -> void = run(
    assert_eq(actual: for_iter_passthrough(), expected: [10, 20, 30]),
)

// =============================================================================
// Guard clause (for...if...yield)
// =============================================================================

@for_guard_yield () -> [int] = for x in [1, 2, 3, 4, 5] if x > 3 yield x

@test_for_guard_yield tests @for_guard_yield () -> void = run(
    assert_eq(actual: for_guard_yield(), expected: [4, 5]),
)

@for_guard_yield_none () -> [int] = for x in [1, 2, 3] if x > 10 yield x

@test_for_guard_yield_none tests @for_guard_yield_none () -> void = run(
    assert_eq(actual: for_guard_yield_none(), expected: []),
)

@for_guard_yield_all () -> [int] = for x in [1, 2, 3] if x > 0 yield x

@test_for_guard_yield_all tests @for_guard_yield_all () -> void = run(
    assert_eq(actual: for_guard_yield_all(), expected: [1, 2, 3]),
)

// =============================================================================
// yield with transformation
// =============================================================================

@for_yield_transform () -> [int] = for x in [1, 2, 3, 4, 5] yield x * x

@test_for_yield_transform tests @for_yield_transform () -> void = run(
    assert_eq(actual: for_yield_transform(), expected: [1, 4, 9, 16, 25]),
)

// =============================================================================
// for...do loop (side effects)
// =============================================================================

@for_do_sum () -> int = run(
    let sum = 0,
    for x in [1, 2, 3, 4, 5] do sum = sum + x,
    sum,
)

@test_for_do_sum tests @for_do_sum () -> void = run(
    assert_eq(actual: for_do_sum(), expected: 15),
)

@for_do_empty () -> int = run(
    let sum = 0,
    for x in [] do sum = sum + x,
    sum,
)

@test_for_do_empty tests @for_do_empty () -> void = run(
    assert_eq(actual: for_do_empty(), expected: 0),
)

// =============================================================================
// break in for loops
// =============================================================================

@for_break_do () -> int = run(
    let sum = 0,
    for x in [1, 2, 3, 4, 5] do run(
        if x > 3 then break,
        sum = sum + x,
    ),
    sum,
)

@test_for_break_do tests @for_break_do () -> void = run(
    assert_eq(actual: for_break_do(), expected: 6),
)

@for_break_yield () -> [int] = for x in [1, 2, 3, 4, 5] yield run(
    if x == 3 then break,
    x,
)

@test_for_break_yield tests @for_break_yield () -> void = run(
    assert_eq(actual: for_break_yield(), expected: [1, 2]),
)
