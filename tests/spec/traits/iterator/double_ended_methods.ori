// Spec: Section 3.8 — DoubleEndedIterator Default Methods
// Tests for rev(), last(), rfind(), rfold() on double-ended iterators.

use std.testing { assert, assert_eq }

// =============================================================================
// rev() — reverse iteration adapter
// =============================================================================

@rev_list () -> [int] = {
    [1, 2, 3, 4, 5].iter().rev().collect()
}

@test_rev_list tests @rev_list () -> void = {
    assert_eq(actual: rev_list(), expected: [5, 4, 3, 2, 1])
}

@rev_range () -> [int] = {
    (0..5).iter().rev().collect()
}

@test_rev_range tests @rev_range () -> void = {
    assert_eq(actual: rev_range(), expected: [4, 3, 2, 1, 0])
}

@rev_string () -> [char] = {
    "hello".iter().rev().collect()
}

@test_rev_string tests @rev_string () -> void = {
    assert_eq(actual: rev_string(), expected: ['o', 'l', 'l', 'e', 'h'])
}

@rev_empty () -> [int] = {
    [].iter().rev().collect()
}

@test_rev_empty tests @rev_empty () -> void = {
    assert_eq(actual: rev_empty(), expected: [])
}

// rev().rev() should yield original order
@rev_rev () -> [int] = {
    [1, 2, 3].iter().rev().rev().collect()
}

@test_rev_rev tests @rev_rev () -> void = {
    assert_eq(actual: rev_rev(), expected: [1, 2, 3])
}

// rev() with map adapter
@rev_mapped () -> [int] = {
    [1, 2, 3].iter().map(x -> x * 10).rev().collect()
}

@test_rev_mapped tests @rev_mapped () -> void = {
    assert_eq(actual: rev_mapped(), expected: [30, 20, 10])
}

// rev() with filter adapter
@rev_filtered () -> [int] = {
    [1, 2, 3, 4, 5, 6].iter().filter(x -> x % 2 == 0).rev().collect()
}

@test_rev_filtered tests @rev_filtered () -> void = {
    assert_eq(actual: rev_filtered(), expected: [6, 4, 2])
}

// =============================================================================
// last() — efficient last element retrieval
// =============================================================================

@last_list () -> Option<int> = {
    [10, 20, 30].iter().last()
}

@test_last_list tests @last_list () -> void = {
    assert_eq(actual: last_list(), expected: Some(30))
}

@last_range () -> Option<int> = {
    (0..100).iter().last()
}

@test_last_range tests @last_range () -> void = {
    assert_eq(actual: last_range(), expected: Some(99))
}

@last_empty () -> Option<int> = {
    [].iter().last()
}

@test_last_empty tests @last_empty () -> void = {
    assert_eq(actual: last_empty(), expected: None)
}

@last_single () -> Option<int> = {
    [42].iter().last()
}

@test_last_single tests @last_single () -> void = {
    assert_eq(actual: last_single(), expected: Some(42))
}

@last_string () -> Option<char> = {
    "hello".iter().last()
}

@test_last_string tests @last_string () -> void = {
    assert_eq(actual: last_string(), expected: Some('o'))
}

// =============================================================================
// rfind() — find from the back
// =============================================================================

@rfind_basic () -> Option<int> = {
    [1, 2, 3, 4, 5].iter().rfind(x -> x % 2 == 0)
}

@test_rfind_basic tests @rfind_basic () -> void = {
    // Last even number is 4
    assert_eq(actual: rfind_basic(), expected: Some(4))
}

@rfind_no_match () -> Option<int> = {
    [1, 3, 5, 7].iter().rfind(x -> x % 2 == 0)
}

@test_rfind_no_match tests @rfind_no_match () -> void = {
    assert_eq(actual: rfind_no_match(), expected: None)
}

@rfind_first_from_back () -> Option<int> = {
    [10, 20, 30, 40, 50].iter().rfind(x -> x > 25)
}

@test_rfind_first_from_back tests @rfind_first_from_back () -> void = {
    // 50 is found first (searching from back), then 40, then 30 — returns 50
    assert_eq(actual: rfind_first_from_back(), expected: Some(50))
}

@rfind_empty () -> Option<int> = {
    [].iter().rfind(x -> x > 0)
}

@test_rfind_empty tests @rfind_empty () -> void = {
    assert_eq(actual: rfind_empty(), expected: None)
}

// =============================================================================
// rfold() — fold from the back
// =============================================================================

@rfold_basic () -> int = {
    [1, 2, 3].iter().rfold(0, (acc, x) -> acc + x)
}

@test_rfold_basic tests @rfold_basic () -> void = {
    // 0 + 3 + 2 + 1 = 6 (same as fold for addition)
    assert_eq(actual: rfold_basic(), expected: 6)
}

// Subtraction reveals the order: rfold processes 3, then 2, then 1
@rfold_subtraction () -> int = {
    [1, 2, 3].iter().rfold(10, (acc, x) -> acc - x)
}

@test_rfold_subtraction tests @rfold_subtraction () -> void = {
    // 10 - 3 = 7, 7 - 2 = 5, 5 - 1 = 4
    assert_eq(actual: rfold_subtraction(), expected: 4)
}

// Build a string to verify order
@rfold_string () -> str = {
    [1, 2, 3].iter().rfold("", (acc, x) -> acc + x.to_str())
}

@test_rfold_string tests @rfold_string () -> void = {
    // Processes 3 first, then 2, then 1: "" + "3" + "2" + "1" = "321"
    assert_eq(actual: rfold_string(), expected: "321")
}

@rfold_empty () -> int = {
    [].iter().rfold(42, (acc, x) -> acc + x)
}

@test_rfold_empty tests @rfold_empty () -> void = {
    // No items — returns initial value
    assert_eq(actual: rfold_empty(), expected: 42)
}

// rfold on range — build string to verify backward order
@rfold_range () -> str = {
    (1..4).iter().rfold("", (acc, x) -> acc + x.to_str())
}

@test_rfold_range tests @rfold_range () -> void = {
    // Processes 3, 2, 1: "" + "3" + "2" + "1" = "321"
    assert_eq(actual: rfold_range(), expected: "321")
}
