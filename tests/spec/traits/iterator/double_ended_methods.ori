// Spec: Section 3.8 — DoubleEndedIterator Default Methods
// Tests for rev(), last(), rfind(), rfold() on double-ended iterators.

use std.testing { assert, assert_eq }

// =============================================================================
// rev() — reverse iteration adapter
// =============================================================================

@rev_list () -> [int] = run(
    [1, 2, 3, 4, 5].iter().rev().collect(),
)

@test_rev_list tests @rev_list () -> void = run(
    assert_eq(actual: rev_list(), expected: [5, 4, 3, 2, 1]),
)

@rev_range () -> [int] = run(
    (0..5).iter().rev().collect(),
)

@test_rev_range tests @rev_range () -> void = run(
    assert_eq(actual: rev_range(), expected: [4, 3, 2, 1, 0]),
)

@rev_string () -> [char] = run(
    "hello".iter().rev().collect(),
)

@test_rev_string tests @rev_string () -> void = run(
    assert_eq(actual: rev_string(), expected: ['o', 'l', 'l', 'e', 'h']),
)

@rev_empty () -> [int] = run(
    [].iter().rev().collect(),
)

@test_rev_empty tests @rev_empty () -> void = run(
    assert_eq(actual: rev_empty(), expected: []),
)

// rev().rev() should yield original order
@rev_rev () -> [int] = run(
    [1, 2, 3].iter().rev().rev().collect(),
)

@test_rev_rev tests @rev_rev () -> void = run(
    assert_eq(actual: rev_rev(), expected: [1, 2, 3]),
)

// rev() with map adapter
@rev_mapped () -> [int] = run(
    [1, 2, 3].iter().map(x -> x * 10).rev().collect(),
)

@test_rev_mapped tests @rev_mapped () -> void = run(
    assert_eq(actual: rev_mapped(), expected: [30, 20, 10]),
)

// rev() with filter adapter
@rev_filtered () -> [int] = run(
    [1, 2, 3, 4, 5, 6].iter().filter(x -> x % 2 == 0).rev().collect(),
)

@test_rev_filtered tests @rev_filtered () -> void = run(
    assert_eq(actual: rev_filtered(), expected: [6, 4, 2]),
)

// =============================================================================
// last() — efficient last element retrieval
// =============================================================================

@last_list () -> Option<int> = run(
    [10, 20, 30].iter().last(),
)

@test_last_list tests @last_list () -> void = run(
    assert_eq(actual: last_list(), expected: Some(30)),
)

@last_range () -> Option<int> = run(
    (0..100).iter().last(),
)

@test_last_range tests @last_range () -> void = run(
    assert_eq(actual: last_range(), expected: Some(99)),
)

@last_empty () -> Option<int> = run(
    [].iter().last(),
)

@test_last_empty tests @last_empty () -> void = run(
    assert_eq(actual: last_empty(), expected: None),
)

@last_single () -> Option<int> = run(
    [42].iter().last(),
)

@test_last_single tests @last_single () -> void = run(
    assert_eq(actual: last_single(), expected: Some(42)),
)

@last_string () -> Option<char> = run(
    "hello".iter().last(),
)

@test_last_string tests @last_string () -> void = run(
    assert_eq(actual: last_string(), expected: Some('o')),
)

// =============================================================================
// rfind() — find from the back
// =============================================================================

@rfind_basic () -> Option<int> = run(
    [1, 2, 3, 4, 5].iter().rfind(x -> x % 2 == 0),
)

@test_rfind_basic tests @rfind_basic () -> void = run(
    // Last even number is 4
    assert_eq(actual: rfind_basic(), expected: Some(4)),
)

@rfind_no_match () -> Option<int> = run(
    [1, 3, 5, 7].iter().rfind(x -> x % 2 == 0),
)

@test_rfind_no_match tests @rfind_no_match () -> void = run(
    assert_eq(actual: rfind_no_match(), expected: None),
)

@rfind_first_from_back () -> Option<int> = run(
    [10, 20, 30, 40, 50].iter().rfind(x -> x > 25),
)

@test_rfind_first_from_back tests @rfind_first_from_back () -> void = run(
    // 50 is found first (searching from back), then 40, then 30 — returns 50
    assert_eq(actual: rfind_first_from_back(), expected: Some(50)),
)

@rfind_empty () -> Option<int> = run(
    [].iter().rfind(x -> x > 0),
)

@test_rfind_empty tests @rfind_empty () -> void = run(
    assert_eq(actual: rfind_empty(), expected: None),
)

// =============================================================================
// rfold() — fold from the back
// =============================================================================

@rfold_basic () -> int = run(
    [1, 2, 3].iter().rfold(0, (acc, x) -> acc + x),
)

@test_rfold_basic tests @rfold_basic () -> void = run(
    // 0 + 3 + 2 + 1 = 6 (same as fold for addition)
    assert_eq(actual: rfold_basic(), expected: 6),
)

// Subtraction reveals the order: rfold processes 3, then 2, then 1
@rfold_subtraction () -> int = run(
    [1, 2, 3].iter().rfold(10, (acc, x) -> acc - x),
)

@test_rfold_subtraction tests @rfold_subtraction () -> void = run(
    // 10 - 3 = 7, 7 - 2 = 5, 5 - 1 = 4
    assert_eq(actual: rfold_subtraction(), expected: 4),
)

// Build a string to verify order
@rfold_string () -> str = run(
    [1, 2, 3].iter().rfold("", (acc, x) -> acc + x.to_str()),
)

@test_rfold_string tests @rfold_string () -> void = run(
    // Processes 3 first, then 2, then 1: "" + "3" + "2" + "1" = "321"
    assert_eq(actual: rfold_string(), expected: "321"),
)

@rfold_empty () -> int = run(
    [].iter().rfold(42, (acc, x) -> acc + x),
)

@test_rfold_empty tests @rfold_empty () -> void = run(
    // No items — returns initial value
    assert_eq(actual: rfold_empty(), expected: 42),
)

// rfold on range — build string to verify backward order
@rfold_range () -> str = run(
    (1..4).iter().rfold("", (acc, x) -> acc + x.to_str()),
)

@test_rfold_range tests @rfold_range () -> void = run(
    // Processes 3, 2, 1: "" + "3" + "2" + "1" = "321"
    assert_eq(actual: rfold_range(), expected: "321"),
)
