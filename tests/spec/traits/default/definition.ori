// Spec: 07-properties-of-types.md ยง Default Trait
// Tests for Default trait definition and standard implementations

use std.testing { assert_eq, assert }

// =============================================================================
// Primitive Type Defaults (via struct field derivation)
// =============================================================================
// The Default trait provides zero/empty values for all primitive types.
// Tested via #[derive(Default)] structs since primitives participate through
// the derivation mechanism.

// int default = 0
#[derive(Default, Eq)]
type IntBox = { value: int }

@test_int_default tests @int_default () -> void = {
    let b = IntBox.default();
    assert_eq(actual: b.value, expected: 0)
}

@int_default () -> int = IntBox.default().value

// float default = 0.0
#[derive(Default, Eq)]
type FloatBox = { value: float }

@test_float_default tests @float_default () -> void = {
    let b = FloatBox.default();
    assert_eq(actual: b.value, expected: 0.0)
}

@float_default () -> float = FloatBox.default().value

// bool default = false
#[derive(Default, Eq)]
type BoolBox = { value: bool }

@test_bool_default tests @bool_default () -> void = {
    let b = BoolBox.default();
    assert_eq(actual: b.value, expected: false)
}

@bool_default () -> bool = BoolBox.default().value

// str default = ""
#[derive(Default, Eq)]
type StrBox = { value: str }

@test_str_default tests @str_default () -> void = {
    let b = StrBox.default();
    assert_eq(actual: b.value, expected: "")
}

@str_default () -> str = StrBox.default().value

// =============================================================================
// Multiple Primitive Types in One Struct
// =============================================================================

#[derive(Default, Eq)]
type AllPrimitives = {
    i: int,
    f: float,
    b: bool,
    s: str,
}

@test_all_primitives_default tests @all_primitives_default () -> void = {
    let a = AllPrimitives.default();
    assert_eq(actual: a.i, expected: 0);
    assert_eq(actual: a.f, expected: 0.0);
    assert_eq(actual: a.b, expected: false);
    assert_eq(actual: a.s, expected: "")
}

@all_primitives_default () -> bool = {
    let a = AllPrimitives.default();
    a.i == 0 && a.f == 0.0 && a.b == false && a.s == ""
}

// =============================================================================
// Duration and Size Defaults (built-in associated functions)
// =============================================================================

@test_duration_default tests @duration_default () -> void = {
    let d = Duration.default();
    assert_eq(actual: d, expected: 0ns)
}

@duration_default () -> Duration = Duration.default()

@test_size_default tests @size_default () -> void = {
    let s = Size.default();
    assert_eq(actual: s, expected: 0b)
}

@size_default () -> Size = Size.default()

// =============================================================================
// Default Produces Equal Values (idempotency)
// =============================================================================

@test_default_idempotent tests @default_idempotent () -> void = {
    let p1 = IntBox.default();
    let p2 = IntBox.default();
    assert(cond: p1.eq(other: p2))
}

@default_idempotent () -> bool = IntBox.default().eq(other: IntBox.default())

// =============================================================================
// Nested Struct Defaults
// =============================================================================

#[derive(Default, Eq)]
type Inner = { x: int, y: int }

#[derive(Default, Eq)]
type Outer = { inner: Inner, label: str }

@test_nested_struct_default tests @nested_struct_default () -> void = {
    let o = Outer.default();
    assert_eq(actual: o.inner.x, expected: 0);
    assert_eq(actual: o.inner.y, expected: 0);
    assert_eq(actual: o.label, expected: "")
}

@nested_struct_default () -> bool = {
    let o = Outer.default();
    o.inner.x == 0 && o.inner.y == 0 && o.label == ""
}

// =============================================================================
// Deeply Nested Defaults
// =============================================================================

#[derive(Default, Eq)]
type Level1 = { value: int }

#[derive(Default, Eq)]
type Level2 = { child: Level1 }

#[derive(Default, Eq)]
type Level3 = { child: Level2 }

@test_deep_nesting_default tests @deep_nesting_default () -> void = {
    let l = Level3.default();
    assert_eq(actual: l.child.child.value, expected: 0)
}

@deep_nesting_default () -> int = Level3.default().child.child.value

@main () -> void = print(msg: "Default definition tests")
