// Spec: Debug trait proposal — developer-facing structural representation
// Formal semantics: TypeName { field: debug_val, ... } for structs; VariantName(debug_vals) for variants
//
// §3.15: Derived Traits Formal Semantics

use std.testing { assert_eq }

// --- Types ---

#[derive(Debug)]
type Point = { x: int, y: int }

#[derive(Debug)]
type WithStr = { name: str, value: int }

#[derive(Debug)]
type Color = Red | Green | Blue

#[derive(Debug)]
type Shape = Circle(radius: int) | Rectangle(w: int, h: int)

// --- Struct debug ---

@test_struct_debug tests @struct_debug () -> void = run(
    assert_eq(actual: Point { x: 10, y: 20 }.debug(), expected: "Point { x: 10, y: 20 }"),
)
@struct_debug () -> str = Point { x: 10, y: 20 }.debug()

@test_struct_str_escaped tests @str_escaped () -> void = run(
    // Debug wraps strings in quotes
    assert_eq(actual: WithStr { name: "Alice", value: 42 }.debug(), expected: "WithStr { name: \"Alice\", value: 42 }"),
)
@str_escaped () -> str = WithStr { name: "Alice", value: 42 }.debug()

// --- Payloadless variant debug ---

@test_variant_payloadless tests @pl_variant () -> void = run(
    assert_eq(actual: Red.debug(), expected: "Red"),
    assert_eq(actual: Green.debug(), expected: "Green"),
    assert_eq(actual: Blue.debug(), expected: "Blue"),
)
@pl_variant () -> str = Red.debug()

// --- Variant with payload ---

@test_variant_payload tests @payload_variant () -> void = run(
    assert_eq(actual: Circle(radius: 5).debug(), expected: "Circle(5)"),
)
@payload_variant () -> str = Circle(radius: 5).debug()

@test_variant_multi tests @multi_variant () -> void = run(
    assert_eq(actual: Rectangle(w: 3, h: 4).debug(), expected: "Rectangle(3, 4)"),
)
@multi_variant () -> str = Rectangle(w: 3, h: 4).debug()
