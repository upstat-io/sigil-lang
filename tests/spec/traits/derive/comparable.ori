// Spec: 07-properties-of-types.md ยง Comparable + Derive
// Tests for #[derive(Comparable)] on structs (ยง3.14)

use std.testing { assert }

// =============================================================================
// Basic derive(Comparable)
// =============================================================================

#[derive(Eq, Comparable)]
type Point = { x: int, y: int }

@test_point_compare_less tests @point_cmp_less () -> void = {
    let p1 = Point { x: 1, y: 2 };
    let p2 = Point { x: 1, y: 3 };
    assert(cond: p1.compare(other: p2).is_less())
}

@point_cmp_less () -> Ordering = {
    let p1 = Point { x: 1, y: 2 };
    let p2 = Point { x: 1, y: 3 };
    p1.compare(other: p2)
}

@test_point_compare_equal tests @point_cmp_equal () -> void = {
    let p1 = Point { x: 5, y: 10 };
    let p2 = Point { x: 5, y: 10 };
    assert(cond: p1.compare(other: p2).is_equal())
}

@point_cmp_equal () -> Ordering = {
    let p = Point { x: 5, y: 10 };
    p.compare(other: p)
}

@test_point_compare_greater tests @point_cmp_greater () -> void = {
    let p1 = Point { x: 2, y: 0 };
    let p2 = Point { x: 1, y: 99 };
    assert(cond: p1.compare(other: p2).is_greater())
}

@point_cmp_greater () -> Ordering = {
    let p1 = Point { x: 2, y: 0 };
    let p2 = Point { x: 1, y: 99 };
    p1.compare(other: p2)
}

// =============================================================================
// Lexicographic ordering: first field has priority
// =============================================================================

@test_first_field_determines tests @first_field () -> void = {
    let p1 = Point { x: 10, y: 0 };
    let p2 = Point { x: 5, y: 100 };
    // x: 10 > 5, so p1 > p2 regardless of y
    assert(cond: p1.compare(other: p2).is_greater())
}

@first_field () -> Ordering = {
    let p1 = Point { x: 10, y: 0 };
    let p2 = Point { x: 5, y: 100 };
    p1.compare(other: p2)
}

// =============================================================================
// Second field breaks ties
// =============================================================================

@test_second_field_tiebreak tests @second_field () -> void = {
    let p1 = Point { x: 5, y: 3 };
    let p2 = Point { x: 5, y: 7 };
    // x equal, y: 3 < 7
    assert(cond: p1.compare(other: p2).is_less())
}

@second_field () -> Ordering = {
    let p1 = Point { x: 5, y: 3 };
    let p2 = Point { x: 5, y: 7 };
    p1.compare(other: p2)
}

// =============================================================================
// Single-field struct
// =============================================================================

#[derive(Eq, Comparable)]
type Wrapper = { value: int }

@test_wrapper_compare tests @wrapper_cmp () -> void = {
    let w1 = Wrapper { value: 10 };
    let w2 = Wrapper { value: 20 };
    assert(cond: w1.compare(other: w2).is_less());
    assert(cond: w2.compare(other: w1).is_greater());
    assert(cond: w1.compare(other: w1).is_equal())
}

@wrapper_cmp () -> Ordering = {
    let w1 = Wrapper { value: 10 };
    let w2 = Wrapper { value: 20 };
    w1.compare(other: w2)
}
