// Spec: 06-types.md ยง Compound Types - Function
// Tests for () -> T, (A) -> B, (A, B) -> C function types

use std.testing { assert, assert_eq }

// =============================================================================
// Nullary Function Type () -> T
// =============================================================================

@test_nullary_fn tests @nullary_fn () -> void = run(
    let f: () -> int = () -> 42,
    let result = f(),
    assert_eq(actual: result, expected: 42),
)

@nullary_fn () -> int = run(
    let f: () -> int = () -> 42,
    f(),
)

@test_nullary_fn_str tests @nullary_fn_str () -> void = run(
    let f: () -> str = () -> "hello",
    assert_eq(actual: f(), expected: "hello"),
)

@nullary_fn_str () -> str = run(
    let f: () -> str = () -> "hello",
    f(),
)

@test_nullary_fn_void tests @nullary_fn_void () -> void = run(
    let f: () -> void = () -> (),
    f(),
    assert(cond: true),
)

@nullary_fn_void () -> void = run(
    let f: () -> void = () -> (),
    f(),
)

// =============================================================================
// Unary Function Type (A) -> B
// =============================================================================

@test_unary_fn tests @unary_fn () -> void = run(
    let f: (int) -> int = x -> x * 2,
    assert_eq(actual: f(5), expected: 10),
)

@unary_fn () -> int = run(
    let f: (int) -> int = x -> x * 2,
    f(5),
)

@test_unary_fn_diff_types tests @unary_fn_diff_types () -> void = run(
    let f: (int) -> str = n -> str(n),
    assert_eq(actual: f(42), expected: "42"),
)

@unary_fn_diff_types () -> str = run(
    let f: (int) -> str = n -> str(n),
    f(42),
)

@test_unary_fn_str_int tests @unary_fn_str_int () -> void = run(
    let f: (str) -> int = s -> s.len(),
    assert_eq(actual: f("hello"), expected: 5),
)

@unary_fn_str_int () -> int = run(
    let f: (str) -> int = s -> s.len(),
    f("hello"),
)

// =============================================================================
// Binary Function Type (A, B) -> C
// =============================================================================

@test_binary_fn tests @binary_fn () -> void = run(
    let f: (int, int) -> int = (a, b) -> a + b,
    assert_eq(actual: f(10, 20), expected: 30),
)

@binary_fn () -> int = run(
    let f: (int, int) -> int = (a, b) -> a + b,
    f(10, 20),
)

@test_binary_fn_diff_types tests @binary_fn_diff_types () -> void = run(
    let f: (str, int) -> str = (s, n) -> s + str(n),
    assert_eq(actual: f("value: ", 42), expected: "value: 42"),
)

@binary_fn_diff_types () -> str = run(
    let f: (str, int) -> str = (s, n) -> s + str(n),
    f("value: ", 42),
)

// =============================================================================
// Ternary Function Type (A, B, C) -> D
// =============================================================================

@test_ternary_fn tests @ternary_fn () -> void = run(
    let f: (int, int, int) -> int = (a, b, c) -> a + b + c,
    assert_eq(actual: f(1, 2, 3), expected: 6),
)

@ternary_fn () -> int = run(
    let f: (int, int, int) -> int = (a, b, c) -> a + b + c,
    f(1, 2, 3),
)

// =============================================================================
// Function Type with Typed Parameters
// =============================================================================

@test_typed_lambda tests @typed_lambda () -> void = run(
    let f: (int) -> int = (x: int) -> int = x * 2,
    assert_eq(actual: f(5), expected: 10),
)

@typed_lambda () -> int = run(
    let f = (x: int) -> int = x * 2,
    f(5),
)

// =============================================================================
// Higher-Order Functions
// =============================================================================

@test_fn_as_param tests @fn_as_param () -> void = run(
    let result = apply(f: x -> x * 2, value: 5),
    assert_eq(actual: result, expected: 10),
)

@apply (f: (int) -> int, value: int) -> int = f(value)

@fn_as_param () -> int = apply(f: x -> x * 2, value: 5)

@test_fn_returning_fn tests @fn_returning_fn () -> void = run(
    let adder = make_adder(n: 10),
    assert_eq(actual: adder(5), expected: 15),
)

@make_adder (n: int) -> (int) -> int = x -> x + n

@fn_returning_fn () -> (int) -> int = make_adder(n: 10)

// =============================================================================
// Function Composition
// =============================================================================

@test_compose tests @compose () -> void = run(
    let double: (int) -> int = x -> x * 2,
    let add_one: (int) -> int = x -> x + 1,
    let composed = compose(f: add_one, g: double),
    assert_eq(actual: composed(5), expected: 11),
)

@compose (f: (int) -> int, g: (int) -> int) -> (int) -> int = x -> f(g(x))

@compose_fns () -> (int) -> int = run(
    let double: (int) -> int = x -> x * 2,
    let add_one: (int) -> int = x -> x + 1,
    compose(f: add_one, g: double),
)

// =============================================================================
// Function Types with Collections
// =============================================================================

@test_fn_list_param tests @fn_list_param () -> void = run(
    let f: ([int]) -> int = items -> items.len(),
    assert_eq(actual: f([1, 2, 3]), expected: 3),
)

@fn_list_param () -> int = run(
    let f: ([int]) -> int = items -> items.len(),
    f([1, 2, 3]),
)

@test_fn_returns_list tests @fn_returns_list () -> void = run(
    let f: (int) -> [int] = n -> [n, n * 2, n * 3],
    let result = f(5),
    assert_eq(actual: result, expected: [5, 10, 15]),
)

@fn_returns_list () -> [int] = run(
    let f: (int) -> [int] = n -> [n, n * 2, n * 3],
    f(5),
)

// =============================================================================
// Function Types with Option/Result
// =============================================================================

@test_fn_returns_option tests @fn_returns_option () -> void = run(
    let f: (int) -> Option<int> = n -> if n > 0 then Some(n) else None,
    assert(cond: is_some(opt: f(5))),
    assert(cond: is_none(opt: f(-1))),
)

@fn_returns_option () -> Option<int> = run(
    let f: (int) -> Option<int> = n -> if n > 0 then Some(n) else None,
    f(5),
)

@test_fn_returns_result tests @fn_returns_result () -> void = run(
    let f: (int) -> Result<int, str> = n -> if n >= 0 then Ok(n) else Err("negative"),
    assert(cond: is_ok(result: f(5))),
    assert(cond: is_err(result: f(-1))),
)

@fn_returns_result () -> Result<int, str> = run(
    let f: (int) -> Result<int, str> = n -> if n >= 0 then Ok(n) else Err("negative"),
    f(5),
)

// =============================================================================
// Function Types with Tuples
// =============================================================================

@test_fn_tuple_param tests @fn_tuple_param () -> void = run(
    let f: ((int, int)) -> int = t -> run(
        let (a, b) = t,
        a + b,
    ),
    assert_eq(actual: f((10, 20)), expected: 30),
)

@fn_tuple_param () -> int = run(
    let f: ((int, int)) -> int = t -> run(
        let (a, b) = t,
        a + b,
    ),
    f((10, 20)),
)

@test_fn_returns_tuple tests @fn_returns_tuple () -> void = run(
    let f: (int) -> (int, int) = n -> (n, n * 2),
    let (a, b) = f(5),
    assert_eq(actual: a, expected: 5),
    assert_eq(actual: b, expected: 10),
)

@fn_returns_tuple () -> (int, int) = run(
    let f: (int) -> (int, int) = n -> (n, n * 2),
    f(5),
)

// =============================================================================
// Nested Function Types
// =============================================================================

@test_nested_fn_type tests @nested_fn_type () -> void = run(
    let f: ((int) -> int) -> (int) -> int = g -> x -> g(g(x)),
    let double: (int) -> int = x -> x * 2,
    let quadruple = f(double),
    assert_eq(actual: quadruple(5), expected: 20),
)

@nested_fn_type () -> int = run(
    let f: ((int) -> int) -> (int) -> int = g -> x -> g(g(x)),
    let double: (int) -> int = x -> x * 2,
    let quadruple = f(double),
    quadruple(5),
)

// =============================================================================
// Function Types in Structs
// =============================================================================
//
// STATUS: Lexer [OK], Parser [OK], Evaluator [BROKEN] - no method 'callback' on struct
// Evaluator does not support calling function fields with method syntax (h.callback(x)).

type Handler = { callback: (int) -> str }

@test_fn_in_struct tests @fn_in_struct () -> void = run(
    let h = Handler { callback: n -> "value: " + str(n) },
    let result = h.callback(42),
    assert_eq(actual: result, expected: "value: 42"),
)

@fn_in_struct () -> str = run(
    let h = Handler { callback: n -> "value: " + str(n) },
    h.callback(42),
)

// =============================================================================
// Function Type Inference
// =============================================================================

@test_inferred_fn tests @inferred_fn () -> void = run(
    // Type inferred from usage
    let f = x -> x + 1,
    assert_eq(actual: f(5), expected: 6),
)

@inferred_fn () -> int = run(
    let f = x -> x + 1,
    f(5),
)

@test_inferred_multi_param tests @inferred_multi_param () -> void = run(
    let f = (a, b) -> a + b,
    assert_eq(actual: f(10, 20), expected: 30),
)

@inferred_multi_param () -> int = run(
    let f = (a, b) -> a + b,
    f(10, 20),
)

// =============================================================================
// Closures (Capturing Variables)
// =============================================================================

@test_closure tests @closure () -> void = run(
    let captured = 100,
    let f: (int) -> int = x -> x + captured,
    assert_eq(actual: f(5), expected: 105),
)

@closure () -> int = run(
    let captured = 100,
    let f: (int) -> int = x -> x + captured,
    f(5),
)

@test_multi_capture tests @multi_capture () -> void = run(
    let a = 10,
    let b = 20,
    let f: () -> int = () -> a + b,
    assert_eq(actual: f(), expected: 30),
)

@multi_capture () -> int = run(
    let a = 10,
    let b = 20,
    let f: () -> int = () -> a + b,
    f(),
)
