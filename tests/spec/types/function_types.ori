// Spec: 06-types.md ยง Compound Types - Function
// Tests for () -> T, (A) -> B, (A, B) -> C function types
//
// TODO: Type checker needs various features
// - Function type annotations: `let f: (int) -> int = ...`
// - Lambda type inference
// - Higher-order function type checking
// - Function composition patterns
// - Closures (capturing variables)
// - Function types in struct fields
// - Generic function types
//
// Uncomment when type checker supports these features.

// use std.testing { assert, assert_eq }
//
// // =============================================================================
// // Nullary Function Type () -> T
// // =============================================================================
//
// @test_nullary_fn tests @nullary_fn () -> void = {
//     let f: () -> int = () -> 42,
//     let result = f(),
//     assert_eq(actual: result, expected: 42),
// }
//
// @nullary_fn () -> int = {
//     let f: () -> int = () -> 42,
//     f(),
// }
//
// @test_nullary_fn_str tests @nullary_fn_str () -> void = {
//     let f: () -> str = () -> "hello",
//     assert_eq(actual: f(), expected: "hello"),
// }
//
// @nullary_fn_str () -> str = {
//     let f: () -> str = () -> "hello",
//     f(),
// }
//
// @test_nullary_fn_void tests @nullary_fn_void () -> void = {
//     let f: () -> void = () -> (),
//     f(),
//     assert(cond: true),
// }
//
// @nullary_fn_void () -> void = {
//     let f: () -> void = () -> (),
//     f(),
// }
//
// // =============================================================================
// // Unary Function Type (A) -> B
// // =============================================================================
//
// @test_unary_fn tests @unary_fn () -> void = {
//     let f: (int) -> int = x -> x * 2,
//     assert_eq(actual: f(5), expected: 10),
// }
//
// @unary_fn () -> int = {
//     let f: (int) -> int = x -> x * 2,
//     f(5),
// }
//
// @test_unary_fn_diff_types tests @unary_fn_diff_types () -> void = {
//     let f: (int) -> str = n -> str(n),
//     assert_eq(actual: f(42), expected: "42"),
// }
//
// @unary_fn_diff_types () -> str = {
//     let f: (int) -> str = n -> str(n),
//     f(42),
// }
//
// @test_unary_fn_str_int tests @unary_fn_str_int () -> void = {
//     let f: (str) -> int = s -> s.len(),
//     assert_eq(actual: f("hello"), expected: 5),
// }
//
// @unary_fn_str_int () -> int = {
//     let f: (str) -> int = s -> s.len(),
//     f("hello"),
// }
//
// // =============================================================================
// // Binary Function Type (A, B) -> C
// // =============================================================================
//
// @test_binary_fn tests @binary_fn () -> void = {
//     let f: (int, int) -> int = (a, b) -> a + b,
//     assert_eq(actual: f(10, 20), expected: 30),
// }
//
// @binary_fn () -> int = {
//     let f: (int, int) -> int = (a, b) -> a + b,
//     f(10, 20),
// }
//
// @test_binary_fn_diff_types tests @binary_fn_diff_types () -> void = {
//     let f: (str, int) -> str = (s, n) -> s + str(n),
//     assert_eq(actual: f("value: ", 42), expected: "value: 42"),
// }
//
// @binary_fn_diff_types () -> str = {
//     let f: (str, int) -> str = (s, n) -> s + str(n),
//     f("value: ", 42),
// }
//
// // =============================================================================
// // Ternary Function Type (A, B, C) -> D
// // =============================================================================
//
// @test_ternary_fn tests @ternary_fn () -> void = {
//     let f: (int, int, int) -> int = (a, b, c) -> a + b + c,
//     assert_eq(actual: f(1, 2, 3), expected: 6),
// }
//
// @ternary_fn () -> int = {
//     let f: (int, int, int) -> int = (a, b, c) -> a + b + c,
//     f(1, 2, 3),
// }
//
// // =============================================================================
// // Function Type with Typed Parameters
// // =============================================================================
//
// @test_typed_lambda tests @typed_lambda () -> void = {
//     let f: (int) -> int = (x: int) -> int = x * 2,
//     assert_eq(actual: f(5), expected: 10),
// }
//
// @typed_lambda () -> int = {
//     let f = (x: int) -> int = x * 2,
//     f(5),
// }
//
// // =============================================================================
// // Higher-Order Functions
// // =============================================================================
//
// @test_fn_as_param tests @fn_as_param () -> void = {
//     let result = apply(f: x -> x * 2, value: 5),
//     assert_eq(actual: result, expected: 10),
// }
//
// @apply (f: (int) -> int, value: int) -> int = f(value)
//
// @fn_as_param () -> int = apply(f: x -> x * 2, value: 5)
//
// @test_fn_returning_fn tests @fn_returning_fn () -> void = {
//     let adder = make_adder(n: 10),
//     assert_eq(actual: adder(5), expected: 15),
// }
//
// @make_adder (n: int) -> (int) -> int = x -> x + n
//
// @fn_returning_fn () -> (int) -> int = make_adder(n: 10)
//
// // =============================================================================
// // Function Composition
// // =============================================================================
//
// @test_compose tests @compose () -> void = {
//     let double: (int) -> int = x -> x * 2,
//     let add_one: (int) -> int = x -> x + 1,
//     let composed = compose(f: add_one, g: double),
//     assert_eq(actual: composed(5), expected: 11),
// }
//
// @compose (f: (int) -> int, g: (int) -> int) -> (int) -> int = x -> f(g(x))
//
// @compose_fns () -> (int) -> int = {
//     let double: (int) -> int = x -> x * 2,
//     let add_one: (int) -> int = x -> x + 1,
//     compose(f: add_one, g: double),
// }
//
// // =============================================================================
// // Function Types with Collections
// // =============================================================================
//
// @test_fn_list_param tests @fn_list_param () -> void = {
//     let f: ([int]) -> int = items -> items.len(),
//     assert_eq(actual: f([1, 2, 3]), expected: 3),
// }
//
// @fn_list_param () -> int = {
//     let f: ([int]) -> int = items -> items.len(),
//     f([1, 2, 3]),
// }
//
// @test_fn_returns_list tests @fn_returns_list () -> void = {
//     let f: (int) -> [int] = n -> [n, n * 2, n * 3],
//     let result = f(5),
//     assert_eq(actual: result, expected: [5, 10, 15]),
// }
//
// @fn_returns_list () -> [int] = {
//     let f: (int) -> [int] = n -> [n, n * 2, n * 3],
//     f(5),
// }
//
// // =============================================================================
// // Function Types with Option/Result
// // =============================================================================
//
// @test_fn_returns_option tests @fn_returns_option () -> void = {
//     let f: (int) -> Option<int> = n -> if n > 0 then Some(n) else None,
//     assert(cond: is_some(opt: f(5))),
//     assert(cond: is_none(opt: f(-1))),
// }
//
// @fn_returns_option () -> Option<int> = {
//     let f: (int) -> Option<int> = n -> if n > 0 then Some(n) else None,
//     f(5),
// }
//
// @test_fn_returns_result tests @fn_returns_result () -> void = {
//     let f: (int) -> Result<int, str> = n -> if n >= 0 then Ok(n) else Err("negative"),
//     assert(cond: is_ok(r: f(5))),
//     assert(cond: is_err(r: f(-1))),
// }
//
// @fn_returns_result () -> Result<int, str> = {
//     let f: (int) -> Result<int, str> = n -> if n >= 0 then Ok(n) else Err("negative"),
//     f(5),
// }
//
// // =============================================================================
// // Function Types with Tuples
// // =============================================================================
//
// @test_fn_tuple_param tests @fn_tuple_param () -> void = {
//     let f: ((int, int)) -> int = t -> {
//         let (a, b) = t,
//         a + b,
//     },
//     assert_eq(actual: f((10, 20)), expected: 30),
// }
//
// @fn_tuple_param () -> int = {
//     let f: ((int, int)) -> int = t -> {
//         let (a, b) = t,
//         a + b,
//     },
//     f((10, 20)),
// }
//
// @test_fn_returns_tuple tests @fn_returns_tuple () -> void = {
//     let f: (int) -> (int, int) = n -> (n, n * 2),
//     let (a, b) = f(5),
//     assert_eq(actual: a, expected: 5),
//     assert_eq(actual: b, expected: 10),
// }
//
// @fn_returns_tuple () -> (int, int) = {
//     let f: (int) -> (int, int) = n -> (n, n * 2),
//     f(5),
// }
//
// // =============================================================================
// // Nested Function Types
// // =============================================================================
//
// @test_nested_fn_type tests @nested_fn_type () -> void = {
//     let f: ((int) -> int) -> (int) -> int = g -> x -> g(g(x)),
//     let double: (int) -> int = x -> x * 2,
//     let quadruple = f(double),
//     assert_eq(actual: quadruple(5), expected: 20),
// }
//
// @nested_fn_type () -> int = {
//     let f: ((int) -> int) -> (int) -> int = g -> x -> g(g(x)),
//     let double: (int) -> int = x -> x * 2,
//     let quadruple = f(double),
//     quadruple(5),
// }
//
// // =============================================================================
// // Function Types in Structs
// // =============================================================================
// //
// // STATUS: Lexer [OK], Parser [OK], Evaluator [BROKEN] - no method 'callback' on struct
// // Evaluator does not support calling function fields with method syntax (h.callback(x)).
//
// type Handler = { callback: (int) -> str }
//
// @test_fn_in_struct tests @fn_in_struct () -> void = {
//     let h = Handler { callback: n -> "value: " + str(n) },
//     let result = h.callback(42),
//     assert_eq(actual: result, expected: "value: 42"),
// }
//
// @fn_in_struct () -> str = {
//     let h = Handler { callback: n -> "value: " + str(n) },
//     h.callback(42),
// }
//
// // =============================================================================
// // Function Type Inference
// // =============================================================================
//
// @test_inferred_fn tests @inferred_fn () -> void = {
//     // Type inferred from usage
//     let f = x -> x + 1,
//     assert_eq(actual: f(5), expected: 6),
// }
//
// @inferred_fn () -> int = {
//     let f = x -> x + 1,
//     f(5),
// }
//
// @test_inferred_multi_param tests @inferred_multi_param () -> void = {
//     let f = (a, b) -> a + b,
//     assert_eq(actual: f(10, 20), expected: 30),
// }
//
// @inferred_multi_param () -> int = {
//     let f = (a, b) -> a + b,
//     f(10, 20),
// }
//
// // =============================================================================
// // Closures (Capturing Variables)
// // =============================================================================
//
// @test_closure tests @closure () -> void = {
//     let captured = 100,
//     let f: (int) -> int = x -> x + captured,
//     assert_eq(actual: f(5), expected: 105),
// }
//
// @closure () -> int = {
//     let captured = 100,
//     let f: (int) -> int = x -> x + captured,
//     f(5),
// }
//
// @test_multi_capture tests @multi_capture () -> void = {
//     let a = 10,
//     let b = 20,
//     let f: () -> int = () -> a + b,
//     assert_eq(actual: f(), expected: 30),
// }
//
// @multi_capture () -> int = {
//     let a = 10,
//     let b = 20,
//     let f: () -> int = () -> a + b,
//     f(),
// }
