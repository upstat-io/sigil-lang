// Spec: 08-declarations.md ยง Associated Functions

use std.testing { assert_eq, assert }
// Proposal: docs/ori_lang/proposals/approved/associated-functions-language-feature.md

// =============================================================================
// Associated Functions Tests (Phase 5.9)
// =============================================================================
// Tests that associated functions (methods without `self`) work for any type
// with an impl block, not just built-in types like Duration and Size.

// -----------------------------------------------------------------------------
// Basic Associated Functions on User-Defined Types
// -----------------------------------------------------------------------------

type Point = { x: int, y: int }

impl Point {
    // Associated function (no self parameter)
    @origin () -> Self = Point { x: 0, y: 0 }

    // Associated function with parameters
    @new (x: int, y: int) -> Self = Point { x, y }

    // Instance method for comparison
    @distance_from_origin (self) -> int = self.x * self.x + self.y * self.y
}

@test_basic_associated_function tests @_use_point () -> void = run(
    let p = Point.origin(),
    assert_eq(actual: p.x, expected: 0),
    assert_eq(actual: p.y, expected: 0),
)

@test_associated_function_with_params tests @_use_point () -> void = run(
    let p = Point.new(x: 10, y: 20),
    assert_eq(actual: p.x, expected: 10),
    assert_eq(actual: p.y, expected: 20),
)

// Helper function to trigger tests
@_use_point (p: Point) -> int = p.x + p.y

// -----------------------------------------------------------------------------
// Method Chaining with Builder Pattern
// -----------------------------------------------------------------------------

type Builder = { name: str, value: int, enabled: bool }

impl Builder {
    @new () -> Self = Builder { name: "", value: 0, enabled: false }

    @with_name (self, name: str) -> Self = Builder { name, value: self.value, enabled: self.enabled }
    @with_value (self, value: int) -> Self = Builder { name: self.name, value, enabled: self.enabled }
    @with_enabled (self, enabled: bool) -> Self = Builder { name: self.name, value: self.value, enabled }
}

@test_builder_chain tests @_use_builder () -> void = run(
    let b = Builder.new()
        .with_name(name: "example")
        .with_value(value: 42)
        .with_enabled(enabled: true),
    assert_eq(actual: b.name, expected: "example"),
    assert_eq(actual: b.value, expected: 42),
    assert(cond: b.enabled),
)

@_use_builder (b: Builder) -> str = b.name

// -----------------------------------------------------------------------------
// Self Return Type
// -----------------------------------------------------------------------------

type Counter = { count: int }

impl Counter {
    @zero () -> Self = Counter { count: 0 }
    @starting_at (n: int) -> Self = Counter { count: n }
    @increment (self) -> Self = Counter { count: self.count + 1 }
    @value (self) -> int = self.count
}

@test_self_return_type tests @_use_counter () -> void = run(
    let c = Counter.zero().increment().increment().increment(),
    assert_eq(actual: c.value(), expected: 3),
)

@test_self_return_from_associated tests @_use_counter () -> void = run(
    let c = Counter.starting_at(n: 10).increment(),
    assert_eq(actual: c.value(), expected: 11),
)

@_use_counter (c: Counter) -> int = c.count

// -----------------------------------------------------------------------------
// Multiple Associated Functions
// -----------------------------------------------------------------------------

type Rectangle = { width: int, height: int }

impl Rectangle {
    @square (size: int) -> Self = Rectangle { width: size, height: size }
    @from_dimensions (w: int, h: int) -> Self = Rectangle { width: w, height: h }
    @unit () -> Self = Rectangle { width: 1, height: 1 }

    @area (self) -> int = self.width * self.height
}

@test_multiple_associated_functions tests @_use_rect () -> void = run(
    let square = Rectangle.square(size: 5),
    let rect = Rectangle.from_dimensions(w: 3, h: 4),
    let unit = Rectangle.unit(),
    assert_eq(actual: square.area(), expected: 25),
    assert_eq(actual: rect.area(), expected: 12),
    assert_eq(actual: unit.area(), expected: 1),
)

@_use_rect (r: Rectangle) -> int = r.width

// -----------------------------------------------------------------------------
// Built-in Types Still Work (Duration, Size)
// -----------------------------------------------------------------------------

@test_duration_associated_function tests @_duration_helper () -> void = run(
    let d = Duration.from_seconds(s: 5),
    assert_eq(actual: d.seconds(), expected: 5),
)

@test_size_associated_function tests @_size_helper () -> void = run(
    let s = Size.from_megabytes(mb: 2),
    assert_eq(actual: s.megabytes(), expected: 2),
)

@_duration_helper (d: Duration) -> int = d.seconds()
@_size_helper (s: Size) -> int = s.bytes()

// -----------------------------------------------------------------------------
// Instance vs Associated Function Distinction
// -----------------------------------------------------------------------------

type Pair = { a: int, b: int }

impl Pair {
    // Associated function (called on type)
    @create (x: int, y: int) -> Self = Pair { a: x, b: y }

    // Instance methods (called on values)
    @sum (self) -> int = self.a + self.b
    @swap (self) -> Self = Pair { a: self.b, b: self.a }
}

@test_instance_vs_associated tests @_use_pair () -> void = run(
    // Call associated function on type
    let p = Pair.create(x: 3, y: 5),
    // Call instance methods on value
    let sum = p.sum(),
    let swapped = p.swap(),
    assert_eq(actual: sum, expected: 8),
    assert_eq(actual: swapped.a, expected: 5),
    assert_eq(actual: swapped.b, expected: 3),
)

@_use_pair (p: Pair) -> int = p.a

