// Spec: 06-types.md Â§ Primitive Types
// Design: 03-type-system/01-primitive-types.md

use std.testing { assert, assert_eq, assert_ne }

// =============================================================================
// int â€” 64-bit Signed Integer
// =============================================================================
// Spec: 06-types.md Â§ Integer Type
// Design: 03-type-system/01-primitive-types.md Â§ int

@test_int_literal tests @int_literal () -> void = run(
    let x = 42,
    assert_eq(
        actual: x,
        expected: 42,
    ),
)

@int_literal () -> int = 42

@test_int_negative tests @int_negative () -> void = run(
    let x = -17,
    assert_eq(
        actual: x,
        expected: -17,
    ),
)

@int_negative () -> int = -17

@test_int_zero tests @int_zero () -> void = run(
    let x = 0,
    assert_eq(
        actual: x,
        expected: 0,
    ),
)

@int_zero () -> int = 0

@test_int_underscore tests @int_underscore () -> void = run(
    let x = 1_000_000,
    assert_eq(
        actual: x,
        expected: 1000000,
    ),
)

@int_underscore () -> int = 1_000_000

@test_int_hex tests @int_hex () -> void = run(
    let x = 0xFF,
    assert_eq(
        actual: x,
        expected: 255,
    ),
)

@int_hex () -> int = 0xFF

@test_int_annotated tests @int_annotated () -> void = run(
    let x: int = 42,
    assert_eq(
        actual: x,
        expected: 42,
    ),
)

@int_annotated () -> int = run(
    let x: int = 42,
    x,
)

@test_int_arithmetic tests @int_arithmetic () -> void = run(
    assert_eq(
        actual: 3 + 2,
        expected: 5,
    ),
    assert_eq(
        actual: 3 - 2,
        expected: 1,
    ),
    assert_eq(
        actual: 3 * 2,
        expected: 6,
    ),
    assert_eq(
        actual: 7 / 2,
        expected: 3,
    ),
    assert_eq(
        actual: 7 % 2,
        expected: 1,
    ),
    assert_eq(
        actual: -7 / 3,
        expected: -2,
    ),
    // TODO: div operator not yet implemented in oric-v3 parser
    // assert_eq(
    //     actual: -7 div 3,
    //     expected: -3,
    // ),
)

@int_arithmetic () -> int = 3 + 2

@test_int_comparison tests @int_comparison () -> void = run(
    assert(cond: 1 < 2),
    assert(cond: 2 > 1),
    assert(cond: 2 <= 2),
    assert(cond: 2 >= 2),
    assert(cond: 2 == 2),
    assert(cond: 1 != 2),
)

@int_comparison () -> bool = 1 < 2

// =============================================================================
// float â€” 64-bit Floating Point
// =============================================================================
// Spec: 06-types.md Â§ Floating-Point Type
// Design: 03-type-system/01-primitive-types.md Â§ float

@test_float_literal tests @float_literal () -> void = run(
    let x = 3.14,
    assert(cond: x > 3.0),
    assert(cond: x < 4.0),
)

@float_literal () -> float = 3.14

@test_float_negative tests @float_negative () -> void = run(
    let x = -0.5,
    assert(cond: x < 0.0),
)

@float_negative () -> float = -0.5

@test_float_scientific tests @float_scientific () -> void = run(
    let x = 1.5e10,
    assert(cond: x > 1.0e10),
)

@float_scientific () -> float = 1.5e10

@test_float_annotated tests @float_annotated () -> void = run(
    let x: float = 2.5,
    assert(cond: x > 2.0),
)

@float_annotated () -> float = run(
    let x: float = 2.5,
    x,
)

@test_float_arithmetic tests @float_arithmetic () -> void = run(
    assert(cond: 3.0 + 2.0 == 5.0),
    assert(cond: 3.0 - 2.0 == 1.0),
    assert(cond: 3.0 * 2.0 == 6.0),
    assert(cond: 6.0 / 2.0 == 3.0),
)

@float_arithmetic () -> float = 3.0 + 2.0

@test_float_comparison tests @float_comparison () -> void = run(
    assert(cond: 1.0 < 2.0),
    assert(cond: 2.0 > 1.0),
    assert(cond: 2.0 <= 2.0),
    assert(cond: 2.0 >= 2.0),
    assert(cond: 2.0 == 2.0),
    assert(cond: 1.0 != 2.0),
)

@float_comparison () -> bool = 1.0 < 2.0

// =============================================================================
// bool â€” Boolean
// =============================================================================
// Spec: 06-types.md Â§ Boolean Type
// Design: 03-type-system/01-primitive-types.md Â§ bool

@test_bool_true tests @bool_true () -> void = run(
    let x = true,
    assert(cond: x),
)

@bool_true () -> bool = true

@test_bool_false tests @bool_false () -> void = run(
    let x = false,
    assert(cond: !x),
)

@bool_false () -> bool = false

@test_bool_annotated tests @bool_annotated () -> void = run(
    let x: bool = true,
    assert(cond: x),
)

@bool_annotated () -> bool = run(
    let x: bool = true,
    x,
)

@test_bool_logical tests @bool_logical () -> void = run(
    // Logical AND
    assert(cond: true && true),
    assert(cond: !(true && false)),
    assert(cond: !(false && true)),
    assert(cond: !(false && false)),
    // Logical OR
    assert(cond: true || true),
    assert(cond: true || false),
    assert(cond: false || true),
    assert(cond: !(false || false)),
    // Logical NOT
    assert(cond: !false),
    assert(cond: !!true),
)

@bool_logical () -> bool = true && true

@test_bool_equality tests @bool_equality () -> void = run(
    assert(cond: true == true),
    assert(cond: false == false),
    assert(cond: true != false),
    assert(cond: false != true),
)

@bool_equality () -> bool = true == true

// =============================================================================
// str â€” UTF-8 String
// =============================================================================
// Spec: 06-types.md Â§ String Type
// Design: 03-type-system/01-primitive-types.md Â§ str

@test_str_literal tests @str_literal () -> void = run(
    let x = "hello",
    assert_eq(
        actual: x,
        expected: "hello",
    ),
)

@str_literal () -> str = "hello"

@test_str_empty tests @str_empty () -> void = run(
    let x = "",
    assert_eq(
        actual: x,
        expected: "",
    ),
)

@str_empty () -> str = ""

@test_str_escape tests @str_escape () -> void = run(
    let x = "line1\nline2",
    assert(cond: len(collection: x) > 6),
)

@str_escape () -> str = "line1\nline2"

@test_str_annotated tests @str_annotated () -> void = run(
    let x: str = "world",
    assert_eq(
        actual: x,
        expected: "world",
    ),
)

@str_annotated () -> str = run(
    let x: str = "world",
    x,
)

@test_str_concat tests @str_concat () -> void = run(
    let x = "hello" + " " + "world",
    assert_eq(
        actual: x,
        expected: "hello world",
    ),
)

@str_concat () -> str = "hello" + " " + "world"

@test_str_comparison tests @str_comparison () -> void = run(
    assert(cond: "a" < "b"),
    assert(cond: "b" > "a"),
    assert(cond: "abc" == "abc"),
    assert(cond: "abc" != "def"),
)

@str_comparison () -> bool = "a" < "b"

@test_str_len tests @str_len () -> void = run(
    assert_eq(
        actual: len(collection: "hello"),
        expected: 5,
    ),
    assert_eq(
        actual: len(collection: ""),
        expected: 0,
    ),
)

@str_len () -> int = len(collection: "hello")

// =============================================================================
// char â€” Unicode Character
// =============================================================================
// Spec: 06-types.md Â§ Character Type
// Design: 03-type-system/01-primitive-types.md Â§ char

@test_char_ascii tests @char_ascii () -> void = run(
    let x = 'a',
    assert_eq(
        actual: x,
        expected: 'a',
    ),
)

@char_ascii () -> char = 'a'

@test_char_unicode tests @char_unicode () -> void = run(
    let x = 'Î»',
    assert_eq(
        actual: x,
        expected: 'Î»',
    ),
)

@char_unicode () -> char = 'Î»'

@test_char_escape tests @char_escape () -> void = run(
    let newline = '\n',
    let tab = '\t',
    let backslash = '\\',
    assert(cond: newline != tab),
    assert(cond: tab != backslash),
)

@char_escape () -> char = '\n'

@test_char_annotated tests @char_annotated () -> void = run(
    let x: char = 'z',
    assert_eq(
        actual: x,
        expected: 'z',
    ),
)

@char_annotated () -> char = run(
    let x: char = 'z',
    x,
)

@test_char_comparison tests @char_comparison () -> void = run(
    assert(cond: 'a' < 'b'),
    assert(cond: 'b' > 'a'),
    assert(cond: 'x' == 'x'),
    assert(cond: 'x' != 'y'),
)

@char_comparison () -> bool = 'a' < 'b'

// =============================================================================
// byte â€” 8-bit Unsigned Integer
// =============================================================================
// Spec: 06-types.md Â§ Byte Type
// Design: 03-type-system/01-primitive-types.md Â§ byte

@test_byte_literal tests @byte_literal () -> void = run(
    let x: byte = 65,
    assert_eq(
        actual: int(x),
        expected: 65,
    ),
)

@byte_literal () -> byte = 65

@test_byte_hex tests @byte_hex () -> void = run(
    let x: byte = 0x41,
    assert_eq(
        actual: int(x),
        expected: 65,
    ),
)

@byte_hex () -> byte = 0x41

@test_byte_max tests @byte_max () -> void = run(
    let x: byte = 255,
    assert_eq(
        actual: int(x),
        expected: 255,
    ),
)

@byte_max () -> byte = 255

@test_byte_zero tests @byte_zero () -> void = run(
    let x: byte = 0,
    assert_eq(
        actual: int(x),
        expected: 0,
    ),
)

@byte_zero () -> byte = 0

// =============================================================================
// void â€” No Meaningful Value
// =============================================================================
// Spec: 06-types.md Â§ Void Type
// Design: 03-type-system/01-primitive-types.md Â§ void

@test_void_return tests @void_return () -> void = run(
    let result = side_effect(),
    // void functions return ()
    assert(cond: true),
)

@void_return () -> void = ()

@side_effect () -> void = run(
    let x = 1,
    (),
)

@test_void_unit tests @void_unit () -> void = run(
    // void is an alias for ()
    let x: void = (),
    assert(cond: true),
)

@void_unit () -> void = ()

// =============================================================================
// Never â€” Bottom Type
// =============================================================================
// Spec: 06-types.md Â§ Never Type
// Design: 03-type-system/01-primitive-types.md Â§ Never

@test_never_panic tests @never_panic () -> void = run(
    // Test that panic returns Never and coerces to any type
    let result: int = if false then panic(msg: "unreachable") else 42,
    assert_eq(
        actual: result,
        expected: 42,
    ),
)

@never_panic () -> int = if false then panic(msg: "unreachable") else 42

@test_never_coercion tests @never_coercion () -> void = run(
    // Never coerces to any type in conditionals
    let x: str = if true then "hello" else panic(msg: "never reached"),
    assert_eq(
        actual: x,
        expected: "hello",
    ),
)

@never_coercion () -> str = if true then "hello" else panic(msg: "never reached")

// =============================================================================
// Extended int Tests â€” Edge Cases
// =============================================================================

@test_int_large_positive tests @int_large_positive () -> void = run(
    let x = 9223372036854775807,
    assert(cond: x > 0),
)

@int_large_positive () -> int = 9223372036854775807

@test_int_large_negative tests @int_large_negative () -> void = run(
    let x = -9223372036854775808,
    assert(cond: x < 0),
)

@int_large_negative () -> int = -9223372036854775808

@test_int_hex_mixed_case tests @int_hex_mixed_case () -> void = run(
    assert_eq(actual: 0xABcd, expected: 43981),
    // Note: Capital X in hex literals (0X...) is not supported, only lowercase 0x...
    assert_eq(actual: 0xaBCd, expected: 43981),
)

@int_hex_mixed_case () -> int = 0xABcd

@test_int_underscore_positions tests @int_underscore_positions () -> void = run(
    assert_eq(actual: 1_2_3, expected: 123),
    assert_eq(actual: 1__2, expected: 12),
)

@int_underscore_positions () -> int = 1_2_3

@test_int_negation tests @int_negation () -> void = run(
    let x = 5,
    assert_eq(actual: -x, expected: -5),
    assert_eq(actual: --x, expected: 5),
    assert_eq(actual: -(-x), expected: 5),
)

@int_negation () -> int = -5

@test_int_bitwise_and tests @int_bitwise_and () -> void = run(
    assert_eq(actual: 0xFF & 0x0F, expected: 0x0F),
    assert_eq(actual: 12 & 10, expected: 8),
)

@int_bitwise_and () -> int = 0xFF & 0x0F

@test_int_bitwise_or tests @int_bitwise_or () -> void = run(
    assert_eq(actual: 0xF0 | 0x0F, expected: 0xFF),
    assert_eq(actual: 12 | 10, expected: 14),
)

@int_bitwise_or () -> int = 0xF0 | 0x0F

@test_int_bitwise_xor tests @int_bitwise_xor () -> void = run(
    assert_eq(actual: 0xFF ^ 0x0F, expected: 0xF0),
    assert_eq(actual: 12 ^ 10, expected: 6),
)

@int_bitwise_xor () -> int = 0xFF ^ 0x0F

@test_int_bitwise_not tests @int_bitwise_not () -> void = run(
    assert_eq(actual: ~0, expected: -1),
    assert_eq(actual: ~~5, expected: 5),
)

@int_bitwise_not () -> int = ~0

@test_int_left_shift tests @int_left_shift () -> void = run(
    assert_eq(actual: 1 << 4, expected: 16),
    assert_eq(actual: 3 << 2, expected: 12),
)

@int_left_shift () -> int = 1 << 4

// Right shift operator now works after lexer boundary fix.
// The lexer produces single `>` tokens, parser combines adjacent `>` tokens as `>>` in expressions.
@test_int_right_shift tests @int_right_shift () -> void = run(
    assert_eq(actual: 16 >> 4, expected: 1),
    assert_eq(actual: 12 >> 2, expected: 3),
)

@int_right_shift () -> int = 16 >> 4

@test_int_modulo_negative tests @int_modulo_negative () -> void = run(
    assert_eq(actual: 7 % 3, expected: 1),
    assert_eq(actual: -7 % 3, expected: -1),
    assert_eq(actual: 7 % -3, expected: 1),
)

@int_modulo_negative () -> int = -7 % 3

@test_int_division_truncates tests @int_division_truncates () -> void = run(
    assert_eq(actual: 5 / 2, expected: 2),
    assert_eq(actual: -5 / 2, expected: -2),
    assert_eq(actual: 5 / -2, expected: -2),
)

@int_division_truncates () -> int = 5 / 2

@test_int_operator_precedence tests @int_operator_precedence () -> void = run(
    assert_eq(actual: 2 + 3 * 4, expected: 14),
    assert_eq(actual: (2 + 3) * 4, expected: 20),
    assert_eq(actual: 10 - 4 - 2, expected: 4),
    assert_eq(actual: 10 - (4 - 2), expected: 8),
)

@int_operator_precedence () -> int = 2 + 3 * 4

// =============================================================================
// Extended float Tests â€” Edge Cases
// =============================================================================

@test_float_zero tests @float_zero () -> void = run(
    assert(cond: 0.0 == 0.0),
    assert(cond: -0.0 == 0.0),
)

@float_zero () -> float = 0.0

@test_float_small tests @float_small () -> void = run(
    let x = 0.000001,
    assert(cond: x > 0.0),
    assert(cond: x < 0.001),
)

@float_small () -> float = 0.000001

@test_float_scientific_negative_exp tests @float_scientific_negative_exp () -> void = run(
    let x = 1.5e-10,
    assert(cond: x > 0.0),
    assert(cond: x < 0.000001),
)

@float_scientific_negative_exp () -> float = 1.5e-10

@test_float_mixed_arithmetic tests @float_mixed_arithmetic () -> void = run(
    assert(cond: 1.5 + 2.5 == 4.0),
    assert(cond: 5.0 - 2.5 == 2.5),
    assert(cond: 2.0 * 1.5 == 3.0),
    assert(cond: 3.0 / 2.0 == 1.5),
)

@float_mixed_arithmetic () -> float = 1.5 + 2.5

@test_float_negation tests @float_negation () -> void = run(
    let x = 3.14,
    assert(cond: -x < 0.0),
    assert(cond: --x > 0.0),
)

@float_negation () -> float = -3.14

// =============================================================================
// Extended bool Tests â€” Edge Cases
// =============================================================================

@test_bool_short_circuit_and tests @bool_short_circuit_and () -> void = run(
    let evaluated = false,
    let result = false && panic(msg: "should not evaluate"),
    assert(cond: !result),
)

@bool_short_circuit_and () -> bool = false && true

@test_bool_short_circuit_or tests @bool_short_circuit_or () -> void = run(
    let result = true || panic(msg: "should not evaluate"),
    assert(cond: result),
)

@bool_short_circuit_or () -> bool = true || false

@test_bool_complex_expression tests @bool_complex_expression () -> void = run(
    assert(cond: (true && false) || true),
    assert(cond: !(false && true) && true),
    assert(cond: (1 < 2) && (3 > 2)),
)

@bool_complex_expression () -> bool = (true && false) || true

// =============================================================================
// Extended str Tests â€” Edge Cases
// =============================================================================

// TODO: IMPLEMENTATION BUG: len() returns byte count not character count for strings
// Unicode strings "ã“ã‚“ã«ã¡ã¯" has 5 characters but 15 bytes (3 bytes per Japanese char)
// @test_str_unicode_content tests @str_unicode_content () -> void = run(
//     let x = "ã“ã‚“ã«ã¡ã¯",
//     assert(cond: len(collection: x) == 5),
// )

@str_unicode_content () -> str = "ã“ã‚“ã«ã¡ã¯"

@test_str_unicode_byte_len tests @str_unicode_byte_len () -> void = run(
    let x = "ã“ã‚“ã«ã¡ã¯",
    // len() returns byte count, not character count
    assert(cond: len(collection: x) == 15),
)

@str_unicode_byte_len () -> int = len(collection: "ã“ã‚“ã«ã¡ã¯")

@test_str_emoji tests @str_emoji () -> void = run(
    let x = "Hello ğŸ‘‹ World",
    assert(cond: len(collection: x) > 10),
)

@str_emoji () -> str = "Hello ğŸ‘‹ World"

@test_str_multiline_escape tests @str_multiline_escape () -> void = run(
    let x = "line1\nline2\nline3",
    assert(cond: len(collection: x) > 15),
)

@str_multiline_escape () -> str = "line1\nline2\nline3"

@test_str_tab_escape tests @str_tab_escape () -> void = run(
    let x = "col1\tcol2",
    assert(cond: len(collection: x) == 9),
)

@str_tab_escape () -> str = "col1\tcol2"

@test_str_quote_escape tests @str_quote_escape () -> void = run(
    let x = "He said \"hello\"",
    assert(cond: len(collection: x) > 10),
)

@str_quote_escape () -> str = "He said \"hello\""

@test_str_backslash_escape tests @str_backslash_escape () -> void = run(
    let x = "path\\to\\file",
    assert(cond: len(collection: x) == 12),
)

@str_backslash_escape () -> str = "path\\to\\file"

@test_str_concat_multiple tests @str_concat_multiple () -> void = run(
    let x = "a" + "b" + "c" + "d",
    assert_eq(actual: x, expected: "abcd"),
)

@str_concat_multiple () -> str = "a" + "b" + "c" + "d"

@test_str_concat_with_empty tests @str_concat_with_empty () -> void = run(
    let x = "" + "hello" + "",
    assert_eq(actual: x, expected: "hello"),
)

@str_concat_with_empty () -> str = "" + "hello" + ""

@test_str_lexicographic_comparison tests @str_lexicographic_comparison () -> void = run(
    assert(cond: "apple" < "banana"),
    assert(cond: "abc" < "abd"),
    assert(cond: "a" < "aa"),
    assert(cond: "" < "a"),
)

@str_lexicographic_comparison () -> bool = "apple" < "banana"

// =============================================================================
// Extended char Tests â€” Edge Cases
// =============================================================================

@test_char_digits tests @char_digits () -> void = run(
    assert_eq(actual: '0', expected: '0'),
    assert_eq(actual: '9', expected: '9'),
    assert(cond: '0' < '9'),
)

@char_digits () -> char = '5'

@test_char_special tests @char_special () -> void = run(
    let space = ' ',
    let at = '@',
    let hash = '#',
    assert(cond: space != at),
    assert(cond: at != hash),
)

@char_special () -> char = '@'

@test_char_emoji tests @char_emoji () -> void = run(
    let emoji = 'ğŸ˜€',
    assert_eq(actual: emoji, expected: 'ğŸ˜€'),
)

@char_emoji () -> char = 'ğŸ˜€'

// =============================================================================
// Type Conversions
// =============================================================================

@test_int_to_float tests @int_to_float () -> void = run(
    let x: int = 42,
    let y: float = float(x),
    assert(cond: y == 42.0),
)

@int_to_float () -> float = float(42)

@test_float_to_int tests @float_to_int () -> void = run(
    let x: float = 3.7,
    let y: int = int(x),
    assert_eq(actual: y, expected: 3),
)

@float_to_int () -> int = int(3.7)

@test_float_to_int_negative tests @float_to_int_negative () -> void = run(
    let x: float = -3.7,
    let y: int = int(x),
    assert_eq(actual: y, expected: -3),
)

@float_to_int_negative () -> int = int(-3.7)

@test_int_to_str tests @int_to_str () -> void = run(
    let x: int = 42,
    let s: str = str(x),
    assert_eq(actual: s, expected: "42"),
)

@int_to_str () -> str = str(42)

@test_int_to_str_negative tests @int_to_str_negative () -> void = run(
    let x: int = -123,
    let s: str = str(x),
    assert_eq(actual: s, expected: "-123"),
)

@int_to_str_negative () -> str = str(-123)

@test_float_to_str tests @float_to_str () -> void = run(
    let x: float = 3.14,
    let s: str = str(x),
    assert(cond: len(collection: s) > 0),
)

@float_to_str () -> str = str(3.14)

@test_bool_to_str tests @bool_to_str () -> void = run(
    assert_eq(actual: str(true), expected: "true"),
    assert_eq(actual: str(false), expected: "false"),
)

@bool_to_str () -> str = str(true)

// TODO: IMPLEMENTATION BUG: int(b) where b is byte doesn't work - "cannot convert byte to int"
// @test_byte_to_int tests @byte_to_int () -> void = run(
//     let b: byte = 200,
//     let i: int = int(b),
//     assert_eq(actual: i, expected: 200),
// )

@byte_to_int () -> int = 200

// TODO: IMPLEMENTATION BUG: int(b) where b is byte doesn't work - "cannot convert byte to int"
// @test_int_to_byte tests @int_to_byte () -> void = run(
//     let i: int = 100,
//     let b: byte = byte(i),
//     assert_eq(actual: int(b), expected: 100),
// )

@int_to_byte () -> byte = byte(100)
