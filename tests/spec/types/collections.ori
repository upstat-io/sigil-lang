// Spec: 06-types.md § Compound Types
// Design: 03-type-system/05-type-inference.md § Collection Element Inference

use std.testing { assert, assert_eq, assert_ne }

// =============================================================================
// List Type Inference
// =============================================================================

@test_list_int tests @list_int () -> void = run(
    let nums = [1, 2, 3],
    assert_eq(
        actual: nums[0],
        expected: 1,
    ),
    assert_eq(
        actual: len(collection: nums),
        expected: 3,
    ),
)

@list_int () -> int = [1, 2, 3][0]

@test_list_str tests @list_str () -> void = run(
    let strs = ["a", "b", "c"],
    assert_eq(
        actual: strs[0],
        expected: "a",
    ),
    assert_eq(
        actual: len(collection: strs),
        expected: 3,
    ),
)

@list_str () -> str = ["a", "b", "c"][0]

@test_list_bool tests @list_bool () -> void = run(
    let bools = [true, false, true],
    assert(cond: bools[0]),
    assert(cond: !bools[1]),
)

@list_bool () -> bool = [true, false, true][0]

@test_list_nested tests @list_nested () -> void = run(
    let nested = [[1, 2], [3, 4], [5, 6]],
    assert_eq(
        actual: nested[0][0],
        expected: 1,
    ),
    assert_eq(
        actual: nested[1][1],
        expected: 4,
    ),
)

@list_nested () -> int = [[1, 2], [3, 4]][0][0]

@test_list_empty_annotated tests @list_empty_annotated () -> void = run(
    let empty: [int] = [],
    assert_eq(
        actual: len(collection: empty),
        expected: 0,
    ),
)

@list_empty_annotated () -> int = run(
    let empty: [int] = [],
    len(collection: empty),
)

// =============================================================================
// Tuple Type Inference
// =============================================================================

@test_tuple_pair tests @tuple_pair () -> void = run(
    let pair = (1, "hello"),
    let (a, b) = pair,
    assert_eq(
        actual: a,
        expected: 1,
    ),
    assert_eq(
        actual: b,
        expected: "hello",
    ),
)

@tuple_pair () -> int = run(
    let pair = (1, "hello"),
    let (a, b) = pair,
    a,
)

@test_tuple_triple tests @tuple_triple () -> void = run(
    let triple = (1, "two", true),
    let (a, b, c) = triple,
    assert_eq(
        actual: a,
        expected: 1,
    ),
    assert_eq(
        actual: b,
        expected: "two",
    ),
    assert(cond: c),
)

@tuple_triple () -> int = run(
    let triple = (1, "two", true),
    let (a, b, c) = triple,
    a,
)

@test_tuple_nested tests @tuple_nested () -> void = run(
    let nested = ((1, 2), (3, 4)),
    let (left, right) = nested,
    let (a, b) = left,
    assert_eq(
        actual: a,
        expected: 1,
    ),
)

@tuple_nested () -> int = run(
    let nested = ((1, 2), (3, 4)),
    let (left, right) = nested,
    let (a, b) = left,
    a,
)

// =============================================================================
// Mixed Collection Inference
// =============================================================================

@test_list_of_tuples tests @list_of_tuples () -> void = run(
    let pairs = [(1, "a"), (2, "b"), (3, "c")],
    let (num, letter) = pairs[0],
    assert_eq(
        actual: num,
        expected: 1,
    ),
    assert_eq(
        actual: letter,
        expected: "a",
    ),
)

@list_of_tuples () -> int = run(
    let pairs = [(1, "a"), (2, "b")],
    let (num, letter) = pairs[0],
    num,
)

@test_option_of_list tests @option_of_list () -> void = run(
    let opt = Some([1, 2, 3]),
    assert(cond: is_some(opt: opt)),
)

@option_of_list () -> bool = run(
    let opt = Some([1, 2, 3]),
    is_some(opt: opt),
)

@test_list_of_options tests @list_of_options () -> void = run(
    let opts = [Some(1), None, Some(3)],
    let first = opts[0],
    assert(cond: is_some(opt: first)),
)

@list_of_options () -> bool = run(
    let opts = [Some(1), None, Some(3)],
    is_some(opt: opts[0]),
)

// =============================================================================
// Extended List Tests — Edge Cases
// =============================================================================

@test_list_single_element tests @list_single_element () -> void = run(
    let single = [42],
    assert_eq(actual: len(collection: single), expected: 1),
    assert_eq(actual: single[0], expected: 42),
)

@list_single_element () -> int = [42][0]

// TODO: PARSER BUG: # symbol for length in index expressions not implemented
// Expected: nums[# - 1] to return the last element (# = length)
// Error: expected expression, found #
// @test_list_index_last tests @list_index_last () -> void = run(
//     let nums = [10, 20, 30, 40, 50],
//     // # represents length inside brackets
//     assert_eq(actual: nums[# - 1], expected: 50),
//     assert_eq(actual: nums[# - 2], expected: 40),
// )

@list_index_last () -> int = [1, 2, 3][2]

@test_list_length_comparison tests @list_length_comparison () -> void = run(
    let a = [1, 2, 3],
    let b = [1, 2],
    assert(cond: len(collection: a) > len(collection: b)),
)

@list_length_comparison () -> bool = len(collection: [1, 2, 3]) > len(collection: [1, 2])

@test_list_is_empty tests @list_is_empty () -> void = run(
    let empty: [int] = [],
    let nonempty = [1],
    assert(cond: is_empty(collection: empty)),
    assert(cond: !is_empty(collection: nonempty)),
)

@list_is_empty () -> bool = is_empty(collection: [])

@test_list_deeply_nested tests @list_deeply_nested () -> void = run(
    let deep = [[[1, 2], [3, 4]], [[5, 6], [7, 8]]],
    assert_eq(actual: deep[0][0][0], expected: 1),
    assert_eq(actual: deep[1][1][1], expected: 8),
)

@list_deeply_nested () -> int = [[[1]]][0][0][0]

@test_list_float tests @list_float () -> void = run(
    let floats = [1.0, 2.5, 3.14],
    assert(cond: floats[0] == 1.0),
    assert(cond: floats[2] > 3.0),
)

@list_float () -> float = [1.0, 2.0, 3.0][0]

@test_list_char tests @list_char () -> void = run(
    let chars = ['a', 'b', 'c'],
    assert_eq(actual: chars[0], expected: 'a'),
    assert_eq(actual: len(collection: chars), expected: 3),
)

@list_char () -> char = ['a', 'b', 'c'][1]

// =============================================================================
// Map Type Tests
// =============================================================================

// NOTE: Map indexing returns the value directly (not Option), panics on missing key
@test_map_str_int tests @map_str_int () -> void = run(
    let ages = {"alice": 30, "bob": 25},
    let alice_age = ages["alice"],
    assert_eq(actual: alice_age, expected: 30),
)

@map_str_int () -> int = run(
    let ages = {"alice": 30},
    ages["alice"],
)

@test_map_empty tests @map_empty () -> void = run(
    let empty: {str: int} = {},
    assert_eq(actual: len(collection: empty), expected: 0),
    assert(cond: is_empty(collection: empty)),
)

@map_empty () -> int = run(
    let empty: {str: int} = {},
    len(collection: empty),
)

// TODO: IMPLEMENTATION BUG: Map access panics on missing key instead of returning None
// Spec says map[key] should return Option<V>, but it panics with "key not found"
// @test_map_missing_key tests @map_missing_key () -> void = run(
//     let m = {"key": 42},
//     let missing = m["nonexistent"],
//     assert(cond: is_none(opt: missing)),
// )

@map_missing_key () -> bool = true

// TODO: IMPLEMENTATION BUG: Map keys must be strings - int keys not supported
// Error: "map keys must be strings"
// @test_map_int_keys tests @map_int_keys () -> void = run(
//     let m = {1: "one", 2: "two", 3: "three"},
//     let one = m[1],
//     assert_eq(actual: one, expected: "one"),
// )

@map_int_keys () -> bool = true

@test_map_bool_values tests @map_bool_values () -> void = run(
    let flags = {"enabled": true, "debug": false},
    let enabled = flags["enabled"],
    assert(cond: enabled),
)

@map_bool_values () -> bool = run(
    let flags = {"flag": true},
    flags["flag"],
)

// =============================================================================
// Extended Tuple Tests — Edge Cases
// =============================================================================

@test_tuple_unit tests @tuple_unit () -> void = run(
    let unit = (),
    assert(cond: true),
)

@tuple_unit () -> void = ()

@test_tuple_single tests @tuple_single () -> void = run(
    // Single element tuple
    let single = (42,),
    let (x,) = single,
    assert_eq(actual: x, expected: 42),
)

@tuple_single () -> int = run(
    let single = (42,),
    let (x,) = single,
    x,
)

@test_tuple_four_elements tests @tuple_four_elements () -> void = run(
    let quad = (1, 2, 3, 4),
    let (a, b, c, d) = quad,
    assert_eq(actual: a + b + c + d, expected: 10),
)

@tuple_four_elements () -> int = run(
    let quad = (1, 2, 3, 4),
    let (a, b, c, d) = quad,
    a + b + c + d,
)

@test_tuple_mixed_types tests @tuple_mixed_types () -> void = run(
    let mixed = (42, "hello", true, 3.14),
    let (i, s, b, f) = mixed,
    assert_eq(actual: i, expected: 42),
    assert_eq(actual: s, expected: "hello"),
    assert(cond: b),
    assert(cond: f > 3.0),
)

@tuple_mixed_types () -> int = run(
    let mixed = (42, "hello", true, 3.14),
    let (i, s, b, f) = mixed,
    i,
)

@test_tuple_with_option tests @tuple_with_option () -> void = run(
    let t = (Some(1), None),
    let (a, b) = t,
    assert(cond: is_some(opt: a)),
    assert(cond: is_none(opt: b)),
)

@tuple_with_option () -> bool = run(
    let t = (Some(1), None),
    let (a, b) = t,
    is_some(opt: a),
)

@test_tuple_with_list tests @tuple_with_list () -> void = run(
    let t = ([1, 2, 3], ["a", "b"]),
    let (nums, strs) = t,
    assert_eq(actual: len(collection: nums), expected: 3),
    assert_eq(actual: len(collection: strs), expected: 2),
)

@tuple_with_list () -> int = run(
    let t = ([1, 2, 3], ["a", "b"]),
    let (nums, strs) = t,
    len(collection: nums),
)

// =============================================================================
// Complex Nested Collections
// =============================================================================

@test_list_of_maps tests @list_of_maps () -> void = run(
    let people = [{"name": "Alice"}, {"name": "Bob"}],
    let first = people[0],
    let name = first["name"],
    assert_eq(actual: name, expected: "Alice"),
)

@list_of_maps () -> str = run(
    let people = [{"name": "Alice"}],
    people[0]["name"],
)

@test_map_of_lists tests @map_of_lists () -> void = run(
    let groups = {"evens": [2, 4, 6], "odds": [1, 3, 5]},
    let evens = groups["evens"],
    assert_eq(actual: evens[0], expected: 2),
)

@map_of_lists () -> int = run(
    let groups = {"evens": [2, 4, 6]},
    groups["evens"][0],
)

@test_tuple_of_maps tests @tuple_of_maps () -> void = run(
    let t = ({"a": 1}, {"b": 2}),
    let (first, second) = t,
    assert_eq(actual: first["a"], expected: 1),
    assert_eq(actual: second["b"], expected: 2),
)

@tuple_of_maps () -> int = run(
    let t = ({"a": 1}, {"b": 2}),
    let (first, second) = t,
    first["a"],
)

// =============================================================================
// Option and Result with Collections
// =============================================================================

@test_option_unwrap_or_list tests @option_unwrap_or_list () -> void = run(
    let opt: Option<[int]> = None,
    let default = opt.unwrap_or(default: [0]),
    assert_eq(actual: default[0], expected: 0),
)

@option_unwrap_or_list () -> int = run(
    let opt: Option<[int]> = None,
    let default = opt.unwrap_or(default: [0]),
    default[0],
)

@test_result_ok_list tests @result_ok_list () -> void = run(
    let r: Result<[int], str> = Ok([1, 2, 3]),
    assert(cond: is_ok(result: r)),
)

@result_ok_list () -> bool = run(
    let r: Result<[int], str> = Ok([1, 2, 3]),
    is_ok(result: r),
)

@test_result_err_list tests @result_err_list () -> void = run(
    let r: Result<[int], str> = Err("failed"),
    assert(cond: is_err(result: r)),
)

@result_err_list () -> bool = run(
    let r: Result<[int], str> = Err("failed"),
    is_err(result: r),
)
