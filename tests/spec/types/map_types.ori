// Spec: 06-types.md ยง Compound Types - Map
// Tests for {K: V} map types and nested maps
//
// TODO: Type checker needs various features
// - Map type annotations: `let m: {str: int} = ...`
// - Map type inference from key-value literals
// - Map indexing returning Option<V>
// - Nested map type inference
// - Map operations (len, is_empty)
// - Map spread syntax (`{...base, "key": value}`)
// - Map iteration (for (k, v) in m)
// - Computed map keys (`{[expr]: value}`)
//
// Uncomment when type checker supports these features.

// use std.testing { assert, assert_eq }
//
// // =============================================================================
// // Basic Map Types
// // =============================================================================
//
// @test_map_str_int tests @map_str_int () -> void = run(
//     let ages: {str: int} = {"alice": 30, "bob": 25, "charlie": 35},
//     assert_eq(actual: ages.len(), expected: 3),
//     // Map indexing returns Option<V>
//     assert_eq(actual: ages["alice"], expected: Some(30)),
//     assert_eq(actual: ages["bob"], expected: Some(25)),
// )
//
// @map_str_int () -> {str: int} = {"alice": 30, "bob": 25, "charlie": 35}
//
// @test_map_str_str tests @map_str_str () -> void = run(
//     let env: {str: str} = {"HOME": "/home/user", "PATH": "/usr/bin"},
//     // Map indexing returns Option<V>
//     assert_eq(actual: env["HOME"], expected: Some("/home/user")),
// )
//
// @map_str_str () -> {str: str} = {"HOME": "/home/user", "PATH": "/usr/bin"}
//
// @test_map_str_bool tests @map_str_bool () -> void = run(
//     let flags: {str: bool} = {"debug": true, "verbose": false, "enabled": true},
//     // Map indexing returns Option<V>, use ?? to unwrap
//     assert(cond: flags["debug"] ?? false),
//     assert(cond: !(flags["verbose"] ?? true)),
// )
//
// @map_str_bool () -> {str: bool} = {"debug": true, "verbose": false, "enabled": true}
//
// @test_map_str_float tests @map_str_float () -> void = run(
//     let scores: {str: float} = {"math": 95.5, "science": 87.3},
//     // Map indexing returns Option<V>, use ?? to unwrap
//     assert(cond: (scores["math"] ?? 0.0) > 95.0),
// )
//
// @map_str_float () -> {str: float} = {"math": 95.5, "science": 87.3}
//
// // =============================================================================
// // Empty Maps
// // =============================================================================
//
// @test_empty_map tests @empty_map () -> void = run(
//     let m: {str: int} = {},
//     assert_eq(actual: m.len(), expected: 0),
//     assert(cond: is_empty(collection: m)),
// )
//
// @empty_map () -> {str: int} = {}
//
// // =============================================================================
// // Single Entry Maps
// // =============================================================================
//
// @test_single_entry tests @single_entry () -> void = run(
//     let m: {str: int} = {"only": 42},
//     assert_eq(actual: m.len(), expected: 1),
//     // Map indexing returns Option<V>
//     assert_eq(actual: m["only"], expected: Some(42)),
// )
//
// @single_entry () -> {str: int} = {"only": 42}
//
// // =============================================================================
// // Maps with Complex Value Types
// // =============================================================================
//
// @test_map_str_list tests @map_str_list () -> void = run(
//     let groups: {str: [int]} = {
//         "evens": [2, 4, 6, 8],
//         "odds": [1, 3, 5, 7],
//     },
//     // Map indexing returns Option<V>, use ?? to unwrap for further operations
//     assert_eq(actual: (groups["evens"] ?? []).len(), expected: 4),
//     assert_eq(actual: (groups["evens"] ?? [])[0], expected: 2),
//     assert_eq(actual: (groups["odds"] ?? [])[0], expected: 1),
// )
//
// @map_str_list () -> {str: [int]} = {
//     "evens": [2, 4, 6, 8],
//     "odds": [1, 3, 5, 7],
// }
//
// @test_map_str_option tests @map_str_option () -> void = run(
//     let data: {str: Option<int>} = {
//         "present": Some(42),
//         "absent": None,
//     },
//     // Map indexing returns Option<V>, so data["present"] is Option<Option<int>>
//     // Use ?? to get the inner Option<int>
//     assert(cond: is_some(opt: data["present"] ?? None)),
//     assert(cond: is_none(opt: data["absent"] ?? Some(0))),
// )
//
// @map_str_option () -> {str: Option<int>} = {
//     "present": Some(42),
//     "absent": None,
// }
//
// @test_map_str_tuple tests @map_str_tuple () -> void = run(
//     let coords: {str: (int, int)} = {
//         "origin": (0, 0),
//         "point": (10, 20),
//     },
//     // Map indexing returns Option<V>, use ?? to unwrap for destructuring
//     let (x, y) = coords["point"] ?? (0, 0),
//     assert_eq(actual: x, expected: 10),
//     assert_eq(actual: y, expected: 20),
// )
//
// @map_str_tuple () -> {str: (int, int)} = {
//     "origin": (0, 0),
//     "point": (10, 20),
// }
//
// // =============================================================================
// // Nested Maps
// // =============================================================================
//
// @test_nested_map tests @nested_map () -> void = run(
//     let config: {str: {str: int}} = {
//         "server": {"port": 8080, "timeout": 30},
//         "client": {"retry": 3, "timeout": 10},
//     },
//     // Map indexing returns Option<V>, unwrap each level
//     let server = config["server"] ?? {},
//     let client = config["client"] ?? {},
//     assert_eq(actual: server["port"], expected: Some(8080)),
//     assert_eq(actual: client["retry"], expected: Some(3)),
// )
//
// @nested_map () -> {str: {str: int}} = {
//     "server": {"port": 8080, "timeout": 30},
//     "client": {"retry": 3, "timeout": 10},
// }
//
// @test_deeply_nested_map tests @deeply_nested_map () -> void = run(
//     let deep: {str: {str: {str: int}}} = {
//         "level1": {
//             "level2": {
//                 "level3": 42,
//             },
//         },
//     },
//     // Map indexing returns Option<V>, unwrap each level
//     let level1 = deep["level1"] ?? {},
//     let level2 = level1["level2"] ?? {},
//     assert_eq(actual: level2["level3"], expected: Some(42)),
// )
//
// @deeply_nested_map () -> {str: {str: {str: int}}} = {
//     "level1": {
//         "level2": {
//             "level3": 42,
//         },
//     },
// }
//
// // =============================================================================
// // Map Operations
// // =============================================================================
//
// @test_map_len tests @map_len () -> void = run(
//     let m = {"a": 1, "b": 2, "c": 3, "d": 4, "e": 5},
//     assert_eq(actual: m.len(), expected: 5),
// )
//
// @map_len () -> int = {"a": 1, "b": 2, "c": 3}.len()
//
// @test_map_is_empty tests @map_is_empty () -> void = run(
//     let empty: {str: int} = {},
//     let nonempty = {"key": 1},
//     assert(cond: is_empty(collection: empty)),
//     assert(cond: !is_empty(collection: nonempty)),
// )
//
// @map_is_empty () -> bool = is_empty(collection: {})
//
// // =============================================================================
// // Map Access Syntax Variants
// // =============================================================================
//
// @test_map_bracket_access tests @map_bracket_access () -> void = run(
//     let m = {"key": 100},
//     // Map indexing returns Option<V>
//     let value = m["key"],
//     assert_eq(actual: value, expected: Some(100)),
// )
//
// @map_bracket_access () -> Option<int> = run(
//     let m = {"key": 100},
//     m["key"],
// )
//
// // =============================================================================
// // Maps in Function Parameters
// // =============================================================================
//
// // Map indexing returns Option<V>
// @lookup (m: {str: int}, key: str) -> Option<int> = m[key]
//
// @test_map_param tests @map_param () -> void = run(
//     let data = {"x": 10, "y": 20},
//     let result = lookup(m: data, key: "x"),
//     assert_eq(actual: result, expected: Some(10)),
// )
//
// @map_param () -> Option<int> = run(
//     let data = {"x": 10, "y": 20},
//     lookup(m: data, key: "x"),
// )
//
// // =============================================================================
// // Maps as Return Types
// // =============================================================================
//
// @make_map (a: int, b: int) -> {str: int} = {"first": a, "second": b}
//
// @test_map_return tests @map_return () -> void = run(
//     let result = make_map(a: 100, b: 200),
//     // Map indexing returns Option<V>
//     assert_eq(actual: result["first"], expected: Some(100)),
//     assert_eq(actual: result["second"], expected: Some(200)),
// )
//
// @map_return () -> {str: int} = make_map(a: 100, b: 200)
//
// // =============================================================================
// // Map Type Inference
// // =============================================================================
//
// @test_inferred_map tests @inferred_map () -> void = run(
//     // Type inferred from key-value pairs
//     let m = {"name": "Alice", "city": "NYC"},
//     // Map indexing returns Option<V>
//     assert_eq(actual: m["name"], expected: Some("Alice")),
// )
//
// @inferred_map () -> Option<str> = run(
//     let m = {"name": "Alice"},
//     m["name"],
// )
//
// @test_inferred_nested_map tests @inferred_nested_map () -> void = run(
//     let m = {"outer": {"inner": 42}},
//     // Map indexing returns Option<V>, unwrap each level
//     let outer = m["outer"] ?? {},
//     assert_eq(actual: outer["inner"], expected: Some(42)),
// )
//
// @inferred_nested_map () -> Option<int> = run(
//     let m = {"outer": {"inner": 42}},
//     let outer = m["outer"] ?? {},
//     outer["inner"],
// )
//
// // =============================================================================
// // Map with Computed Keys
// // =============================================================================
//
// #skip("computed map keys not hashable - evaluator issue")
// @test_computed_key tests @computed_key () -> void = run(
//     let key = "dynamic",
//     let m = {[key]: 999},
//     // Map indexing returns Option<V>
//     assert_eq(actual: m["dynamic"], expected: Some(999)),
// )
//
// @computed_key () -> Option<int> = run(
//     let key = "dynamic",
//     let m = {[key]: 999},
//     m["dynamic"],
// )
//
// // =============================================================================
// // Map Spread
// // =============================================================================
// //
// // STATUS: Lexer [OK], Parser [OK], Evaluator [BROKEN] - Option comparison issue
// // Map spread works but test comparison with Option fails.
//
// #skip("Option to int comparison issue in test")
// @test_map_spread tests @map_spread () -> void = run(
//     let base = {"a": 1, "b": 2},
//     let extended = {...base, "c": 3},
//     assert_eq(actual: extended["a"], expected: 1),
//     assert_eq(actual: extended["c"], expected: 3),
// )
//
// @map_spread () -> {str: int} = run(
//     let base = {"a": 1},
//     {...base, "b": 2},
// )
//
// #skip("Option to int comparison issue in test")
// @test_map_spread_override tests @map_spread_override () -> void = run(
//     let base = {"x": 1, "y": 2},
//     let updated = {...base, "x": 100},
//     // Later value wins
//     assert_eq(actual: updated["x"], expected: 100),
//     assert_eq(actual: updated["y"], expected: 2),
// )
//
// @map_spread_override () -> {str: int} = run(
//     let base = {"x": 1},
//     {...base, "x": 100},
// )
//
// // =============================================================================
// // Map Iteration
// // =============================================================================
// //
// // STATUS: Lexer [OK], Parser [BROKEN] - tuple destructuring in for loop not supported
// // Parser misinterprets 'for (k, v) in m' as for(...) pattern syntax.
// // Workaround: use .values() or .entries() with single variable.
//
// // SKIP: Tuple destructuring in for loop not supported
// // for (k, v) in m do ...
// @map_iteration () -> int = run(
//     let m = {"a": 1, "b": 2, "c": 3},
//     m.values().fold(initial: 0, op: (acc, v) -> acc + v),
// )
//
// #skip("tuple destructuring in for loop (for (k, v) in m) not implemented")
// @test_map_iteration tests @map_iteration () -> void = run(
//     let m = {"a": 1, "b": 2, "c": 3},
//     let sum = map_iteration(),
//     assert_eq(actual: sum, expected: 6),
// )
