// Spec: 06-types.md ยง Compound Types - Fixed-Capacity List
// Tests for [T, max N] fixed-capacity lists
//
// STATUS: Lexer [OK], Parser [OK] - fixed-capacity list type syntax supported
// Parser now recognizes [T, max N] and [T, max $N] fixed-capacity list types.

use std.testing { assert, assert_eq }

// =============================================================================
// Basic Fixed-Capacity List Declaration
// =============================================================================

// NOTE: Fixed-capacity lists may not be fully implemented.
// These tests are designed to expose missing features.

@test_fixed_list_empty tests @fixed_list_empty () -> void = run(
    let buffer: [int, max 10] = [],
    assert_eq(actual: buffer.len(), expected: 0),
    // assert_eq(actual: buffer.capacity(), expected: 10),
)

@fixed_list_empty () -> [int, max 10] = []

@test_fixed_list_partial tests @fixed_list_partial () -> void = run(
    let buffer: [int, max 10] = [1, 2, 3],
    assert_eq(actual: buffer.len(), expected: 3),
    // assert_eq(actual: buffer.capacity(), expected: 10),
    // assert(cond: !buffer.is_full()),
)

@fixed_list_partial () -> [int, max 10] = [1, 2, 3]

@test_fixed_list_full tests @fixed_list_full () -> void = run(
    let buffer: [int, max 3] = [1, 2, 3],
    assert_eq(actual: buffer.len(), expected: 3),
    // assert(cond: buffer.is_full()),
)

@fixed_list_full () -> [int, max 3] = [1, 2, 3]

// =============================================================================
// Fixed-Capacity with Different Types
// =============================================================================

@test_fixed_str tests @fixed_str () -> void = run(
    let names: [str, max 5] = ["alice", "bob"],
    assert_eq(actual: names.len(), expected: 2),
    assert_eq(actual: names[0], expected: "alice"),
)

@fixed_str () -> [str, max 5] = ["alice", "bob"]

@test_fixed_bool tests @fixed_bool () -> void = run(
    let flags: [bool, max 4] = [true, false, true],
    assert_eq(actual: flags.len(), expected: 3),
    assert(cond: flags[0]),
)

@fixed_bool () -> [bool, max 4] = [true, false, true]

// =============================================================================
// Fixed-Capacity Methods
// =============================================================================

// NOTE: These methods may not be implemented yet.
// Uncomment when available.

// @test_capacity tests @capacity () -> void = run(
//     let buffer: [int, max 100] = [1, 2, 3],
//     assert_eq(actual: buffer.capacity(), expected: 100),
// )

// @capacity () -> int = run(
//     let buffer: [int, max 100] = [],
//     buffer.capacity(),
// )

// @test_is_full tests @is_full () -> void = run(
//     let full: [int, max 2] = [1, 2],
//     let partial: [int, max 10] = [1, 2],
//     assert(cond: full.is_full()),
//     assert(cond: !partial.is_full()),
// )

// @is_full () -> bool = run(
//     let buffer: [int, max 2] = [1, 2],
//     buffer.is_full(),
// )

// @test_remaining tests @remaining () -> void = run(
//     let buffer: [int, max 10] = [1, 2, 3],
//     assert_eq(actual: buffer.remaining(), expected: 7),
// )

// @remaining () -> int = run(
//     let buffer: [int, max 10] = [1, 2, 3],
//     buffer.remaining(),
// )

// =============================================================================
// Fixed-Capacity Push Operations
// =============================================================================

// @test_push tests @push () -> void = run(
//     let buffer: [int, max 5] = [1, 2],
//     buffer.push(item: 3),
//     assert_eq(actual: buffer.len(), expected: 3),
//     assert_eq(actual: buffer[2], expected: 3),
// )

// @push () -> [int, max 5] = run(
//     let buffer: [int, max 5] = [1, 2],
//     buffer.push(item: 3),
//     buffer,
// )

// @test_try_push tests @try_push () -> void = run(
//     let buffer: [int, max 2] = [1, 2],
//     let success = buffer.try_push(item: 3),
//     assert(cond: !success),
//     assert_eq(actual: buffer.len(), expected: 2),
// )

// @try_push () -> bool = run(
//     let buffer: [int, max 2] = [1, 2],
//     buffer.try_push(item: 3),
// )

// @test_push_or_drop tests @push_or_drop () -> void = run(
//     let buffer: [int, max 2] = [1, 2],
//     buffer.push_or_drop(item: 3),
//     // Item dropped, length unchanged
//     assert_eq(actual: buffer.len(), expected: 2),
// )

// @push_or_drop () -> [int, max 2] = run(
//     let buffer: [int, max 2] = [1, 2],
//     buffer.push_or_drop(item: 3),
//     buffer,
// )

// @test_push_or_oldest tests @push_or_oldest () -> void = run(
//     let buffer: [int, max 2] = [1, 2],
//     buffer.push_or_oldest(item: 3),
//     // First element removed, new element added
//     assert_eq(actual: buffer.len(), expected: 2),
//     assert_eq(actual: buffer[0], expected: 2),
//     assert_eq(actual: buffer[1], expected: 3),
// )

// @push_or_oldest () -> [int, max 2] = run(
//     let buffer: [int, max 2] = [1, 2],
//     buffer.push_or_oldest(item: 3),
//     buffer,
// )

// =============================================================================
// Conversion Between Fixed and Dynamic
// =============================================================================

// @test_to_dynamic tests @to_dynamic () -> void = run(
//     let fixed: [int, max 5] = [1, 2, 3],
//     let dynamic: [int] = fixed.to_dynamic(),
//     assert_eq(actual: dynamic.len(), expected: 3),
//     assert_eq(actual: dynamic[0], expected: 1),
// )

// @to_dynamic () -> [int] = run(
//     let fixed: [int, max 5] = [1, 2, 3],
//     fixed.to_dynamic(),
// )

// @test_to_fixed tests @to_fixed () -> void = run(
//     let dynamic: [int] = [1, 2, 3],
//     let fixed: [int, max 10] = dynamic.to_fixed<10>(),
//     assert_eq(actual: fixed.len(), expected: 3),
// )

// @to_fixed () -> [int, max 10] = run(
//     let dynamic: [int] = [1, 2, 3],
//     dynamic.to_fixed<10>(),
// )

// @test_try_to_fixed tests @try_to_fixed () -> void = run(
//     let dynamic: [int] = [1, 2, 3, 4, 5],
//     let maybe_fixed: Option<[int, max 3]> = dynamic.try_to_fixed<3>(),
//     assert(cond: is_none(opt: maybe_fixed)),
// )

// @try_to_fixed () -> Option<[int, max 3]> = run(
//     let dynamic: [int] = [1, 2, 3, 4, 5],
//     dynamic.try_to_fixed<3>(),
// )

// =============================================================================
// Fixed-Capacity Subtype Relationship
// =============================================================================

// [T, max N] <: [T]
// Fixed-capacity can be passed where dynamic is expected

@accepts_dynamic (items: [int]) -> int = items.len()

@test_fixed_as_dynamic tests @fixed_as_dynamic () -> void = run(
    let fixed: [int, max 5] = [1, 2, 3],
    let result = accepts_dynamic(items: fixed),
    assert_eq(actual: result, expected: 3),
)

@fixed_as_dynamic () -> int = run(
    let fixed: [int, max 5] = [1, 2, 3],
    accepts_dynamic(items: fixed),
)

// =============================================================================
// Fixed-Capacity Index Access
// =============================================================================

@test_fixed_index tests @fixed_index () -> void = run(
    let buffer: [int, max 10] = [10, 20, 30],
    assert_eq(actual: buffer[0], expected: 10),
    assert_eq(actual: buffer[1], expected: 20),
    assert_eq(actual: buffer[2], expected: 30),
)

@fixed_index () -> int = run(
    let buffer: [int, max 10] = [10, 20, 30],
    buffer[1],
)

@test_fixed_index_last tests @fixed_index_last () -> void = run(
    let buffer: [int, max 10] = [10, 20, 30],
    assert_eq(actual: buffer[# - 1], expected: 30),
)

@fixed_index_last () -> int = run(
    let buffer: [int, max 10] = [10, 20, 30],
    buffer[# - 1],
)

// =============================================================================
// Fixed-Capacity Iteration
// =============================================================================

@test_fixed_iter tests @fixed_iter () -> void = run(
    let buffer: [int, max 5] = [1, 2, 3],
    let sum = 0,
    for x in buffer do sum = sum + x,
    assert_eq(actual: sum, expected: 6),
)

@fixed_iter () -> int = run(
    let buffer: [int, max 5] = [1, 2, 3],
    let sum = 0,
    for x in buffer do sum = sum + x,
    sum,
)

// =============================================================================
// Const Generic Capacity (via type parameter)
// =============================================================================

// type RingBuffer<T, $N: int> = {
//     data: [T, max N],
//     head: int,
//     tail: int,
// }

// @test_ring_buffer tests @ring_buffer () -> void = run(
//     let rb: RingBuffer<int, 5> = RingBuffer {
//         data: [0, 0, 0, 0, 0],
//         head: 0,
//         tail: 0,
//     },
//     assert_eq(actual: rb.data.capacity(), expected: 5),
// )

// @ring_buffer () -> RingBuffer<int, 5> = RingBuffer {
//     data: [0, 0, 0, 0, 0],
//     head: 0,
//     tail: 0,
// }

// =============================================================================
// Fallback: Basic fixed list as dynamic
// =============================================================================

// Until fixed-capacity is fully implemented, verify it at least
// can be used as a dynamic list

@test_fixed_basic_usage tests @fixed_basic_usage () -> void = run(
    let items: [int, max 10] = [5, 10, 15],
    assert_eq(actual: items.len(), expected: 3),
    assert_eq(actual: items[0], expected: 5),
)

@fixed_basic_usage () -> int = run(
    let items: [int, max 10] = [5, 10, 15],
    items[0] + items[1] + items[2],
)
