// Spec: 06-types.md ยง Compound Types
// Design: 03-type-system/05-type-inference.md ยง Collection Element Inference

// =============================================================================
// List Type Inference
// =============================================================================

@test_list_int tests @list_int () -> void = run(
    let nums = [1, 2, 3],
    assert_eq(
        actual: nums[0],
        expected: 1,
    ),
    assert_eq(
        actual: len(collection: nums),
        expected: 3,
    ),
)

@list_int () -> int = [1, 2, 3][0]

@test_list_str tests @list_str () -> void = run(
    let strs = ["a", "b", "c"],
    assert_eq(
        actual: strs[0],
        expected: "a",
    ),
    assert_eq(
        actual: len(collection: strs),
        expected: 3,
    ),
)

@list_str () -> str = ["a", "b", "c"][0]

@test_list_bool tests @list_bool () -> void = run(
    let bools = [true, false, true],
    assert(cond: bools[0]),
    assert(cond: !bools[1]),
)

@list_bool () -> bool = [true, false, true][0]

@test_list_nested tests @list_nested () -> void = run(
    let nested = [[1, 2], [3, 4], [5, 6]],
    assert_eq(
        actual: nested[0][0],
        expected: 1,
    ),
    assert_eq(
        actual: nested[1][1],
        expected: 4,
    ),
)

@list_nested () -> int = [[1, 2], [3, 4]][0][0]

@test_list_empty_annotated tests @list_empty_annotated () -> void = run(
    let empty: [int] = [],
    assert_eq(
        actual: len(collection: empty),
        expected: 0,
    ),
)

@list_empty_annotated () -> int = run(
    let empty: [int] = [],
    len(collection: empty),
)

// =============================================================================
// Tuple Type Inference
// =============================================================================

@test_tuple_pair tests @tuple_pair () -> void = run(
    let pair = (1, "hello"),
    let (a, b) = pair,
    assert_eq(
        actual: a,
        expected: 1,
    ),
    assert_eq(
        actual: b,
        expected: "hello",
    ),
)

@tuple_pair () -> int = run(
    let pair = (1, "hello"),
    let (a, b) = pair,
    a,
)

@test_tuple_triple tests @tuple_triple () -> void = run(
    let triple = (1, "two", true),
    let (a, b, c) = triple,
    assert_eq(
        actual: a,
        expected: 1,
    ),
    assert_eq(
        actual: b,
        expected: "two",
    ),
    assert(cond: c),
)

@tuple_triple () -> int = run(
    let triple = (1, "two", true),
    let (a, b, c) = triple,
    a,
)

@test_tuple_nested tests @tuple_nested () -> void = run(
    let nested = ((1, 2), (3, 4)),
    let (left, right) = nested,
    let (a, b) = left,
    assert_eq(
        actual: a,
        expected: 1,
    ),
)

@tuple_nested () -> int = run(
    let nested = ((1, 2), (3, 4)),
    let (left, right) = nested,
    let (a, b) = left,
    a,
)

// =============================================================================
// Mixed Collection Inference
// =============================================================================

@test_list_of_tuples tests @list_of_tuples () -> void = run(
    let pairs = [(1, "a"), (2, "b"), (3, "c")],
    let (num, letter) = pairs[0],
    assert_eq(
        actual: num,
        expected: 1,
    ),
    assert_eq(
        actual: letter,
        expected: "a",
    ),
)

@list_of_tuples () -> int = run(
    let pairs = [(1, "a"), (2, "b")],
    let (num, letter) = pairs[0],
    num,
)

@test_option_of_list tests @option_of_list () -> void = run(
    let opt = Some([1, 2, 3]),
    assert(cond: is_some(opt: opt)),
)

@option_of_list () -> bool = run(
    let opt = Some([1, 2, 3]),
    is_some(opt: opt),
)

@test_list_of_options tests @list_of_options () -> void = run(
    let opts = [Some(1), None, Some(3)],
    let first = opts[0],
    assert(cond: is_some(opt: first)),
)

@list_of_options () -> bool = run(
    let opts = [Some(1), None, Some(3)],
    is_some(opt: opts[0]),
)
