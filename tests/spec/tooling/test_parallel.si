// Spec: spec/13-testing.md § Test Isolation
// Design: design/11-testing/index.md § Overview
//
// Tests for parallel test execution.
// The test runner executes tests in parallel by default (using rayon).
// Use --no-parallel to run sequentially.
//
// These tests validate that parallel execution works correctly by ensuring
// tests can run independently without interfering with each other.

// =============================================================================
// Independent helper functions (no shared state)
// =============================================================================

@compute_a (x: int) -> int = x * 2 + 1

@compute_b (x: int) -> int = x * 3 - 1

@compute_c (x: int) -> int = x * x

// =============================================================================
// Test: Independent computation A
// Spec: spec/13-testing.md § Test Isolation
// These tests can run in parallel without interference
// =============================================================================
@test_compute_a tests @compute_a () -> void = run(
    assert_eq(compute_a(0), 1),
    assert_eq(compute_a(5), 11),
    assert_eq(compute_a(10), 21),
)

// =============================================================================
// Test: Independent computation B
// Spec: spec/13-testing.md § Test Isolation
// =============================================================================
@test_compute_b tests @compute_b () -> void = run(
    assert_eq(compute_b(0), -1),
    assert_eq(compute_b(5), 14),
    assert_eq(compute_b(10), 29),
)

// =============================================================================
// Test: Independent computation C
// Spec: spec/13-testing.md § Test Isolation
// =============================================================================
@test_compute_c tests @compute_c () -> void = run(
    assert_eq(compute_c(0), 0),
    assert_eq(compute_c(5), 25),
    assert_eq(compute_c(10), 100),
)
