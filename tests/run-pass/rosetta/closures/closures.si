// Rosetta Code: Closures/Value capture
// Task: Demonstrate closures capturing values from enclosing scope
// Sigil uses lambda expressions: x -> expr

// Create an adder function that captures a value
@make_adder (n: int) -> (int -> int) = x -> x + n

// Create a multiplier that captures a value
@make_multiplier (n: int) -> (int -> int) = x -> x * n

// Demonstrate closure capturing in map
// Each lambda captures the 'factor' value
@scale_list (arr: [int], factor: int) -> [int] = map(
    .over: arr,
    .transform: x -> x * factor
)

// Create a list of closures, each capturing a different value
// Returns a list where each element is i squared
@create_square_closures (n: int) -> [int] = map(
    .over: collect(0..n, i -> i),
    .transform: i -> i * i
)

// Closure capturing multiple values
@make_linear (m: int, b: int) -> (int -> int) = x -> m * x + b

// Using closures with filter - capture threshold
@filter_above (arr: [int], threshold: int) -> [int] = filter(
    .over: arr,
    .predicate: x -> x > threshold
)

// Closure in fold - capture an offset
@sum_with_offset (arr: [int], offset: int) -> int = fold(
    .over: arr,
    .init: offset,
    .op: (acc, x) -> acc + x
)

@main () -> void = run(
    add5 := make_adder(5),
    print("add5(10) = " + str(add5(10))),

    times3 := make_multiplier(3),
    print("times3(7) = " + str(times3(7))),

    print("scale_list([1,2,3], 10) = " + str(scale_list([1, 2, 3], 10))),
    print("create_square_closures(5) = " + str(create_square_closures(5))),

    line := make_linear(2, 3),
    print("line(5) = 2*5+3 = " + str(line(5))),

    print("filter_above([1,5,3,8,2], 3) = " + str(filter_above([1, 5, 3, 8, 2], 3))),
    print("sum_with_offset([1,2,3], 100) = " + str(sum_with_offset([1, 2, 3], 100)))
)
