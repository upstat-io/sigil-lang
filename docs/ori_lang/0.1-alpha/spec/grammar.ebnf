// ============================================================================
// Ori Language Grammar
// Version: 0.1-alpha
//
// This is the unified formal grammar for the Ori programming language.
// All productions are authoritative and take precedence over prose descriptions.
//
// Notation:
//   production = expression .     Production definition
//   "keyword"                     Literal token
//   |                             Alternation
//   [ ]                           Optional (0 or 1)
//   { }                           Repetition (0 or more)
//   ( )                           Grouping
//   /* comment */                 Informative note
//
// Cross-references to detailed explanations are provided in comments.
// ============================================================================


// ============================================================================
// LEXICAL GRAMMAR
// See: 02-source-code.md, 03-lexical-elements.md
// ============================================================================

// --- Characters ---

unicode_char  = /* any Unicode code point except NUL (U+0000) */ .
letter        = 'A' … 'Z' | 'a' … 'z' .
digit         = '0' … '9' .
hex_digit     = digit | 'A' … 'F' | 'a' … 'f' .
newline       = /* U+000A */ .
whitespace    = ' ' | '\t' | '\r' | newline .

// --- Tokens ---

token = identifier | keyword | literal | operator | delimiter .

// --- Comments ---
// See: 03-lexical-elements.md § Comments

comment      = "//" { unicode_char - newline } newline .
doc_comment  = "//" [ " " ] [ doc_marker ] { unicode_char - newline } newline .
doc_marker   = "*" | "!" | ">" .
member_doc   = "//" " " "*" " " identifier ":" [ " " { unicode_char - newline } ] .
warning_doc  = "//" " " "!" " " { unicode_char - newline } .
example_doc  = "//" " " ">" " " { unicode_char - newline } .

// --- Identifiers ---
// See: 03-lexical-elements.md § Identifiers

identifier = ( letter | "_" ) { letter | digit | "_" } .

// --- Keywords ---
// See: 03-lexical-elements.md § Keywords
// Reserved: async, break, continue, def, do, else, extern, false, for, if, impl, in, let,
//           loop, match, pub, self, Self, then, trait, true, type, unsafe, use,
//           uses, void, where, with, yield
// Context-sensitive (patterns): cache, catch, for, match, nursery, parallel,
//           recurse, run, spawn, timeout, try, with
// Context-sensitive (imports): without (only in import items, before "def")
// Context-sensitive (other): by (only after range expressions)
// Context-sensitive (type conversion, call position): int, float, str, byte

// --- Operators ---
// See: 03-lexical-elements.md § Operators

arith_op  = "+" | "-" | "*" | "/" | "%" | "div" .
comp_op   = "==" | "!=" | "<" | ">" | "<=" | ">=" .
logic_op  = "&&" | "||" | "!" .
bit_op    = "&" | "|" | "^" | "~" | "<<" | ">>" .
unary_op  = "!" | "-" | "~" .
other_op  = ".." | "..=" | "??" | "?" | "->" | "=>" .

// --- Delimiters ---

delimiter = "(" | ")" | "[" | "]" | "{" | "}"
          | "," | ":" | "." | "@" | "$" .

// --- Literals ---
// See: 03-lexical-elements.md § Literals

literal = int_literal | float_literal | string_literal | template_literal | char_literal
        | bool_literal | duration_literal | size_literal .

// Integer literals
int_literal = decimal_lit | hex_lit .
decimal_lit = digit { digit | "_" } .
hex_lit     = "0x" hex_digit { hex_digit | "_" } .

// Float literals
float_literal = decimal_lit "." decimal_lit [ exponent ] .
exponent      = ( "e" | "E" ) [ "+" | "-" ] decimal_lit .

// String literals
string_literal = '"' { string_char } '"' .
string_char    = unicode_char - ( '"' | '\' | newline ) | escape .
escape         = '\' ( '"' | '\' | 'n' | 't' | 'r' | '0' ) .

// Template string literals (with interpolation)
template_literal = '`' { template_char | template_escape | template_brace | interpolation } '`' .
template_char    = unicode_char - ( '`' | '\' | '{' | '}' ) .
template_escape  = '\' ( '`' | '\' | 'n' | 't' | 'r' | '0' ) .
template_brace   = "{{" | "}}" .
interpolation    = '{' expression [ ':' format_spec ] '}' .

// Format specifiers for template strings
format_spec      = [ [ fill ] align ] [ width ] [ '.' precision ] [ format_type ] .
fill             = unicode_char - align .
align            = '<' | '>' | '^' .
width            = decimal_lit .
precision        = decimal_lit .
format_type      = 'b' | 'x' | 'X' | 'o' | 'e' | 'E' .

// Character literals
char_literal = "'" char_char "'" .
char_char    = unicode_char - ( "'" | '\' | newline ) | char_escape .
char_escape  = '\' ( "'" | '\' | 'n' | 't' | 'r' | '0' ) .

// Boolean literals
bool_literal = "true" | "false" .

// Duration literals
duration_literal = int_literal duration_unit .
duration_unit    = "ns" | "us" | "ms" | "s" | "m" | "h" .

// Size literals
size_literal = int_literal size_unit .
size_unit    = "b" | "kb" | "mb" | "gb" | "tb" .


// ============================================================================
// SOURCE STRUCTURE
// See: 02-source-code.md, 12-modules.md
// ============================================================================

source_file = [ file_attribute ] { import } { declaration } .

// File-level attribute (conditional compilation)
// See: 24-conditional-compilation.md § File-Level Conditions
file_attribute = "#!" identifier "(" [ attribute_arg { "," attribute_arg } ] ")" .

// --- Imports ---
// See: 12-modules.md § Imports

import      = "use" import_path [ import_list | "as" identifier ] .
import_path = string_literal | identifier { "." identifier } .
import_list = "{" import_item { "," import_item } "}" .
import_item = [ "::" ] identifier [ "without" "def" ] [ "as" identifier ] | "$" identifier .

// --- Re-exports ---

reexport = "pub" "use" import_path import_list .

// --- Extensions ---
// See: 12-modules.md § Extensions

extension_def    = "extend" identifier [ where_clause ] "{" { method } "}" .
extension_import = "extension" import_path "{" extension_item { "," extension_item } "}" .
extension_item   = identifier "." identifier .

// --- FFI (Foreign Function Interface) ---
// See: spec/23-ffi.md

extern_block = [ "pub" ] "extern" string_literal [ "from" string_literal ] "{" { extern_item } "}" .
extern_item  = "@" identifier params "->" type [ "as" string_literal ] .


// ============================================================================
// DECLARATIONS
// See: 08-declarations.md
// ============================================================================

declaration = { attribute } [ "pub" ] ( function | type_def | trait_def | impl_block | test | constant_decl | extern_block ) .

// --- Attributes ---
// See: 08-declarations.md § Attributes, 24-conditional-compilation.md
// Item-level: #derive(...), #skip(...), #target(...), #cfg(...)

attribute      = "#" identifier [ "(" [ attribute_arg { "," attribute_arg } ] ")" ] .
attribute_arg  = expression | identifier ":" expression | array_literal .
array_literal  = "[" [ string_literal { "," string_literal } ] "]" .

// --- Functions ---
// See: 08-declarations.md § Functions

function      = "@" identifier [ generics ] clause_params "->" type [ uses_clause ] [ where_clause ] [ guard_clause ] "=" expression .
clause_params = "(" [ clause_param { "," clause_param } ] ")" .
clause_param  = match_pattern [ ":" type ] [ "=" expression ] .  /* pattern with optional type and default */
guard_clause  = "if" expression .

// --- Generics ---
// See: 06-types.md § Const Generic Parameters

generics      = "<" generic_param { "," generic_param } ">" .
generic_param = type_param | const_param .
type_param    = identifier [ ":" bounds ] [ "=" type ] .
const_param   = "$" identifier ":" const_type [ "=" const_expr ] .
const_type    = "int" | "bool" .
bounds        = type_path { "+" type_path } .
where_clause  = "where" constraint { "," constraint } .
constraint    = type_constraint | const_constraint .
type_constraint = identifier ":" bounds .
const_constraint = const_bound_expr .

// Const bound expressions (for where clauses)
// See: 06-types.md § Const Bounds
const_bound_expr = const_or_expr .
const_or_expr    = const_and_expr { "||" const_and_expr } .
const_and_expr   = const_not_expr { "&&" const_not_expr } .
const_not_expr   = "!" const_not_expr | const_cmp_expr .
const_cmp_expr   = const_expr comparison_op const_expr
                 | "(" const_bound_expr ")" .
comparison_op    = ">" | "<" | ">=" | "<=" | "==" | "!=" .

// --- Capabilities ---
// See: 14-capabilities.md

uses_clause = "uses" identifier { "," identifier } .

// --- Type Definitions ---
// See: 08-declarations.md § Types, 06-types.md § User-Defined Types

type_def    = "type" identifier [ generics ] [ where_clause ] "=" type_body .
type_body   = struct_body | sum_body | type .
struct_body = "{" [ field { "," field } ] "}" .
sum_body    = variant { "|" variant } .
variant     = identifier [ "(" [ field { "," field } ] ")" ] .
field       = identifier ":" type .

// --- Traits ---
// See: 08-declarations.md § Traits

trait_def      = "trait" identifier [ generics ] [ ":" bounds ] "{" { trait_item } "}" .
trait_item     = method_sig | default_method | assoc_type .
method_sig     = "@" identifier params "->" type .
default_method = method_sig "=" expression .
assoc_type     = "type" identifier [ ":" bounds ] [ "=" type ] .
params         = "(" [ param { "," param } ] ")" .
param          = identifier ":" type .

// --- Implementations ---
// See: 08-declarations.md § Implementations

impl_block    = inherent_impl | trait_impl | def_impl .
inherent_impl = "impl" [ generics ] type_path [ where_clause ] "{" { method } "}" .
trait_impl    = "impl" [ generics ] type_path "for" type [ where_clause ] "{" { method } "}" .
def_impl      = "def" "impl" identifier "{" { def_impl_method } "}" .
method        = "@" identifier params "->" type [ uses_clause ] "=" expression .
def_impl_method = "@" identifier params "->" type "=" expression .  /* no self, no uses */

// --- Tests ---
// See: 13-testing.md

test         = "@" identifier "tests" test_targets "()" "->" "void" "=" expression .
test_targets = "_" | test_target { "tests" test_target } .
test_target  = "@" identifier .

// --- Constants (Immutable Bindings) ---
// See: 04-constants.md

constant_decl = "let" "$" identifier [ ":" type ] "=" expression .


// ============================================================================
// TYPES
// See: 06-types.md
// ============================================================================

type          = type_path [ type_args ]
              | list_type | fixed_list_type | map_type | tuple_type | function_type .
type_path     = identifier { "." identifier } .
type_args     = "<" type_or_const { "," type_or_const } ">" .
type_or_const = type | const_expr .
list_type     = "[" type "]" .
fixed_list_type = "[" type "," "max" const_expr "]" .
map_type      = "{" type ":" type "}" .
tuple_type    = "(" type { "," type } ")" | "()" .
function_type = "(" [ type { "," type } ] ")" "->" type .
const_expr    = integer_literal | "$" identifier | const_expr binary_op const_expr .


// ============================================================================
// EXPRESSIONS
// See: 09-expressions.md
// ============================================================================

expression = with_expr | let_expr | if_expr | for_expr | loop_expr | lambda | break_expr | continue_expr | unsafe_expr | binary_expr .

// --- Primary Expressions ---

primary       = literal | identifier | "self" | "Self"
              | "(" expression ")"
              | "#"                                   /* length in index context */
              | list_literal | map_literal | struct_literal
              | pattern_expr                          /* run, try, match, parallel, etc. */
              | unsafe_expr .

// --- Unsafe Expression ---
// See: spec/23-ffi.md § Unsafe Blocks

unsafe_expr = "unsafe" "{" expression "}" .

// List literals with spread support
// See: 09-expressions.md § Spread Operator
list_literal   = "[" [ list_element { "," list_element } ] "]" .
list_element   = "..." expression | expression .

// Map literals with spread support
// See: computed-map-keys-proposal.md for key semantics
map_literal    = "{" [ map_element { "," map_element } ] "}" .
map_element    = "..." expression | map_entry .
map_entry      = map_key ":" expression .
map_key        = "[" expression "]"       /* computed key: evaluates expression */
               | identifier               /* literal string key: "foo" from foo */
               | string_literal .         /* literal string key */

// Struct literals with spread support
struct_literal  = type_path "{" [ struct_element { "," struct_element } ] "}" .
struct_element  = "..." expression | field_init .
field_init      = identifier [ ":" expression ] .

// --- Postfix Expressions ---
// See: 09-expressions.md § Postfix Expressions

postfix_expr   = primary { postfix_op } .
postfix_op     = "." identifier [ call_args ]        /* field/method access */
               | "[" expression "]"                  /* index access */
               | call_args                           /* function call */
               | "?"                                 /* error propagation */
               | "as" type                           /* infallible type conversion */
               | "as?" type .                        /* fallible type conversion */
call_args      = "(" [ call_arg { "," call_arg } ] ")" .
call_arg       = named_arg | positional_arg .
named_arg      = identifier ":" expression .
positional_arg = expression .

// --- Unary Expressions ---
// See: 09-expressions.md § Unary Expressions

unary_expr = [ "!" | "-" | "~" ] postfix_expr .

// --- Binary Expressions ---
// See: 09-expressions.md § Binary Expressions
// Precedence (lowest to highest): ||, &&, |, ^, &, ==, cmp, range, shift, add, mul

binary_expr   = coalesce_expr .
coalesce_expr = or_expr { "??" or_expr } .
or_expr       = and_expr { "||" and_expr } .
and_expr      = bit_or_expr { "&&" bit_or_expr } .
bit_or_expr   = bit_xor_expr { "|" bit_xor_expr } .
bit_xor_expr  = bit_and_expr { "^" bit_and_expr } .
bit_and_expr  = eq_expr { "&" eq_expr } .
eq_expr       = cmp_expr { ( "==" | "!=" ) cmp_expr } .
cmp_expr      = range_expr { ( "<" | ">" | "<=" | ">=" ) range_expr } .
range_expr    = shift_expr [ ( ".." | "..=" ) [ shift_expr ] [ "by" shift_expr ] ] .
shift_expr    = add_expr { ( "<<" | ">>" ) add_expr } .
add_expr      = mul_expr { ( "+" | "-" ) mul_expr } .
mul_expr      = unary_expr { ( "*" | "/" | "%" | "div" ) unary_expr } .

// --- With Expression ---
// See: 09-expressions.md § With Expression, 14-capabilities.md § Providing Capabilities

with_expr           = "with" capability_binding { "," capability_binding } "in" expression .
capability_binding  = identifier "=" expression .

// --- Let Binding ---
// See: 09-expressions.md § Let Binding, 05-variables.md

let_expr = "let" binding_pattern [ ":" type ] "=" expression .
assignment = identifier "=" expression .
binding  = let_expr | assignment .  /* used in run/try patterns */

// --- Conditional ---
// See: 09-expressions.md § Conditional

if_expr = "if" expression "then" expression
          { "else" "if" expression "then" expression }
          [ "else" expression ] .

// --- For Expression ---
// See: 09-expressions.md § For Expression, 19-control-flow.md § Labeled Loops

for_expr = "for" [ label ] identifier "in" expression [ "if" expression ] ( "do" | "yield" ) expression .

// --- Loop Expression ---
// See: 09-expressions.md § Loop Expression, 19-control-flow.md § Labeled Loops

loop_expr = "loop" [ label ] "(" expression ")" .

// --- Labels ---
// See: 19-control-flow.md § Labeled Loops
label = ":" identifier .  /* no space around colon */

// --- Lambda ---
// See: 09-expressions.md § Lambda

lambda        = simple_lambda | typed_lambda .
simple_lambda = lambda_params "->" expression .
typed_lambda  = "(" [ typed_param { "," typed_param } ] ")" "->" type "=" expression .
lambda_params = identifier | "(" [ identifier { "," identifier } ] ")" .
typed_param   = identifier ":" type .

// --- Control Flow ---
// See: 19-control-flow.md

break_expr    = "break" [ label ] [ expression ] .
continue_expr = "continue" [ label ] [ expression ] .


// ============================================================================
// PATTERNS (COMPILER CONSTRUCTS)
// See: 10-patterns.md
// ============================================================================

// --- Pattern Categories ---

pattern_expr = function_seq | function_exp | function_val | channel_expr .
function_seq = run_expr | try_expr | match_expr | for_pattern | catch_expr | nursery_expr .
function_exp = pattern_name "(" pattern_arg { "," pattern_arg } ")" .
pattern_name = "recurse" | "parallel" | "spawn" | "timeout" | "cache" | "with" .  /* nursery has explicit nursery_expr */
pattern_arg  = identifier ":" expression .

// Type conversion patterns (call position only)
function_val = ( "int" | "float" | "str" | "byte" ) "(" expression ")" .

// --- Sequential Patterns ---

// run: Sequential expressions with optional pre/post checks
// See: 10-patterns.md § run
run_expr        = "run" "(" [ run_prechecks ] { binding "," } expression [ run_postchecks ] ")" .
run_prechecks   = { "pre_check" ":" check_expr "," } .
run_postchecks  = { "," "post_check" ":" postcheck_expr } .
check_expr      = expression [ "|" string_literal ] .
postcheck_expr  = lambda_params "->" check_expr .

// try: Error-propagating sequence (returns early on Err)
try_expr = "try" "(" { binding "," } expression ")" .

// match: Pattern matching
match_expr = "match" "(" expression "," match_arm { "," match_arm } ")" .
match_arm  = match_pattern [ guard ] "->" expression .
guard      = ".match" "(" expression ")" .

// for pattern: First-match iteration
// See: 10-patterns.md § for Pattern
for_pattern = "for" "(" for_pattern_args ")" .
for_pattern_args = "over" ":" expression "," "match" ":" match_pattern "->" expression "," "default" ":" expression
                 | "over" ":" expression "," "map" ":" expression "," "match" ":" match_pattern "->" expression "," "default" ":" expression .

// catch: Panic recovery
// See: 20-errors-and-panics.md § Catching Panics
catch_expr = "catch" "(" "expr" ":" expression ")" .

// nursery: Structured concurrency
// See: 10-patterns.md § Concurrency
nursery_expr = "nursery" "(" nursery_args ")" .
nursery_args = "body" ":" lambda "," "on_error" ":" expression [ "," "timeout" ":" expression ] .

// --- Channel Constructors ---
// See: 06-types.md § Channel Types
channel_expr = channel_constructor "(" "buffer" ":" expression ")" .
channel_constructor = "channel" [ type_args ] | "channel_in" [ type_args ] | "channel_out" [ type_args ] | "channel_all" [ type_args ] .

// --- Match Patterns ---
// See: 10-patterns.md § Match Patterns

match_pattern = literal_pattern
              | identifier_pattern
              | wildcard_pattern
              | variant_pattern
              | struct_pattern
              | tuple_pattern
              | list_pattern
              | range_pattern
              | or_pattern
              | at_pattern .

literal_pattern     = [ "-" ] ( int_literal | float_literal ) | string_literal | char_literal | bool_literal .
identifier_pattern  = identifier .
wildcard_pattern    = "_" .
variant_pattern     = type_path [ "(" [ match_pattern { "," match_pattern } ] ")" ] .
struct_pattern      = [ type_path ] "{" [ field_pattern { "," field_pattern } ] [ ".." ] "}" .
field_pattern       = identifier [ ":" match_pattern ] .
tuple_pattern       = "(" [ match_pattern { "," match_pattern } ] ")" .
list_pattern        = "[" [ list_pattern_elems ] "]" .
list_pattern_elems  = match_pattern { "," match_pattern } [ "," ".." [ identifier ] ]
                    | ".." [ identifier ] .
range_pattern       = literal_pattern ( ".." | "..=" ) literal_pattern .
or_pattern          = match_pattern "|" match_pattern .
at_pattern          = identifier "@" match_pattern .

// --- Binding Patterns ---
// See: 05-variables.md § Destructuring
// The "$" prefix marks immutable bindings; without "$", bindings are mutable.

binding_pattern = [ "$" ] identifier
                | "_"
                | "{" [ field_binding { "," field_binding } ] "}"
                | "(" [ binding_pattern { "," binding_pattern } ] ")"
                | "[" [ binding_pattern { "," binding_pattern } [ ".." identifier ] ] "]" .
field_binding   = [ "$" ] identifier [ ":" binding_pattern ] .


// ============================================================================
// CONSTANT EXPRESSIONS
// See: 04-constants.md, 21-constant-expressions.md
// ============================================================================

const_expr = literal
           | const_expr arith_op const_expr
           | const_expr comp_op const_expr
           | const_expr logic_op const_expr
           | unary_op const_expr
           | "(" const_expr ")" .


// ============================================================================
// PROGRAM ENTRY
// See: 18-program-execution.md
// ============================================================================

main_function = "@main" main_params "->" main_return "=" expression .
main_params   = "()" | "(" "args" ":" "[" "str" "]" ")" .
main_return   = "void" | "int" .


// ============================================================================
// END OF GRAMMAR
// ============================================================================
