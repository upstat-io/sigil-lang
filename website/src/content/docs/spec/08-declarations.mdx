---
title: "Declarations"
description: "Ori Language Specification — Declarations"
section: spec
order: 8
---


Functions, types, traits, and implementations.

## Functions

```
function      = [ "pub" ] "@" identifier [ generics ] params "->" type [ uses ] [ where ] "=" expression .
params        = "(" [ param { "," param } ] ")" .
param         = identifier ":" type .
generics      = "<" generic_param { "," generic_param } ">" .
generic_param = identifier [ ":" bounds ] .
uses          = "uses" identifier { "," identifier } .
```

```ori
@add (a: int, b: int) -> int = a + b

pub @identity<T> (x: T) -> T = x

@sort<T: Comparable> (items: [T]) -> [T] = ...

@fetch (url: str) -> Result<str, Error> uses Http = Http.get(url)
```

- `@` prefix required
- Return type required (`void` for no value)
- Parameters are immutable
- Private by default; `pub` exports
- `uses` declares capability dependencies

## Types

```
type_def    = [ "pub" ] [ derive ] "type" identifier [ generics ] "=" type_body .
derive      = "#[derive(" identifier { "," identifier } ")]" .
type_body   = struct_body | sum_body | type .
struct_body = "{" [ field { "," field } ] "}" .
sum_body    = variant { "|" variant } .
variant     = identifier [ "(" [ field { "," field } ] ")" ] .
field       = identifier ":" type .
```

```ori
type Point = { x: int, y: int }

type Status = Pending | Running | Done | Failed(reason: str)

type UserId = int

#[derive(Eq, Clone)]
type User = { id: int, name: str }
```

## Traits

```
trait_def    = [ "pub" ] "trait" identifier [ generics ] [ ":" bounds ] "{" { trait_item } "}" .
trait_item   = method_sig | default_method | assoc_type .
method_sig   = "@" identifier params "->" type .
default_method = method_sig "=" expression .
assoc_type   = "type" identifier .
```

```ori
trait Printable {
    @to_string (self) -> str
}

trait Comparable: Eq {
    @compare (self, other: Self) -> Ordering
}

trait Iterator {
    type Item
    @next (self) -> Option<Self.Item>
}
```

- `self` — instance
- `Self` — implementing type

## Implementations

```
impl_block    = inherent_impl | trait_impl .
inherent_impl = "impl" [ generics ] type_path [ where ] "{" { method } "}" .
trait_impl    = "impl" [ generics ] type_path "for" type [ where ] "{" { method } "}" .
```

```ori
impl Point {
    @new (x: int, y: int) -> Point = Point { x, y }
}

impl Printable for Point {
    @to_string (self) -> str = "(" + str(self.x) + ", " + str(self.y) + ")"
}

impl<T: Printable> Printable for [T] {
    @to_string (self) -> str = ...
}
```

## Tests

```
test = "@" identifier "tests" "@" identifier { "tests" "@" identifier } params "->" "void" "=" expression .
```

```ori
@test_add tests @add () -> void = run(
    assert_eq(actual: add(a: 2, b: 3), expected: 5),
)
```

See [Testing](/docs/spec/13-testing).
