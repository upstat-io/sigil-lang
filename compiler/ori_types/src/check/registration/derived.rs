//! Derived trait implementation registration (Pass 0d).
//!
//! Processes `#[derive(Eq, Clone, ...)]` attributes on type declarations.
//! Validates derivability constraints (supertrait requirements, sum type
//! restrictions, field trait satisfaction) and generates method signatures
//! so the type checker can resolve derived method calls.

use ori_ir::{DerivedMethodShape, DerivedTrait, ExprId, Name, Span};
use rustc_hash::{FxHashMap, FxHashSet};

use super::type_resolution::{collect_generic_params, resolve_parsed_type_simple};
use crate::{Idx, ImplEntry, ImplMethodDef, ImplSpecificity, ModuleChecker, Tag, TypeCheckError};

/// Register derived trait implementations.
pub fn register_derived_impls(checker: &mut ModuleChecker<'_>, module: &ori_ir::Module) {
    for type_decl in &module.types {
        for derive in &type_decl.derives {
            register_derived_impl(checker, type_decl, *derive);
        }
    }
}

/// Generate and register an implementation for a derived trait.
///
/// Creates an impl block with proper method signatures so the type checker can
/// resolve derived method calls. The actual method bodies are generated by the
/// evaluator (interpreter) or LLVM codegen — the type checker only needs the
/// signatures for return type resolution.
pub(super) fn register_derived_impl(
    checker: &mut ModuleChecker<'_>,
    type_decl: &ori_ir::TypeDecl,
    trait_name: Name,
) {
    // 0. Reject non-derivable traits (E2033)
    let trait_kind = {
        let trait_str = checker.interner().lookup(trait_name);
        if let Some(kind) = DerivedTrait::from_name(trait_str) {
            kind
        } else {
            checker.push_error(TypeCheckError::trait_not_derivable(
                type_decl.span,
                trait_name,
            ));
            return;
        }
    };

    // 0a. Reject derives on sum types when the trait doesn't support it (E2028)
    if !trait_kind.supports_sum_types() && matches!(type_decl.kind, ori_ir::TypeDeclKind::Sum(_)) {
        checker.push_error(TypeCheckError::cannot_derive_for_sum_type(
            type_decl.span,
            type_decl.name,
            trait_kind,
        ));
        return;
    }

    // 0b. Reject derives when the required supertrait is missing (E2029)
    if let Some(required) = trait_kind.requires_supertrait() {
        let required_name = checker.interner().intern(required.trait_name());
        let has_derive = type_decl.derives.contains(&required_name);
        if !has_derive {
            // Also check if an explicit impl exists in the trait registry
            let required_idx = checker.pool_mut().named(required_name);
            let self_type = checker.pool_mut().named(type_decl.name);
            let has_impl = checker.trait_registry().has_impl(required_idx, self_type);
            if !has_impl {
                checker.push_error(TypeCheckError::cannot_derive_without_supertrait(
                    type_decl.span,
                    type_decl.name,
                    trait_kind,
                    required,
                ));
                return;
            }
        }
    }

    // 1. Get the trait index
    let trait_idx = checker.pool_mut().named(trait_name);

    // 2. Get the self type
    let self_type = checker.pool_mut().named(type_decl.name);

    // 3. Collect type parameters from the type declaration
    let type_params = collect_generic_params(checker.arena(), type_decl.generics);

    // 4. Check if this impl already exists (coherence check)
    if checker.trait_registry().has_impl(trait_idx, self_type) {
        // Already have an impl for this trait+type combination
        return;
    }

    // 5. Validate field types implement the derived trait (E2032)
    if !validate_derive_field_constraints(checker, type_decl, trait_name, trait_idx) {
        return;
    }

    // 6. Build method signatures for the derived trait
    let methods = build_derived_methods(checker, trait_name, self_type, type_decl.span);

    // 7. Create and register the impl entry (derived impls are always concrete)
    let entry = ImplEntry {
        trait_idx: Some(trait_idx),
        trait_type_args: Vec::new(),
        self_type,
        type_params,
        methods,
        assoc_types: FxHashMap::default(),
        where_clause: Vec::new(),
        specificity: ImplSpecificity::Concrete,
        span: type_decl.span,
    };

    checker.trait_registry_mut().register_impl(entry);
}

/// Validate that all field types implement the derived trait (E2032).
///
/// Returns `true` if validation passes (all fields satisfy the trait or are
/// generic type parameters). Returns `false` if any field definitively fails,
/// after emitting E2032 errors for each failing field.
fn validate_derive_field_constraints(
    checker: &mut ModuleChecker<'_>,
    type_decl: &ori_ir::TypeDecl,
    trait_name: Name,
    trait_idx: Idx,
) -> bool {
    let arena = checker.arena();

    // Collect generic parameter names to skip them during validation.
    // Generic params (e.g., T in Pair<T>) are checked at instantiation.
    let generic_params: FxHashSet<Name> = {
        let params = arena.get_generic_params(type_decl.generics);
        params.iter().map(|p| p.name).collect()
    };

    let self_name = type_decl.name;
    let mut all_valid = true;

    match &type_decl.kind {
        ori_ir::TypeDeclKind::Struct(fields) => {
            for field in fields {
                let field_ty = resolve_parsed_type_simple(checker, &field.ty, arena);
                if !field_type_satisfies_trait(
                    checker,
                    field_ty,
                    trait_name,
                    trait_idx,
                    self_name,
                    &generic_params,
                ) {
                    checker.push_error(TypeCheckError::field_missing_trait_in_derive(
                        field.span,
                        type_decl.name,
                        trait_name,
                        field.name,
                        field_ty,
                    ));
                    all_valid = false;
                }
            }
        }
        ori_ir::TypeDeclKind::Sum(variants) => {
            for variant in variants {
                for field in &variant.fields {
                    let field_ty = resolve_parsed_type_simple(checker, &field.ty, arena);
                    if !field_type_satisfies_trait(
                        checker,
                        field_ty,
                        trait_name,
                        trait_idx,
                        self_name,
                        &generic_params,
                    ) {
                        checker.push_error(TypeCheckError::field_missing_trait_in_derive(
                            field.span,
                            type_decl.name,
                            trait_name,
                            field.name,
                            field_ty,
                        ));
                        all_valid = false;
                    }
                }
            }
        }
        ori_ir::TypeDeclKind::Newtype(_) => {
            // Newtypes don't have fields to validate
        }
    }

    all_valid
}

/// Check if a field type satisfies a trait for derive validation.
///
/// Conservative: returns `true` for generic type parameters (checked at
/// instantiation), self-references, and types where satisfaction can't be
/// determined during registration.
fn field_type_satisfies_trait(
    checker: &ModuleChecker<'_>,
    field_ty: Idx,
    trait_name: Name,
    trait_idx: Idx,
    self_name: Name,
    generic_params: &FxHashSet<Name>,
) -> bool {
    let tag = checker.pool().tag(field_ty);

    // Generic type variables — skip, checked at instantiation
    if matches!(tag, Tag::Var | Tag::BoundVar | Tag::RigidVar | Tag::Infer) {
        return true;
    }

    // Primitives and builtins — use well-known table
    let wk = checker.well_known();
    if wk.type_satisfies_trait(field_ty, trait_name, checker.pool()) {
        return true;
    }

    // Check trait registry for existing impls (covers earlier derives + manual impls)
    if checker.trait_registry().has_impl(trait_idx, field_ty) {
        return true;
    }

    // For Named types: skip self-references and generic parameters
    if tag == Tag::Named {
        let name = checker.pool().named_name(field_ty);
        // Self-reference (e.g., Tree containing Tree fields)
        if name == self_name {
            return true;
        }
        // Generic type parameter (e.g., T in Pair<T>)
        if generic_params.contains(&name) {
            return true;
        }
    }

    // For applied types (generics like List<T>, Option<T>), the trait satisfaction
    // depends on the type arguments. Be conservative and accept.
    if matches!(tag, Tag::Applied) {
        return true;
    }

    false
}

/// Build the method map for a derived trait implementation.
///
/// Each derived trait has a single method with a known signature:
/// - Eq: `eq(self: T, other: T) -> bool`
/// - Clone: `clone(self: T) -> T`
/// - Hashable: `hash(self: T) -> int`
/// - Printable: `to_str(self: T) -> str`
/// - Default: `default() -> T`
pub(super) fn build_derived_methods(
    checker: &mut ModuleChecker<'_>,
    trait_name: Name,
    self_type: Idx,
    span: Span,
) -> FxHashMap<Name, ImplMethodDef> {
    let trait_str = checker.interner().lookup(trait_name);
    let Some(trait_kind) = DerivedTrait::from_name(trait_str) else {
        return FxHashMap::default();
    };

    let method_str = trait_kind.method_name();
    let method_name = checker.interner().intern(method_str);

    // Build function type from shape metadata — adding a new trait with an
    // existing shape requires zero changes here.
    let signature = match trait_kind.shape() {
        DerivedMethodShape::BinaryPredicate => {
            checker
                .pool_mut()
                .function2(self_type, self_type, Idx::BOOL)
        }
        DerivedMethodShape::UnaryIdentity => checker.pool_mut().function1(self_type, self_type),
        DerivedMethodShape::UnaryToInt => checker.pool_mut().function1(self_type, Idx::INT),
        DerivedMethodShape::UnaryToStr => checker.pool_mut().function1(self_type, Idx::STR),
        DerivedMethodShape::Nullary => checker.pool_mut().function0(self_type),
        DerivedMethodShape::BinaryToOrdering => {
            checker
                .pool_mut()
                .function2(self_type, self_type, Idx::ORDERING)
        }
    };

    let has_self = trait_kind.shape().has_self();

    let mut methods = FxHashMap::default();
    methods.insert(
        method_name,
        ImplMethodDef {
            name: method_name,
            signature,
            has_self,
            body: ExprId::INVALID,
            span,
        },
    );
    methods
}
