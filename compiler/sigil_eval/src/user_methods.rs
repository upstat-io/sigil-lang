//! User-defined method registry for impl block methods.
//!
//! This module stores methods defined in `impl` blocks so they can be
//! dispatched at runtime. Built-in methods (in `methods.rs`) take precedence,
//! but user-defined methods can extend types with new functionality.
//!
//! Also supports derived methods (`#[derive(Eq, Clone, ...)]`) which are
//! generated by the compiler without explicit method bodies.

use std::collections::HashMap;
use sigil_ir::{ExprId, Name, SharedArena};
use sigil_patterns::Value;

/// A derived trait that can be auto-implemented.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub enum DerivedTrait {
    /// Eq trait - structural equality
    Eq,
    /// Clone trait - field-by-field cloning
    Clone,
    /// Hashable trait - hash computation
    Hashable,
    /// Printable trait - string representation
    Printable,
    /// Default trait - default value construction
    Default,
}

impl DerivedTrait {
    /// Parse a trait name string into a DerivedTrait.
    pub fn from_str(s: &str) -> Option<DerivedTrait> {
        match s {
            "Eq" => Some(DerivedTrait::Eq),
            "Clone" => Some(DerivedTrait::Clone),
            "Hashable" => Some(DerivedTrait::Hashable),
            "Printable" => Some(DerivedTrait::Printable),
            "Default" => Some(DerivedTrait::Default),
            _ => None,
        }
    }

    /// Get the method name for this derived trait.
    pub fn method_name(&self) -> &'static str {
        match self {
            DerivedTrait::Eq => "eq",
            DerivedTrait::Clone => "clone",
            DerivedTrait::Hashable => "hash",
            DerivedTrait::Printable => "to_string",
            DerivedTrait::Default => "default",
        }
    }
}

/// Information about a derived method.
///
/// Unlike `UserMethod`, derived methods don't have expression bodies.
/// Instead, they operate on struct/enum field information.
#[derive(Clone, Debug)]
pub struct DerivedMethodInfo {
    /// The trait being derived.
    pub trait_kind: DerivedTrait,
    /// Field names for struct types (in order).
    pub field_names: Vec<Name>,
}

impl DerivedMethodInfo {
    /// Create a new derived method info for a struct.
    pub fn new(trait_kind: DerivedTrait, field_names: Vec<Name>) -> Self {
        DerivedMethodInfo {
            trait_kind,
            field_names,
        }
    }
}

/// A user-defined method from an impl block.
#[derive(Clone, Debug)]
pub struct UserMethod {
    /// Parameter names (first is always `self`).
    pub params: Vec<Name>,
    /// Method body expression.
    pub body: ExprId,
    /// Arena for evaluating the body (Some for imported methods).
    pub arena: Option<SharedArena>,
    /// Captured variables from the defining scope.
    pub captures: HashMap<Name, Value>,
}

impl UserMethod {
    /// Create a new user method.
    pub fn new(params: Vec<Name>, body: ExprId) -> Self {
        UserMethod {
            params,
            body,
            arena: None,
            captures: HashMap::new(),
        }
    }

    /// Create a user method from an imported module.
    pub fn from_import(params: Vec<Name>, body: ExprId, arena: SharedArena) -> Self {
        UserMethod {
            params,
            body,
            arena: Some(arena),
            captures: HashMap::new(),
        }
    }

    /// Create a user method with captures.
    pub fn with_captures(params: Vec<Name>, body: ExprId, captures: HashMap<Name, Value>) -> Self {
        UserMethod {
            params,
            body,
            arena: None,
            captures,
        }
    }
}

/// A method that can be either user-defined or derived.
#[derive(Clone, Debug)]
pub enum MethodEntry {
    /// User-defined method with an expression body.
    User(UserMethod),
    /// Derived method with field information.
    Derived(DerivedMethodInfo),
}

/// Registry for user-defined methods from impl blocks.
///
/// Methods are keyed by (`type_name`, `method_name`) pairs.
/// Type names are strings like "Point", "int", "[int]", etc.
///
/// Also supports derived methods from `#[derive(...)]` attributes.
#[derive(Clone, Debug, Default)]
pub struct UserMethodRegistry {
    /// Map from (`type_name`, `method_name`) to method definition.
    methods: HashMap<(String, String), UserMethod>,
    /// Map from (`type_name`, `method_name`) to derived method info.
    derived_methods: HashMap<(String, String), DerivedMethodInfo>,
}

impl UserMethodRegistry {
    /// Create a new empty registry.
    pub fn new() -> Self {
        UserMethodRegistry {
            methods: HashMap::new(),
            derived_methods: HashMap::new(),
        }
    }

    /// Register a user-defined method.
    ///
    /// # Arguments
    /// * `type_name` - The type this method is defined on (e.g., "Point", "int")
    /// * `method_name` - The method name (e.g., "distance", "double")
    /// * `method` - The method definition
    pub fn register(&mut self, type_name: String, method_name: String, method: UserMethod) {
        self.methods.insert((type_name, method_name), method);
    }

    /// Register a derived method.
    ///
    /// # Arguments
    /// * `type_name` - The type this method is defined on (e.g., "Point")
    /// * `method_name` - The method name (e.g., "eq", "clone")
    /// * `info` - The derived method information
    pub fn register_derived(
        &mut self,
        type_name: String,
        method_name: String,
        info: DerivedMethodInfo,
    ) {
        self.derived_methods.insert((type_name, method_name), info);
    }

    /// Look up a user-defined method.
    ///
    /// Returns None if no method is registered for this type/method combination.
    pub fn lookup(&self, type_name: &str, method_name: &str) -> Option<&UserMethod> {
        self.methods
            .get(&(type_name.to_string(), method_name.to_string()))
    }

    /// Look up a derived method.
    ///
    /// Returns None if no derived method is registered for this type/method combination.
    pub fn lookup_derived(&self, type_name: &str, method_name: &str) -> Option<&DerivedMethodInfo> {
        self.derived_methods
            .get(&(type_name.to_string(), method_name.to_string()))
    }

    /// Look up any method (user-defined or derived).
    ///
    /// Returns the method entry if found.
    pub fn lookup_any(&self, type_name: &str, method_name: &str) -> Option<MethodEntry> {
        let key = (type_name.to_string(), method_name.to_string());

        if let Some(user_method) = self.methods.get(&key) {
            return Some(MethodEntry::User(user_method.clone()));
        }

        if let Some(derived_info) = self.derived_methods.get(&key) {
            return Some(MethodEntry::Derived(derived_info.clone()));
        }

        None
    }

    /// Check if a method exists for the given type (user or derived).
    pub fn has_method(&self, type_name: &str, method_name: &str) -> bool {
        let key = (type_name.to_string(), method_name.to_string());
        self.methods.contains_key(&key) || self.derived_methods.contains_key(&key)
    }

    /// Get all registered user methods (for debugging).
    pub fn all_methods(&self) -> impl Iterator<Item = (&(String, String), &UserMethod)> {
        self.methods.iter()
    }

    /// Get all registered derived methods (for debugging).
    pub fn all_derived_methods(
        &self,
    ) -> impl Iterator<Item = (&(String, String), &DerivedMethodInfo)> {
        self.derived_methods.iter()
    }

    /// Merge another registry into this one.
    pub fn merge(&mut self, other: UserMethodRegistry) {
        self.methods.extend(other.methods);
        self.derived_methods.extend(other.derived_methods);
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use sigil_ir::{ExprId, SharedInterner};

    fn dummy_expr_id() -> ExprId {
        ExprId::new(0)
    }

    fn dummy_name() -> Name {
        let interner = SharedInterner::default();
        interner.intern("dummy")
    }

    #[test]
    fn test_register_and_lookup() {
        let mut registry = UserMethodRegistry::new();
        let method = UserMethod::new(vec![dummy_name()], dummy_expr_id());

        registry.register("Point".to_string(), "distance".to_string(), method);

        assert!(registry.has_method("Point", "distance"));
        assert!(!registry.has_method("Point", "other"));
        assert!(!registry.has_method("Other", "distance"));

        let found = registry.lookup("Point", "distance");
        assert!(found.is_some());
    }

    #[test]
    fn test_empty_registry() {
        let registry = UserMethodRegistry::new();
        assert!(!registry.has_method("Point", "distance"));
        assert!(registry.lookup("Point", "distance").is_none());
    }

    #[test]
    fn test_derived_trait_from_str() {
        assert_eq!(DerivedTrait::from_str("Eq"), Some(DerivedTrait::Eq));
        assert_eq!(DerivedTrait::from_str("Clone"), Some(DerivedTrait::Clone));
        assert_eq!(
            DerivedTrait::from_str("Hashable"),
            Some(DerivedTrait::Hashable)
        );
        assert_eq!(
            DerivedTrait::from_str("Printable"),
            Some(DerivedTrait::Printable)
        );
        assert_eq!(
            DerivedTrait::from_str("Default"),
            Some(DerivedTrait::Default)
        );
        assert_eq!(DerivedTrait::from_str("Unknown"), None);
    }

    #[test]
    fn test_derived_trait_method_name() {
        assert_eq!(DerivedTrait::Eq.method_name(), "eq");
        assert_eq!(DerivedTrait::Clone.method_name(), "clone");
        assert_eq!(DerivedTrait::Hashable.method_name(), "hash");
        assert_eq!(DerivedTrait::Printable.method_name(), "to_string");
        assert_eq!(DerivedTrait::Default.method_name(), "default");
    }

    #[test]
    fn test_register_and_lookup_derived() {
        let interner = SharedInterner::default();
        let mut registry = UserMethodRegistry::new();

        let x_name = interner.intern("x");
        let y_name = interner.intern("y");
        let info = DerivedMethodInfo::new(DerivedTrait::Eq, vec![x_name, y_name]);

        registry.register_derived("Point".to_string(), "eq".to_string(), info);

        assert!(registry.has_method("Point", "eq"));
        assert!(registry.lookup_derived("Point", "eq").is_some());
        assert!(registry.lookup("Point", "eq").is_none()); // not a user method

        let found = registry.lookup_derived("Point", "eq").unwrap();
        assert_eq!(found.trait_kind, DerivedTrait::Eq);
        assert_eq!(found.field_names.len(), 2);
    }

    #[test]
    fn test_lookup_any() {
        let interner = SharedInterner::default();
        let mut registry = UserMethodRegistry::new();

        // Register a user method
        let method = UserMethod::new(vec![dummy_name()], dummy_expr_id());
        registry.register("Point".to_string(), "distance".to_string(), method);

        // Register a derived method
        let x_name = interner.intern("x");
        let info = DerivedMethodInfo::new(DerivedTrait::Eq, vec![x_name]);
        registry.register_derived("Point".to_string(), "eq".to_string(), info);

        // Lookup user method via lookup_any
        if let Some(MethodEntry::User(_)) = registry.lookup_any("Point", "distance") {
            // ok
        } else {
            panic!("Expected User method entry");
        }

        // Lookup derived method via lookup_any
        if let Some(MethodEntry::Derived(info)) = registry.lookup_any("Point", "eq") {
            assert_eq!(info.trait_kind, DerivedTrait::Eq);
        } else {
            panic!("Expected Derived method entry");
        }

        // Lookup non-existent method
        assert!(registry.lookup_any("Point", "nonexistent").is_none());
    }

    #[test]
    fn test_merge_registries() {
        let interner = SharedInterner::default();
        let mut registry1 = UserMethodRegistry::new();
        let mut registry2 = UserMethodRegistry::new();

        // Register in first registry
        let method = UserMethod::new(vec![dummy_name()], dummy_expr_id());
        registry1.register("Point".to_string(), "distance".to_string(), method);

        // Register derived in second registry
        let x_name = interner.intern("x");
        let info = DerivedMethodInfo::new(DerivedTrait::Clone, vec![x_name]);
        registry2.register_derived("Point".to_string(), "clone".to_string(), info);

        // Merge
        registry1.merge(registry2);

        // Both should be present
        assert!(registry1.has_method("Point", "distance"));
        assert!(registry1.has_method("Point", "clone"));
    }
}
