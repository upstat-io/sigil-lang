// C Code Generator for Sigil
// Transforms typed AST into C source code
//
// The code generator is split into several submodules:
// - emitter.rs: Low-level output helpers
// - runtime.rs: C runtime code emission
// - types.rs: Type mapping
// - decl.rs: Declaration emission
// - expr.rs: Expression translation
// - tir/: TIR-based code generation (new)

pub mod backend;
mod decl;
mod emitter;
mod expr;
mod runtime;
pub mod tir;
mod types;

#[cfg(test)]
mod tests;

// Re-export backend types for convenience
pub use backend::{
    Backend, BackendRegistry, CBackend, CodegenOptions, GeneratedCode, OutputFormat,
};

use crate::arc::ArcValidatedModule;
use crate::ast::*;
use crate::ir::TModule;

pub struct CodeGen {
    output: String,
    indent: usize,
}

impl Default for CodeGen {
    fn default() -> Self {
        Self::new()
    }
}

impl CodeGen {
    pub fn new() -> Self {
        CodeGen {
            output: String::new(),
            indent: 0,
        }
    }

    pub fn generate(mut self, module: &Module) -> Result<String, String> {
        // Emit header
        self.emit_line("// Generated by Sigil compiler");
        self.emit_line("#include <stdio.h>");
        self.emit_line("#include <stdlib.h>");
        self.emit_line("#include <stdint.h>");
        self.emit_line("#include <stdbool.h>");
        self.emit_line("#include <string.h>");
        self.emit_line("");

        // Emit runtime helpers
        self.emit_runtime();

        // Forward declarations
        for item in &module.items {
            if let Item::Function(f) = item {
                if f.name != "main" {
                    self.emit_forward_decl(f)?;
                }
            }
        }
        self.emit_line("");

        // Emit config variables
        for item in &module.items {
            if let Item::Config(c) = item {
                self.emit_config(c)?;
            }
        }
        self.emit_line("");

        // Emit functions
        for item in &module.items {
            if let Item::Function(f) = item {
                self.emit_function(f)?;
                self.emit_line("");
            }
        }

        Ok(self.output)
    }
}

/// Generate C code from AST (legacy)
pub fn generate(module: &Module) -> Result<String, String> {
    CodeGen::new().generate(module)
}

/// Generate C code from TIR (legacy - use generate_from_validated for new code)
///
/// This function bypasses mandatory ARC validation. It is kept for backward
/// compatibility but new code should use `generate_from_validated` instead.
pub fn generate_from_tir(module: &TModule) -> Result<String, String> {
    tir::generate(module)
}

/// Generate C code from an ARC-validated module (RECOMMENDED)
///
/// This is the recommended entry point for code generation. It accepts
/// only ArcValidatedModule, ensuring that ARC analysis has been performed
/// and all IR variants are properly handled for memory management.
///
/// The pre-computed ARC information is used during code generation for
/// optimal retain/release placement and elision opportunities.
pub fn generate_from_validated(validated: &ArcValidatedModule) -> Result<String, String> {
    tir::generate_from_validated(validated)
}
