// TIR-based C code generation for Sigil
// Generates C code from Typed Intermediate Representation
//
// Unlike the AST-based codegen, this version uses the embedded types
// directly from the TIR expressions, eliminating the need for type inference.
//
// Memory management uses ARC (Automatic Reference Counting) with:
// - Compile-time cycle prevention
// - Small String Optimization (SSO)
// - Scope-based destruction

mod decl;
mod expr;
mod types;

use crate::arc::{create_emitter, ArcConfig, ArcEmitter, ArcValidatedModule, ModuleArcInfo};
use crate::ir::TModule;

/// TIR-based code generator
pub struct TirCodeGen {
    output: String,
    indent: usize,
    /// Whether to use the ARC runtime (default: true)
    use_arc: bool,
    /// ARC configuration
    arc_config: ArcConfig,
}

impl Default for TirCodeGen {
    fn default() -> Self {
        Self::new()
    }
}

impl TirCodeGen {
    pub fn new() -> Self {
        TirCodeGen {
            output: String::new(),
            indent: 0,
            use_arc: true,
            arc_config: ArcConfig::default(),
        }
    }

    /// Create a code generator with custom ARC configuration
    pub fn with_arc_config(config: ArcConfig) -> Self {
        TirCodeGen {
            output: String::new(),
            indent: 0,
            use_arc: true,
            arc_config: config,
        }
    }

    /// Disable ARC (for testing or simple programs)
    pub fn without_arc() -> Self {
        TirCodeGen {
            output: String::new(),
            indent: 0,
            use_arc: false,
            arc_config: ArcConfig::default(),
        }
    }

    /// Generate code from an ARC-validated module
    ///
    /// This method uses pre-computed ARC information for code generation,
    /// ensuring proper retain/release placement based on the analysis.
    pub fn generate_validated(mut self, validated: &ArcValidatedModule) -> Result<String, String> {
        let module = validated.module();
        let arc_info = validated.arc_info();

        // Store ARC info for use during generation (could be used for optimization)
        // For now, we just delegate to the standard generate method since the
        // actual retain/release emission is done based on type classification
        // which is already computed

        self.generate_with_arc_info(module, Some(arc_info))
    }

    /// Internal: Generate with optional ARC info
    fn generate_with_arc_info(
        &mut self,
        module: &TModule,
        _arc_info: Option<&ModuleArcInfo>,
    ) -> Result<String, String> {
        // Emit header
        self.emit_line("// Generated by Sigil compiler (TIR)");
        self.emit_line("#include <stdio.h>");
        self.emit_line("#include <stdlib.h>");
        self.emit_line("#include <stdint.h>");
        self.emit_line("#include <stdbool.h>");
        self.emit_line("#include <string.h>");
        self.emit_line("");

        // Emit runtime helpers
        self.emit_runtime();

        // Forward declarations
        for func in &module.functions {
            if func.name != "main" {
                self.emit_forward_decl(func)?;
            }
        }
        self.emit_line("");

        // Emit config variables
        for config in &module.configs {
            self.emit_config(config)?;
        }
        self.emit_line("");

        // Emit functions
        for func in &module.functions {
            self.emit_function(func)?;
            self.emit_line("");
        }

        Ok(std::mem::take(&mut self.output))
    }

    pub fn generate(mut self, module: &TModule) -> Result<String, String> {
        // Emit header
        self.emit_line("// Generated by Sigil compiler (TIR)");
        self.emit_line("#include <stdio.h>");
        self.emit_line("#include <stdlib.h>");
        self.emit_line("#include <stdint.h>");
        self.emit_line("#include <stdbool.h>");
        self.emit_line("#include <string.h>");
        self.emit_line("");

        // Emit runtime helpers
        self.emit_runtime();

        // Forward declarations
        for func in &module.functions {
            if func.name != "main" {
                self.emit_forward_decl(func)?;
            }
        }
        self.emit_line("");

        // Emit config variables
        for config in &module.configs {
            self.emit_config(config)?;
        }
        self.emit_line("");

        // Emit functions
        for func in &module.functions {
            self.emit_function(func)?;
            self.emit_line("");
        }

        Ok(self.output)
    }

    // Output helpers

    #[allow(dead_code)]
    pub(super) fn emit(&mut self, s: &str) {
        self.output.push_str(s);
    }

    pub(super) fn emit_line(&mut self, s: &str) {
        self.emit_indent();
        self.output.push_str(s);
        self.output.push('\n');
    }

    pub(super) fn emit_indent(&mut self) {
        for _ in 0..self.indent {
            self.output.push_str("    ");
        }
    }

    pub(super) fn indent(&mut self) {
        self.indent += 1;
    }

    pub(super) fn dedent(&mut self) {
        self.indent = self.indent.saturating_sub(1);
    }

    // Runtime helpers

    pub(super) fn emit_runtime(&mut self) {
        if self.use_arc {
            // Use the ARC runtime
            let emitter = create_emitter();
            let header = emitter.emit_runtime_header(&self.arc_config);

            // Emit the ARC runtime header inline
            self.emit_line("// ARC Runtime (inline)");
            for line in header.lines() {
                self.emit_line(line);
            }
            self.emit_line("");

            // Emit the ARC runtime implementation inline
            let impl_code = emitter.emit_runtime_impl(&self.arc_config);
            self.emit_line("// ARC Runtime Implementation");
            for line in impl_code.lines() {
                self.emit_line(line);
            }
            self.emit_line("");

            // Emit compatibility wrappers for existing codegen
            self.emit_line("// Compatibility wrappers");
            self.emit_line("#define str_new(s) sigil_string_new((s), strlen(s))");
            self.emit_line("#define String SigilString");
            self.emit_line("");
            self.emit_line("SigilString str_concat(SigilString a, SigilString b) {");
            self.indent();
            self.emit_line("return sigil_string_concat(a, b);");
            self.dedent();
            self.emit_line("}");
            self.emit_line("");
            self.emit_line("SigilString int_to_str(int64_t n) {");
            self.indent();
            self.emit_line("char buf[32];");
            self.emit_line("snprintf(buf, sizeof(buf), \"%ld\", n);");
            self.emit_line("return sigil_string_new(buf, strlen(buf));");
            self.dedent();
            self.emit_line("}");
            self.emit_line("");
        } else {
            // Use simple runtime without ARC (for testing)
            self.emit_line("// Simple Runtime (no ARC)");
            self.emit_line("typedef struct { char* data; size_t len; } String;");
            self.emit_line("");
            self.emit_line("String str_new(const char* s) {");
            self.indent();
            self.emit_line("String str = { strdup(s), strlen(s) };");
            self.emit_line("return str;");
            self.dedent();
            self.emit_line("}");
            self.emit_line("");
            self.emit_line("String str_concat(String a, String b) {");
            self.indent();
            self.emit_line("size_t len = a.len + b.len;");
            self.emit_line("char* data = malloc(len + 1);");
            self.emit_line("memcpy(data, a.data, a.len);");
            self.emit_line("memcpy(data + a.len, b.data, b.len);");
            self.emit_line("data[len] = '\\0';");
            self.emit_line("String str = { data, len };");
            self.emit_line("return str;");
            self.dedent();
            self.emit_line("}");
            self.emit_line("");
            self.emit_line("String int_to_str(int64_t n) {");
            self.indent();
            self.emit_line("char buf[32];");
            self.emit_line("snprintf(buf, sizeof(buf), \"%ld\", n);");
            self.emit_line("return str_new(buf);");
            self.dedent();
            self.emit_line("}");
            self.emit_line("");
        }
    }
}

/// Generate C code from a TModule (legacy - use generate_from_validated for new code)
pub fn generate(module: &TModule) -> Result<String, String> {
    TirCodeGen::new().generate(module)
}

/// Generate C code from an ARC-validated module (RECOMMENDED)
///
/// This function uses the pre-computed ARC information for optimal
/// retain/release placement during code generation.
pub fn generate_from_validated(validated: &ArcValidatedModule) -> Result<String, String> {
    TirCodeGen::new().generate_validated(validated)
}
