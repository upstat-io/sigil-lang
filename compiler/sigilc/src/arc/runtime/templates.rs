// C Runtime Templates for ARC Memory Management
//
// Contains template strings for generating the C runtime library.
// These templates are used by header.rs and impl_gen.rs.

/// Header file preamble
pub const HEADER_PREAMBLE: &str = r#"/*
 * Sigil ARC Runtime Library
 * Automatic Reference Counting support for Sigil compiled programs
 *
 * Generated by the Sigil compiler - do not edit manually
 */

#ifndef SIGIL_ARC_H
#define SIGIL_ARC_H

#include <stdint.h>
#include <stddef.h>
#include <stdbool.h>

#ifdef __cplusplus
extern "C" {
#endif

"#;

/// Header file postamble
pub const HEADER_POSTAMBLE: &str = r#"
#ifdef __cplusplus
}
#endif

#endif /* SIGIL_ARC_H */
"#;

/// Thread-safe refcount type definition
pub const THREAD_SAFE_REFCOUNT: &str = r#"
/* Thread-safe reference counting */
#include <stdatomic.h>
typedef _Atomic size_t sigil_refcount_t;

#define SIGIL_REFCOUNT_INC(rc) atomic_fetch_add(&(rc), 1)
#define SIGIL_REFCOUNT_DEC(rc) atomic_fetch_sub(&(rc), 1)
#define SIGIL_REFCOUNT_LOAD(rc) atomic_load(&(rc))
#define SIGIL_REFCOUNT_INIT(rc, val) atomic_init(&(rc), val)
"#;

/// Single-threaded refcount type definition
pub const SINGLE_THREADED_REFCOUNT: &str = r#"
/* Single-threaded reference counting */
typedef size_t sigil_refcount_t;

#define SIGIL_REFCOUNT_INC(rc) (++(rc))
#define SIGIL_REFCOUNT_DEC(rc) (--(rc))
#define SIGIL_REFCOUNT_LOAD(rc) (rc)
#define SIGIL_REFCOUNT_INIT(rc, val) ((rc) = (val))
"#;

/// ARC header structure
pub const ARC_HEADER_STRUCT: &str = r#"
/* ARC header for heap-allocated objects */
typedef struct SigilArcHeader {
    sigil_refcount_t refcount;
} SigilArcHeader;

/* Get the ARC header from a data pointer */
static inline SigilArcHeader* sigil_arc_header(void* ptr) {
    return (SigilArcHeader*)((char*)ptr - sizeof(SigilArcHeader));
}
"#;

/// String type with SSO
pub const STRING_TYPE: &str = r#"
/* String with Small String Optimization (SSO)
 * Inline storage for strings up to SSO_THRESHOLD bytes
 */
#define SIGIL_SSO_THRESHOLD 22

typedef struct SigilString {
    union {
        /* Heap-allocated string */
        struct {
            char* data;
            size_t len;
            SigilArcHeader* header;
        } heap;
        /* Small string optimization */
        struct {
            char data[SIGIL_SSO_THRESHOLD];
            uint8_t len;
            uint8_t flags;  /* Bit 0: is_sso flag */
        } sso;
    } storage;
} SigilString;

#define SIGIL_STRING_IS_SSO(s) ((s)->storage.sso.flags & 1)
"#;

/// List type
pub const LIST_TYPE: &str = r#"
/* Dynamic list (array) */
typedef struct SigilList {
    void* data;
    size_t len;
    size_t capacity;
    size_t elem_size;
    SigilArcHeader* header;
} SigilList;
"#;

/// Map type
pub const MAP_TYPE: &str = r#"
/* Hash map */
typedef struct SigilMapEntry {
    uint64_t hash;
    void* key;
    void* value;
    struct SigilMapEntry* next;
} SigilMapEntry;

typedef struct SigilMap {
    SigilMapEntry** buckets;
    size_t bucket_count;
    size_t size;
    size_t key_size;
    size_t value_size;
    SigilArcHeader* header;
} SigilMap;
"#;

/// Closure type
pub const CLOSURE_TYPE: &str = r#"
/* Closure (function pointer + captured environment) */
typedef struct SigilClosure {
    void* func;
    void* env;
    size_t env_size;
    SigilArcHeader* header;
} SigilClosure;
"#;

/// Core ARC function declarations
pub const ARC_FUNCTIONS: &str = r#"
/* Core ARC functions */
void* sigil_arc_alloc(size_t size);
void sigil_arc_retain(void* ptr);
bool sigil_arc_release(void* ptr);  /* Returns true if freed */
size_t sigil_arc_refcount(void* ptr);

/* Scope cleanup helper */
typedef struct SigilCleanupEntry {
    void* ptr;
    void (*release_fn)(void*);
} SigilCleanupEntry;

void sigil_scope_cleanup(SigilCleanupEntry* entries, size_t count);
"#;

/// String function declarations
pub const STRING_FUNCTIONS: &str = r#"
/* String functions */
SigilString sigil_string_new(const char* data, size_t len);
SigilString sigil_string_from_cstr(const char* cstr);
void sigil_string_retain(SigilString* s);
void sigil_string_release(SigilString* s);
size_t sigil_string_len(const SigilString* s);
const char* sigil_string_data(const SigilString* s);
SigilString sigil_string_concat(const SigilString* a, const SigilString* b);
bool sigil_string_eq(const SigilString* a, const SigilString* b);
int sigil_string_cmp(const SigilString* a, const SigilString* b);
uint64_t sigil_string_hash(const SigilString* s);
"#;

/// List function declarations
pub const LIST_FUNCTIONS: &str = r#"
/* List functions */
SigilList sigil_list_new(size_t elem_size);
void sigil_list_retain(SigilList* list);
void sigil_list_release(SigilList* list);
void sigil_list_push(SigilList* list, const void* elem);
void* sigil_list_get(const SigilList* list, size_t index);
size_t sigil_list_len(const SigilList* list);
void sigil_list_clear(SigilList* list);
"#;

/// Map function declarations
pub const MAP_FUNCTIONS: &str = r#"
/* Map functions */
SigilMap sigil_map_new(size_t key_size, size_t value_size);
void sigil_map_retain(SigilMap* map);
void sigil_map_release(SigilMap* map);
void sigil_map_insert(SigilMap* map, const void* key, uint64_t hash, const void* value);
void* sigil_map_get(const SigilMap* map, const void* key, uint64_t hash);
bool sigil_map_remove(SigilMap* map, const void* key, uint64_t hash);
size_t sigil_map_len(const SigilMap* map);
"#;

/// Debug tracking declarations
pub const DEBUG_TRACKING: &str = r#"
/* Debug allocation tracking */
#ifdef SIGIL_DEBUG_ARC

typedef struct SigilAllocRecord {
    void* ptr;
    size_t size;
    const char* file;
    int line;
    struct SigilAllocRecord* next;
} SigilAllocRecord;

void sigil_debug_record_alloc(void* ptr, size_t size, const char* file, int line);
void sigil_debug_record_free(void* ptr);
void sigil_debug_leak_report(void);
size_t sigil_debug_alloc_count(void);
size_t sigil_debug_total_bytes(void);

#define SIGIL_ARC_ALLOC(size) sigil_debug_alloc_wrapper(size, __FILE__, __LINE__)
#define SIGIL_ARC_FREE(ptr) sigil_debug_free_wrapper(ptr)

#else

#define SIGIL_ARC_ALLOC(size) sigil_arc_alloc(size)
#define SIGIL_ARC_FREE(ptr) sigil_arc_release(ptr)

#endif
"#;

/// Implementation file preamble
pub const IMPL_PREAMBLE: &str = r#"/*
 * Sigil ARC Runtime Library Implementation
 * Generated by the Sigil compiler - do not edit manually
 */

#include "sigil_arc.h"
#include <stdlib.h>
#include <string.h>
#include <stdio.h>

"#;

/// Core ARC implementation
pub const ARC_IMPL: &str = r#"
/* Core ARC implementation */

void* sigil_arc_alloc(size_t size) {
    SigilArcHeader* header = (SigilArcHeader*)malloc(sizeof(SigilArcHeader) + size);
    if (!header) {
        fprintf(stderr, "sigil: out of memory\n");
        abort();
    }
    SIGIL_REFCOUNT_INIT(header->refcount, 1);
    return (char*)header + sizeof(SigilArcHeader);
}

void sigil_arc_retain(void* ptr) {
    if (!ptr) return;
    SigilArcHeader* header = sigil_arc_header(ptr);
    SIGIL_REFCOUNT_INC(header->refcount);
}

bool sigil_arc_release(void* ptr) {
    if (!ptr) return false;
    SigilArcHeader* header = sigil_arc_header(ptr);
    if (SIGIL_REFCOUNT_DEC(header->refcount) == 1) {
        free(header);
        return true;
    }
    return false;
}

size_t sigil_arc_refcount(void* ptr) {
    if (!ptr) return 0;
    SigilArcHeader* header = sigil_arc_header(ptr);
    return SIGIL_REFCOUNT_LOAD(header->refcount);
}

void sigil_scope_cleanup(SigilCleanupEntry* entries, size_t count) {
    for (size_t i = 0; i < count; i++) {
        if (entries[i].ptr && entries[i].release_fn) {
            entries[i].release_fn(entries[i].ptr);
        }
    }
}
"#;

/// String implementation
pub const STRING_IMPL: &str = r#"
/* String implementation with SSO */

SigilString sigil_string_new(const char* data, size_t len) {
    SigilString s;

    if (len <= SIGIL_SSO_THRESHOLD) {
        /* Use SSO */
        memcpy(s.storage.sso.data, data, len);
        s.storage.sso.len = (uint8_t)len;
        s.storage.sso.flags = 1;  /* is_sso = true */
    } else {
        /* Heap allocate */
        s.storage.heap.header = (SigilArcHeader*)malloc(sizeof(SigilArcHeader) + len + 1);
        if (!s.storage.heap.header) {
            fprintf(stderr, "sigil: out of memory\n");
            abort();
        }
        SIGIL_REFCOUNT_INIT(s.storage.heap.header->refcount, 1);
        s.storage.heap.data = (char*)(s.storage.heap.header + 1);
        memcpy(s.storage.heap.data, data, len);
        s.storage.heap.data[len] = '\0';
        s.storage.heap.len = len;
    }

    return s;
}

SigilString sigil_string_from_cstr(const char* cstr) {
    return sigil_string_new(cstr, strlen(cstr));
}

void sigil_string_retain(SigilString* s) {
    if (!SIGIL_STRING_IS_SSO(s) && s->storage.heap.header) {
        SIGIL_REFCOUNT_INC(s->storage.heap.header->refcount);
    }
}

void sigil_string_release(SigilString* s) {
    if (!SIGIL_STRING_IS_SSO(s) && s->storage.heap.header) {
        if (SIGIL_REFCOUNT_DEC(s->storage.heap.header->refcount) == 1) {
            free(s->storage.heap.header);
            s->storage.heap.header = NULL;
            s->storage.heap.data = NULL;
        }
    }
}

size_t sigil_string_len(const SigilString* s) {
    if (SIGIL_STRING_IS_SSO(s)) {
        return s->storage.sso.len;
    }
    return s->storage.heap.len;
}

const char* sigil_string_data(const SigilString* s) {
    if (SIGIL_STRING_IS_SSO(s)) {
        return s->storage.sso.data;
    }
    return s->storage.heap.data;
}

SigilString sigil_string_concat(const SigilString* a, const SigilString* b) {
    size_t len_a = sigil_string_len(a);
    size_t len_b = sigil_string_len(b);
    size_t total_len = len_a + len_b;

    if (total_len <= SIGIL_SSO_THRESHOLD) {
        SigilString result;
        memcpy(result.storage.sso.data, sigil_string_data(a), len_a);
        memcpy(result.storage.sso.data + len_a, sigil_string_data(b), len_b);
        result.storage.sso.len = (uint8_t)total_len;
        result.storage.sso.flags = 1;
        return result;
    }

    char* buffer = malloc(total_len + 1);
    memcpy(buffer, sigil_string_data(a), len_a);
    memcpy(buffer + len_a, sigil_string_data(b), len_b);
    buffer[total_len] = '\0';

    SigilString result = sigil_string_new(buffer, total_len);
    free(buffer);
    return result;
}

bool sigil_string_eq(const SigilString* a, const SigilString* b) {
    size_t len_a = sigil_string_len(a);
    size_t len_b = sigil_string_len(b);
    if (len_a != len_b) return false;
    return memcmp(sigil_string_data(a), sigil_string_data(b), len_a) == 0;
}

int sigil_string_cmp(const SigilString* a, const SigilString* b) {
    size_t len_a = sigil_string_len(a);
    size_t len_b = sigil_string_len(b);
    size_t min_len = len_a < len_b ? len_a : len_b;
    int cmp = memcmp(sigil_string_data(a), sigil_string_data(b), min_len);
    if (cmp != 0) return cmp;
    if (len_a < len_b) return -1;
    if (len_a > len_b) return 1;
    return 0;
}

uint64_t sigil_string_hash(const SigilString* s) {
    /* FNV-1a hash */
    uint64_t hash = 0xcbf29ce484222325ULL;
    const char* data = sigil_string_data(s);
    size_t len = sigil_string_len(s);
    for (size_t i = 0; i < len; i++) {
        hash ^= (uint64_t)(unsigned char)data[i];
        hash *= 0x100000001b3ULL;
    }
    return hash;
}
"#;

/// List implementation
pub const LIST_IMPL: &str = r#"
/* List implementation */

SigilList sigil_list_new(size_t elem_size) {
    SigilList list = {0};
    list.elem_size = elem_size;
    list.capacity = 8;

    size_t data_size = list.capacity * elem_size;
    list.header = (SigilArcHeader*)malloc(sizeof(SigilArcHeader) + data_size);
    if (!list.header) {
        fprintf(stderr, "sigil: out of memory\n");
        abort();
    }
    SIGIL_REFCOUNT_INIT(list.header->refcount, 1);
    list.data = (char*)(list.header + 1);

    return list;
}

void sigil_list_retain(SigilList* list) {
    if (list->header) {
        SIGIL_REFCOUNT_INC(list->header->refcount);
    }
}

void sigil_list_release(SigilList* list) {
    if (list->header) {
        if (SIGIL_REFCOUNT_DEC(list->header->refcount) == 1) {
            free(list->header);
            list->header = NULL;
            list->data = NULL;
        }
    }
}

void sigil_list_push(SigilList* list, const void* elem) {
    if (list->len >= list->capacity) {
        size_t new_capacity = list->capacity * 2;
        size_t new_size = sizeof(SigilArcHeader) + new_capacity * list->elem_size;
        SigilArcHeader* new_header = (SigilArcHeader*)realloc(list->header, new_size);
        if (!new_header) {
            fprintf(stderr, "sigil: out of memory\n");
            abort();
        }
        list->header = new_header;
        list->data = (char*)(new_header + 1);
        list->capacity = new_capacity;
    }

    memcpy((char*)list->data + list->len * list->elem_size, elem, list->elem_size);
    list->len++;
}

void* sigil_list_get(const SigilList* list, size_t index) {
    if (index >= list->len) {
        fprintf(stderr, "sigil: list index out of bounds\n");
        abort();
    }
    return (char*)list->data + index * list->elem_size;
}

size_t sigil_list_len(const SigilList* list) {
    return list->len;
}

void sigil_list_clear(SigilList* list) {
    list->len = 0;
}
"#;

/// Debug tracking implementation
pub const DEBUG_IMPL: &str = r#"
#ifdef SIGIL_DEBUG_ARC

static SigilAllocRecord* debug_alloc_list = NULL;
static size_t debug_alloc_count = 0;
static size_t debug_total_bytes = 0;

void sigil_debug_record_alloc(void* ptr, size_t size, const char* file, int line) {
    SigilAllocRecord* record = (SigilAllocRecord*)malloc(sizeof(SigilAllocRecord));
    record->ptr = ptr;
    record->size = size;
    record->file = file;
    record->line = line;
    record->next = debug_alloc_list;
    debug_alloc_list = record;
    debug_alloc_count++;
    debug_total_bytes += size;
}

void sigil_debug_record_free(void* ptr) {
    SigilAllocRecord** prev = &debug_alloc_list;
    SigilAllocRecord* curr = debug_alloc_list;

    while (curr) {
        if (curr->ptr == ptr) {
            *prev = curr->next;
            debug_alloc_count--;
            debug_total_bytes -= curr->size;
            free(curr);
            return;
        }
        prev = &curr->next;
        curr = curr->next;
    }
}

void sigil_debug_leak_report(void) {
    if (!debug_alloc_list) {
        printf("No memory leaks detected.\n");
        return;
    }

    printf("=== MEMORY LEAK REPORT ===\n");
    printf("Leaked allocations: %zu\n", debug_alloc_count);
    printf("Leaked bytes: %zu\n", debug_total_bytes);
    printf("\nLeaked allocations:\n");

    SigilAllocRecord* curr = debug_alloc_list;
    while (curr) {
        printf("  %p: %zu bytes at %s:%d\n",
               curr->ptr, curr->size, curr->file, curr->line);
        curr = curr->next;
    }
}

size_t sigil_debug_alloc_count(void) {
    return debug_alloc_count;
}

size_t sigil_debug_total_bytes(void) {
    return debug_total_bytes;
}

void* sigil_debug_alloc_wrapper(size_t size, const char* file, int line) {
    void* ptr = sigil_arc_alloc(size);
    sigil_debug_record_alloc(ptr, size, file, line);
    return ptr;
}

void sigil_debug_free_wrapper(void* ptr) {
    sigil_debug_record_free(ptr);
    sigil_arc_release(ptr);
}

#endif /* SIGIL_DEBUG_ARC */
"#;
