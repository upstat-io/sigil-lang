//! Derived trait definitions.
//!
//! This module contains the `DerivedTrait` enum (generated by [`define_derived_traits!`]),
//! `DerivedMethodShape`, and `DerivedMethodInfo`. These are used by the type checker,
//! evaluator, and LLVM codegen. By placing them in `ori_ir`, we avoid circular
//! dependencies between consuming crates.
//!
//! **Adding a new derived trait?** Add one tuple to the [`define_derived_traits!`]
//! invocation below. The macro generates the enum variant, all accessor methods,
//! and metadata. Then implement the eval handler, LLVM handler, and prelude definition.

use crate::Name;

/// The parameter/return shape of a derived method's signature.
///
/// Consuming crates (`ori_types`, `ori_llvm`) use this to construct type-correct
/// signatures without hard-coding per-trait parameter lists.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub enum DerivedMethodShape {
    /// `(self: T, other: T) -> bool` (Eq)
    BinaryPredicate,
    /// `(self: T) -> T` (Clone)
    UnaryIdentity,
    /// `(self: T) -> int` (Hashable)
    UnaryToInt,
    /// `(self: T) -> str` (Printable, Debug)
    UnaryToStr,
    /// `() -> T` (Default) — no self parameter
    Nullary,
    /// `(self: T, other: T) -> Ordering` (Comparable)
    BinaryToOrdering,
}

impl DerivedMethodShape {
    /// Whether the method takes a `self` parameter.
    pub fn has_self(&self) -> bool {
        !matches!(self, DerivedMethodShape::Nullary)
    }

    /// Whether the method takes an `other: Self` parameter.
    pub fn has_other(&self) -> bool {
        matches!(
            self,
            DerivedMethodShape::BinaryPredicate | DerivedMethodShape::BinaryToOrdering
        )
    }

    /// Number of parameters (including self).
    pub fn param_count(&self) -> usize {
        match self {
            DerivedMethodShape::Nullary => 0,
            DerivedMethodShape::UnaryIdentity
            | DerivedMethodShape::UnaryToInt
            | DerivedMethodShape::UnaryToStr => 1,
            DerivedMethodShape::BinaryPredicate | DerivedMethodShape::BinaryToOrdering => 2,
        }
    }
}

/// Declare all derived traits in a single location.
///
/// Each entry is: `(Variant, "TraitName", "method_name", Shape, Supertrait, SumSupport)`
///
/// Generates:
/// - `DerivedTrait` enum with all variants
/// - `from_name(&str) -> Option<DerivedTrait>` — parse trait name
/// - `method_name(&self) -> &'static str` — method identifier
/// - `trait_name(&self) -> &'static str` — trait name string
/// - `shape(&self) -> DerivedMethodShape` — parameter/return shape
/// - `requires_supertrait(&self) -> Option<DerivedTrait>` — supertrait constraint
/// - `supports_sum_types(&self) -> bool` — derivable on enums?
/// - `ALL: &[DerivedTrait]` — all variants for iteration
/// - `COUNT: usize` — variant count
macro_rules! define_derived_traits {
    ($(
        ($variant:ident, $trait_name:literal, $method_name:literal,
         $shape:expr, $supertrait:expr, $sum_support:expr)
    ),+ $(,)?) => {
        /// A derived trait that can be auto-implemented.
        #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
        pub enum DerivedTrait {
            $( #[doc = concat!("The `", $trait_name, "` trait.")] $variant, )+
        }

        impl DerivedTrait {
            /// All derived trait variants, for iteration in tests and registration.
            pub const ALL: &[DerivedTrait] = &[ $( DerivedTrait::$variant, )+ ];

            /// Number of derived trait variants.
            pub const COUNT: usize = { let _variants = &[ $( DerivedTrait::$variant, )+ ]; _variants.len() };

            /// Parse a trait name string into a `DerivedTrait`.
            pub fn from_name(s: &str) -> Option<DerivedTrait> {
                match s {
                    $( $trait_name => Some(DerivedTrait::$variant), )+
                    _ => None,
                }
            }

            /// Get the method name for this derived trait.
            pub fn method_name(&self) -> &'static str {
                match self {
                    $( DerivedTrait::$variant => $method_name, )+
                }
            }

            /// Get the trait name string for this derived trait.
            pub fn trait_name(&self) -> &'static str {
                match self {
                    $( DerivedTrait::$variant => $trait_name, )+
                }
            }

            /// Get the parameter/return shape for this derived method.
            pub fn shape(&self) -> DerivedMethodShape {
                match self {
                    $( DerivedTrait::$variant => $shape, )+
                }
            }

            /// Get the required supertrait, if any.
            pub fn requires_supertrait(&self) -> Option<DerivedTrait> {
                match self {
                    $( DerivedTrait::$variant => $supertrait, )+
                }
            }

            /// Whether this trait can be derived for sum types (enums).
            pub fn supports_sum_types(&self) -> bool {
                match self {
                    $( DerivedTrait::$variant => $sum_support, )+
                }
            }
        }
    };
}

// Trait metadata table — the single source of truth for all derived traits.
//
// (Variant,    "TraitName",   "method",  Shape,                               Supertrait,                  SumTypes)
define_derived_traits! {
    (Eq,         "Eq",         "eq",      DerivedMethodShape::BinaryPredicate,  None,                       true),
    (Clone,      "Clone",      "clone",   DerivedMethodShape::UnaryIdentity,    None,                       true),
    (Hashable,   "Hashable",   "hash",    DerivedMethodShape::UnaryToInt,       Some(DerivedTrait::Eq),     true),
    (Printable,  "Printable",  "to_str",  DerivedMethodShape::UnaryToStr,       None,                       true),
    (Debug,      "Debug",      "debug",   DerivedMethodShape::UnaryToStr,       None,                       true),
    (Default,    "Default",    "default", DerivedMethodShape::Nullary,          None,                       false),
    (Comparable, "Comparable", "compare", DerivedMethodShape::BinaryToOrdering, Some(DerivedTrait::Eq),     true),
}

/// Information about a derived method.
///
/// Unlike user-defined methods, derived methods don't have expression bodies.
/// Instead, they operate on struct/enum field information.
#[derive(Clone, Debug, PartialEq, Eq, Hash)]
pub struct DerivedMethodInfo {
    /// The trait being derived.
    pub trait_kind: DerivedTrait,
    /// Field names for struct types (in declaration order).
    pub field_names: Vec<Name>,
    /// Variant names for sum types (in declaration order).
    ///
    /// Empty for struct types. Used by the evaluator to determine variant
    /// ordering for `Comparable` derivation and variant-aware `Hash` dispatch.
    pub variant_names: Vec<Name>,
}

impl DerivedMethodInfo {
    /// Create a new derived method info for a struct.
    pub fn new(trait_kind: DerivedTrait, field_names: Vec<Name>) -> Self {
        DerivedMethodInfo {
            trait_kind,
            field_names,
            variant_names: Vec::new(),
        }
    }

    /// Create a new derived method info for a sum type.
    ///
    /// # Panics (debug only)
    ///
    /// Panics if `variant_names` is empty — sum types must have at least one variant.
    pub fn new_sum(trait_kind: DerivedTrait, variant_names: Vec<Name>) -> Self {
        debug_assert!(
            !variant_names.is_empty(),
            "new_sum() requires at least one variant"
        );
        DerivedMethodInfo {
            trait_kind,
            field_names: Vec::new(),
            variant_names,
        }
    }
}

#[cfg(test)]
mod tests;
