//! User-defined method registry for impl block methods.
//!
//! This module stores methods defined in `impl` blocks so they can be
//! dispatched at runtime. Built-in methods take precedence,
//! but user-defined methods can extend types with new functionality.
//!
//! Also supports derived methods (`#[derive(Eq, Clone, ...)]`) which are
//! generated by the compiler without explicit method bodies.

#![allow(
    clippy::disallowed_types,
    reason = "Arc needed for cheap cloning of shared captures across methods"
)]

use crate::Value;
use ori_ir::canon::{CanId, SharedCanonResult};
use ori_ir::{DerivedMethodInfo, Name, SharedArena};
use rustc_hash::FxHashMap;
use std::sync::Arc;

use crate::method_key::MethodKey;

/// A user-defined method from an impl block.
///
/// Dispatches via canonical IR (`CanId`). Each method carries its own arena
/// and canonical result for thread-safe evaluation.
///
/// # Arena Requirement (Thread Safety)
/// Every method carries its own arena reference. This is required for thread
/// safety in parallel execution — when methods are called from different
/// contexts (e.g., parallel test runner), they need independent arena access.
///
/// # Captures
/// Uses `Arc<HashMap>` for captures to enable cheap cloning when registering
/// multiple methods from the same scope. The Arc is cloned (O(1)) rather than
/// the entire `HashMap`.
#[derive(Clone, Debug)]
pub struct UserMethod {
    /// Parameter names (first is always `self`).
    pub params: Vec<Name>,
    /// Canonical method body.
    pub can_body: CanId,
    /// Arena for evaluating the body (required for thread safety).
    pub arena: SharedArena,
    /// Canonical IR for canonical dispatch.
    pub canon: Option<SharedCanonResult>,
    /// Captured variables from the defining scope (Arc for cheap cloning).
    pub captures: Arc<FxHashMap<Name, Value>>,
    /// Expected key type name for discriminated dispatch.
    ///
    /// Set when a method is registered from a trait impl with type arguments
    /// (e.g., `impl Index<int, str> for T` → `key_type_hint = Some("int")`).
    /// Used at runtime to disambiguate when multiple methods share the same
    /// `(type_name, method_name)` key.
    pub key_type_hint: Option<Name>,
}

impl UserMethod {
    /// Create a new user method.
    ///
    /// # Arguments
    /// * `params` - Parameter names (first is always `self`)
    /// * `captures` - Captured variables from the defining scope (wrapped in Arc)
    /// * `arena` - Arena for expression resolution (required for thread safety)
    pub fn new(
        params: Vec<Name>,
        captures: Arc<FxHashMap<Name, Value>>,
        arena: SharedArena,
    ) -> Self {
        UserMethod {
            params,
            can_body: CanId::INVALID,
            arena,
            canon: None,
            captures,
            key_type_hint: None,
        }
    }

    /// Create a new user method from owned captures.
    ///
    /// Convenience method that wraps the captures in Arc.
    pub fn with_captures(
        params: Vec<Name>,
        captures: FxHashMap<Name, Value>,
        arena: SharedArena,
    ) -> Self {
        Self::new(params, Arc::new(captures), arena)
    }

    /// Attach canonical IR to this method for canonical dispatch.
    pub fn set_canon(&mut self, can_body: CanId, canon: SharedCanonResult) {
        self.can_body = can_body;
        self.canon = Some(canon);
    }
}

/// A method that can be either user-defined or derived.
#[derive(Clone, Debug)]
pub enum MethodEntry {
    /// User-defined method with an expression body.
    User(UserMethod),
    /// Derived method with field information.
    Derived(DerivedMethodInfo),
}

/// Registry for user-defined methods from impl blocks.
///
/// Methods are keyed by (`type_name`, `method_name`) pairs. Each key maps
/// to a `Vec<UserMethod>` to support multiple trait impls providing the same
/// method name (e.g., `Index<int, V>` + `Index<str, V>` both provide `index`).
///
/// Type names are strings like "Point", "int", "[int]", etc.
///
/// Also supports derived methods from `#[derive(...)]` attributes.
#[derive(Clone, Debug, Default)]
pub struct UserMethodRegistry {
    /// Map from method key to method definitions (Vec for multi-impl support).
    methods: FxHashMap<MethodKey, Vec<UserMethod>>,
    /// Map from method key to derived method info.
    derived_methods: FxHashMap<MethodKey, DerivedMethodInfo>,
}

impl UserMethodRegistry {
    /// Create a new empty registry.
    pub fn new() -> Self {
        UserMethodRegistry {
            methods: FxHashMap::default(),
            derived_methods: FxHashMap::default(),
        }
    }

    /// Register a user-defined method.
    ///
    /// Multiple methods can be registered for the same (type, name) pair,
    /// enabling multi-dispatch for traits like `Index<K, V>` with different
    /// key types.
    pub fn register(&mut self, type_name: Name, method_name: Name, method: UserMethod) {
        self.methods
            .entry(MethodKey::new(type_name, method_name))
            .or_default()
            .push(method);
    }

    /// Register a derived method.
    pub fn register_derived(
        &mut self,
        type_name: Name,
        method_name: Name,
        info: DerivedMethodInfo,
    ) {
        self.derived_methods
            .insert(MethodKey::new(type_name, method_name), info);
    }

    /// Look up a user-defined method (single-dispatch, returns first).
    ///
    /// For most methods, there is exactly one registration per key. When
    /// multiple exist (e.g., multiple Index impls), use `lookup_all()`.
    pub fn lookup(&self, type_name: Name, method_name: Name) -> Option<&UserMethod> {
        self.methods
            .get(&MethodKey::new(type_name, method_name))
            .and_then(|v| v.first())
    }

    /// Look up all user-defined methods for a (type, name) pair.
    ///
    /// Returns `None` if no methods registered, `Some(&[UserMethod])` otherwise.
    /// Used for multi-dispatch (e.g., multiple `Index<K, V>` impls).
    pub fn lookup_all(&self, type_name: Name, method_name: Name) -> Option<&[UserMethod]> {
        self.methods
            .get(&MethodKey::new(type_name, method_name))
            .map(Vec::as_slice)
    }

    /// Look up a derived method.
    pub fn lookup_derived(&self, type_name: Name, method_name: Name) -> Option<&DerivedMethodInfo> {
        self.derived_methods
            .get(&MethodKey::new(type_name, method_name))
    }

    /// Look up any method (user-defined or derived).
    ///
    /// For user methods, returns the first registered method.
    pub fn lookup_any(&self, type_name: Name, method_name: Name) -> Option<MethodEntry> {
        let key = MethodKey::new(type_name, method_name);

        if let Some(methods) = self.methods.get(&key) {
            if let Some(user_method) = methods.first() {
                return Some(MethodEntry::User(user_method.clone()));
            }
        }

        if let Some(derived_info) = self.derived_methods.get(&key) {
            return Some(MethodEntry::Derived(derived_info.clone()));
        }

        None
    }

    /// Check if a method exists for the given type (user or derived).
    pub fn has_method(&self, type_name: Name, method_name: Name) -> bool {
        let key = MethodKey::new(type_name, method_name);
        self.methods.get(&key).is_some_and(|v| !v.is_empty())
            || self.derived_methods.contains_key(&key)
    }

    /// Get all registered user methods (for debugging).
    pub fn all_methods(&self) -> impl Iterator<Item = (&MethodKey, &[UserMethod])> {
        self.methods.iter().map(|(k, v)| (k, v.as_slice()))
    }

    /// Get all registered derived methods (for debugging).
    pub fn all_derived_methods(&self) -> impl Iterator<Item = (&MethodKey, &DerivedMethodInfo)> {
        self.derived_methods.iter()
    }

    /// Merge another registry into this one.
    ///
    /// Concatenates method Vecs for keys that exist in both registries.
    pub fn merge(&mut self, other: UserMethodRegistry) {
        for (key, methods) in other.methods {
            self.methods.entry(key).or_default().extend(methods);
        }
        self.derived_methods.extend(other.derived_methods);
    }

    /// Check if a type has any methods registered (user or derived).
    ///
    /// This is useful for determining if a type name should be treated as
    /// a type reference for associated function calls.
    pub fn has_any_methods_for_type(&self, type_name: Name) -> bool {
        let has_user = self
            .methods
            .iter()
            .any(|(k, v)| k.type_name == type_name && !v.is_empty());
        if has_user {
            return true;
        }
        self.derived_methods
            .keys()
            .any(|k| k.type_name == type_name)
    }
}

#[cfg(test)]
#[expect(clippy::unwrap_used, reason = "Tests use unwrap for brevity")]
mod tests;
