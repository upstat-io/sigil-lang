//! User-defined method registry for impl block methods.
//!
//! This module stores methods defined in `impl` blocks so they can be
//! dispatched at runtime. Built-in methods take precedence,
//! but user-defined methods can extend types with new functionality.
//!
//! Also supports derived methods (`#[derive(Eq, Clone, ...)]`) which are
//! generated by the compiler without explicit method bodies.

#![allow(
    clippy::disallowed_types,
    reason = "Arc needed for cheap cloning of shared captures across methods"
)]

use crate::Value;
use ori_ir::canon::{CanId, SharedCanonResult};
use ori_ir::{DerivedMethodInfo, Name, SharedArena};
use rustc_hash::FxHashMap;
use std::sync::Arc;

use crate::method_key::MethodKey;

/// A user-defined method from an impl block.
///
/// Dispatches via canonical IR (`CanId`). Each method carries its own arena
/// and canonical result for thread-safe evaluation.
///
/// # Arena Requirement (Thread Safety)
/// Every method carries its own arena reference. This is required for thread
/// safety in parallel execution â€” when methods are called from different
/// contexts (e.g., parallel test runner), they need independent arena access.
///
/// # Captures
/// Uses `Arc<HashMap>` for captures to enable cheap cloning when registering
/// multiple methods from the same scope. The Arc is cloned (O(1)) rather than
/// the entire `HashMap`.
#[derive(Clone, Debug)]
pub struct UserMethod {
    /// Parameter names (first is always `self`).
    pub params: Vec<Name>,
    /// Canonical method body.
    pub can_body: CanId,
    /// Arena for evaluating the body (required for thread safety).
    pub arena: SharedArena,
    /// Canonical IR for canonical dispatch.
    pub canon: Option<SharedCanonResult>,
    /// Captured variables from the defining scope (Arc for cheap cloning).
    pub captures: Arc<FxHashMap<Name, Value>>,
}

impl UserMethod {
    /// Create a new user method.
    ///
    /// # Arguments
    /// * `params` - Parameter names (first is always `self`)
    /// * `captures` - Captured variables from the defining scope (wrapped in Arc)
    /// * `arena` - Arena for expression resolution (required for thread safety)
    pub fn new(
        params: Vec<Name>,
        captures: Arc<FxHashMap<Name, Value>>,
        arena: SharedArena,
    ) -> Self {
        UserMethod {
            params,
            can_body: CanId::INVALID,
            arena,
            canon: None,
            captures,
        }
    }

    /// Create a new user method from owned captures.
    ///
    /// Convenience method that wraps the captures in Arc.
    pub fn with_captures(
        params: Vec<Name>,
        captures: FxHashMap<Name, Value>,
        arena: SharedArena,
    ) -> Self {
        Self::new(params, Arc::new(captures), arena)
    }

    /// Attach canonical IR to this method for canonical dispatch.
    pub fn set_canon(&mut self, can_body: CanId, canon: SharedCanonResult) {
        self.can_body = can_body;
        self.canon = Some(canon);
    }
}

/// A method that can be either user-defined or derived.
#[derive(Clone, Debug)]
pub enum MethodEntry {
    /// User-defined method with an expression body.
    User(UserMethod),
    /// Derived method with field information.
    Derived(DerivedMethodInfo),
}

/// Registry for user-defined methods from impl blocks.
///
/// Methods are keyed by (`type_name`, `method_name`) pairs.
/// Type names are strings like "Point", "int", "[int]", etc.
///
/// Also supports derived methods from `#[derive(...)]` attributes.
#[derive(Clone, Debug, Default)]
pub struct UserMethodRegistry {
    /// Map from method key to method definition.
    methods: FxHashMap<MethodKey, UserMethod>,
    /// Map from method key to derived method info.
    derived_methods: FxHashMap<MethodKey, DerivedMethodInfo>,
}

impl UserMethodRegistry {
    /// Create a new empty registry.
    pub fn new() -> Self {
        UserMethodRegistry {
            methods: FxHashMap::default(),
            derived_methods: FxHashMap::default(),
        }
    }

    /// Register a user-defined method.
    ///
    /// # Arguments
    /// * `type_name` - The type this method is defined on (interned)
    /// * `method_name` - The method name (interned)
    /// * `method` - The method definition
    pub fn register(&mut self, type_name: Name, method_name: Name, method: UserMethod) {
        self.methods
            .insert(MethodKey::new(type_name, method_name), method);
    }

    /// Register a derived method.
    ///
    /// # Arguments
    /// * `type_name` - The type this method is defined on (interned)
    /// * `method_name` - The method name (interned)
    /// * `info` - The derived method information
    pub fn register_derived(
        &mut self,
        type_name: Name,
        method_name: Name,
        info: DerivedMethodInfo,
    ) {
        self.derived_methods
            .insert(MethodKey::new(type_name, method_name), info);
    }

    /// Look up a user-defined method.
    ///
    /// Returns None if no method is registered for this type/method combination.
    pub fn lookup(&self, type_name: Name, method_name: Name) -> Option<&UserMethod> {
        self.methods.get(&MethodKey::new(type_name, method_name))
    }

    /// Look up a derived method.
    ///
    /// Returns None if no derived method is registered for this type/method combination.
    pub fn lookup_derived(&self, type_name: Name, method_name: Name) -> Option<&DerivedMethodInfo> {
        self.derived_methods
            .get(&MethodKey::new(type_name, method_name))
    }

    /// Look up any method (user-defined or derived).
    ///
    /// Returns the method entry if found.
    pub fn lookup_any(&self, type_name: Name, method_name: Name) -> Option<MethodEntry> {
        let key = MethodKey::new(type_name, method_name);

        if let Some(user_method) = self.methods.get(&key) {
            return Some(MethodEntry::User(user_method.clone()));
        }

        if let Some(derived_info) = self.derived_methods.get(&key) {
            return Some(MethodEntry::Derived(derived_info.clone()));
        }

        None
    }

    /// Check if a method exists for the given type (user or derived).
    pub fn has_method(&self, type_name: Name, method_name: Name) -> bool {
        let key = MethodKey::new(type_name, method_name);
        self.methods.contains_key(&key) || self.derived_methods.contains_key(&key)
    }

    /// Get all registered user methods (for debugging).
    pub fn all_methods(&self) -> impl Iterator<Item = (&MethodKey, &UserMethod)> {
        self.methods.iter()
    }

    /// Get all registered derived methods (for debugging).
    pub fn all_derived_methods(&self) -> impl Iterator<Item = (&MethodKey, &DerivedMethodInfo)> {
        self.derived_methods.iter()
    }

    /// Merge another registry into this one.
    pub fn merge(&mut self, other: UserMethodRegistry) {
        self.methods.extend(other.methods);
        self.derived_methods.extend(other.derived_methods);
    }

    /// Check if a type has any methods registered (user or derived).
    ///
    /// This is useful for determining if a type name should be treated as
    /// a type reference for associated function calls.
    pub fn has_any_methods_for_type(&self, type_name: Name) -> bool {
        // Check if any user method is registered for this type
        let has_user = self.methods.keys().any(|k| k.type_name == type_name);
        if has_user {
            return true;
        }
        // Check if any derived method is registered for this type
        self.derived_methods
            .keys()
            .any(|k| k.type_name == type_name)
    }
}

#[cfg(test)]
#[expect(clippy::unwrap_used, reason = "Tests use unwrap for brevity")]
mod tests;
