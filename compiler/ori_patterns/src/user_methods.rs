//! User-defined method registry for impl block methods.
//!
//! This module stores methods defined in `impl` blocks so they can be
//! dispatched at runtime. Built-in methods take precedence,
//! but user-defined methods can extend types with new functionality.
//!
//! Also supports derived methods (`#[derive(Eq, Clone, ...)]`) which are
//! generated by the compiler without explicit method bodies.

use crate::Value;
use ori_ir::{DerivedMethodInfo, ExprId, Name, SharedArena};
use std::collections::HashMap;

use crate::method_key::MethodKey;

/// A user-defined method from an impl block.
///
/// # Arena Requirement (Thread Safety)
/// Every method carries its own arena reference. This is required for thread
/// safety in parallel execution - when methods are called from different
/// contexts (e.g., parallel test runner), they must use their own arena to
/// resolve `ExprId` values correctly.
#[derive(Clone, Debug)]
pub struct UserMethod {
    /// Parameter names (first is always `self`).
    pub params: Vec<Name>,
    /// Method body expression.
    pub body: ExprId,
    /// Arena for evaluating the body (required for thread safety).
    pub arena: SharedArena,
    /// Captured variables from the defining scope.
    pub captures: HashMap<Name, Value>,
}

impl UserMethod {
    /// Create a new user method.
    ///
    /// # Arguments
    /// * `params` - Parameter names (first is always `self`)
    /// * `body` - Method body expression ID
    /// * `captures` - Captured variables from the defining scope
    /// * `arena` - Arena for expression resolution (required for thread safety)
    pub fn new(
        params: Vec<Name>,
        body: ExprId,
        captures: HashMap<Name, Value>,
        arena: SharedArena,
    ) -> Self {
        UserMethod {
            params,
            body,
            arena,
            captures,
        }
    }
}

/// A method that can be either user-defined or derived.
#[derive(Clone, Debug)]
pub enum MethodEntry {
    /// User-defined method with an expression body.
    User(UserMethod),
    /// Derived method with field information.
    Derived(DerivedMethodInfo),
}

/// Registry for user-defined methods from impl blocks.
///
/// Methods are keyed by (`type_name`, `method_name`) pairs.
/// Type names are strings like "Point", "int", "[int]", etc.
///
/// Also supports derived methods from `#[derive(...)]` attributes.
#[derive(Clone, Debug, Default)]
pub struct UserMethodRegistry {
    /// Map from method key to method definition.
    methods: HashMap<MethodKey, UserMethod>,
    /// Map from method key to derived method info.
    derived_methods: HashMap<MethodKey, DerivedMethodInfo>,
}

impl UserMethodRegistry {
    /// Create a new empty registry.
    pub fn new() -> Self {
        UserMethodRegistry {
            methods: HashMap::new(),
            derived_methods: HashMap::new(),
        }
    }

    /// Register a user-defined method.
    ///
    /// # Arguments
    /// * `type_name` - The type this method is defined on (interned)
    /// * `method_name` - The method name (interned)
    /// * `method` - The method definition
    pub fn register(&mut self, type_name: Name, method_name: Name, method: UserMethod) {
        self.methods
            .insert(MethodKey::new(type_name, method_name), method);
    }

    /// Register a derived method.
    ///
    /// # Arguments
    /// * `type_name` - The type this method is defined on (interned)
    /// * `method_name` - The method name (interned)
    /// * `info` - The derived method information
    pub fn register_derived(
        &mut self,
        type_name: Name,
        method_name: Name,
        info: DerivedMethodInfo,
    ) {
        self.derived_methods
            .insert(MethodKey::new(type_name, method_name), info);
    }

    /// Look up a user-defined method.
    ///
    /// Returns None if no method is registered for this type/method combination.
    pub fn lookup(&self, type_name: Name, method_name: Name) -> Option<&UserMethod> {
        self.methods.get(&MethodKey::new(type_name, method_name))
    }

    /// Look up a derived method.
    ///
    /// Returns None if no derived method is registered for this type/method combination.
    pub fn lookup_derived(&self, type_name: Name, method_name: Name) -> Option<&DerivedMethodInfo> {
        self.derived_methods
            .get(&MethodKey::new(type_name, method_name))
    }

    /// Look up any method (user-defined or derived).
    ///
    /// Returns the method entry if found.
    pub fn lookup_any(&self, type_name: Name, method_name: Name) -> Option<MethodEntry> {
        let key = MethodKey::new(type_name, method_name);

        if let Some(user_method) = self.methods.get(&key) {
            return Some(MethodEntry::User(user_method.clone()));
        }

        if let Some(derived_info) = self.derived_methods.get(&key) {
            return Some(MethodEntry::Derived(derived_info.clone()));
        }

        None
    }

    /// Check if a method exists for the given type (user or derived).
    pub fn has_method(&self, type_name: Name, method_name: Name) -> bool {
        let key = MethodKey::new(type_name, method_name);
        self.methods.contains_key(&key) || self.derived_methods.contains_key(&key)
    }

    /// Get all registered user methods (for debugging).
    pub fn all_methods(&self) -> impl Iterator<Item = (&MethodKey, &UserMethod)> {
        self.methods.iter()
    }

    /// Get all registered derived methods (for debugging).
    pub fn all_derived_methods(&self) -> impl Iterator<Item = (&MethodKey, &DerivedMethodInfo)> {
        self.derived_methods.iter()
    }

    /// Merge another registry into this one.
    pub fn merge(&mut self, other: UserMethodRegistry) {
        self.methods.extend(other.methods);
        self.derived_methods.extend(other.derived_methods);
    }
}

#[cfg(test)]
#[expect(clippy::unwrap_used, reason = "Tests use unwrap for brevity")]
mod tests {
    use super::*;
    use ori_ir::{DerivedMethodInfo, DerivedTrait, ExprArena, ExprId, SharedInterner};

    fn dummy_expr_id() -> ExprId {
        ExprId::new(0)
    }

    fn dummy_name() -> Name {
        let interner = SharedInterner::default();
        interner.intern("dummy")
    }

    fn dummy_arena() -> SharedArena {
        SharedArena::new(ExprArena::new())
    }

    #[test]
    fn test_register_and_lookup() {
        let interner = SharedInterner::default();
        let mut registry = UserMethodRegistry::new();
        let method = UserMethod::new(
            vec![dummy_name()],
            dummy_expr_id(),
            HashMap::new(),
            dummy_arena(),
        );

        let point = interner.intern("Point");
        let distance = interner.intern("distance");
        let other = interner.intern("other");
        let other_type = interner.intern("Other");

        registry.register(point, distance, method);

        assert!(registry.has_method(point, distance));
        assert!(!registry.has_method(point, other));
        assert!(!registry.has_method(other_type, distance));

        let found = registry.lookup(point, distance);
        assert!(found.is_some());
    }

    #[test]
    fn test_empty_registry() {
        let interner = SharedInterner::default();
        let registry = UserMethodRegistry::new();
        let point = interner.intern("Point");
        let distance = interner.intern("distance");

        assert!(!registry.has_method(point, distance));
        assert!(registry.lookup(point, distance).is_none());
    }

    #[test]
    fn test_derived_trait_from_name() {
        assert_eq!(DerivedTrait::from_name("Eq"), Some(DerivedTrait::Eq));
        assert_eq!(DerivedTrait::from_name("Clone"), Some(DerivedTrait::Clone));
        assert_eq!(
            DerivedTrait::from_name("Hashable"),
            Some(DerivedTrait::Hashable)
        );
        assert_eq!(
            DerivedTrait::from_name("Printable"),
            Some(DerivedTrait::Printable)
        );
        assert_eq!(
            DerivedTrait::from_name("Default"),
            Some(DerivedTrait::Default)
        );
        assert_eq!(DerivedTrait::from_name("Unknown"), None);
    }

    #[test]
    fn test_derived_trait_method_name() {
        assert_eq!(DerivedTrait::Eq.method_name(), "eq");
        assert_eq!(DerivedTrait::Clone.method_name(), "clone");
        assert_eq!(DerivedTrait::Hashable.method_name(), "hash");
        assert_eq!(DerivedTrait::Printable.method_name(), "to_string");
        assert_eq!(DerivedTrait::Default.method_name(), "default");
    }

    #[test]
    fn test_register_and_lookup_derived() {
        let interner = SharedInterner::default();
        let mut registry = UserMethodRegistry::new();

        let point = interner.intern("Point");
        let eq = interner.intern("eq");
        let x_name = interner.intern("x");
        let y_name = interner.intern("y");
        let info = DerivedMethodInfo::new(DerivedTrait::Eq, vec![x_name, y_name]);

        registry.register_derived(point, eq, info);

        assert!(registry.has_method(point, eq));
        assert!(registry.lookup_derived(point, eq).is_some());
        assert!(registry.lookup(point, eq).is_none()); // not a user method

        let found = registry.lookup_derived(point, eq).unwrap();
        assert_eq!(found.trait_kind, DerivedTrait::Eq);
        assert_eq!(found.field_names.len(), 2);
    }

    #[test]
    fn test_lookup_any() {
        let interner = SharedInterner::default();
        let mut registry = UserMethodRegistry::new();

        let point = interner.intern("Point");
        let distance = interner.intern("distance");
        let eq = interner.intern("eq");
        let nonexistent = interner.intern("nonexistent");

        // Register a user method
        let method = UserMethod::new(
            vec![dummy_name()],
            dummy_expr_id(),
            HashMap::new(),
            dummy_arena(),
        );
        registry.register(point, distance, method);

        // Register a derived method
        let x_name = interner.intern("x");
        let info = DerivedMethodInfo::new(DerivedTrait::Eq, vec![x_name]);
        registry.register_derived(point, eq, info);

        // Lookup user method via lookup_any
        if let Some(MethodEntry::User(_)) = registry.lookup_any(point, distance) {
            // ok
        } else {
            panic!("Expected User method entry");
        }

        // Lookup derived method via lookup_any
        if let Some(MethodEntry::Derived(info)) = registry.lookup_any(point, eq) {
            assert_eq!(info.trait_kind, DerivedTrait::Eq);
        } else {
            panic!("Expected Derived method entry");
        }

        // Lookup non-existent method
        assert!(registry.lookup_any(point, nonexistent).is_none());
    }

    #[test]
    fn test_merge_registries() {
        let interner = SharedInterner::default();
        let mut registry1 = UserMethodRegistry::new();
        let mut registry2 = UserMethodRegistry::new();

        let point = interner.intern("Point");
        let distance = interner.intern("distance");
        let clone_name = interner.intern("clone");

        // Register in first registry
        let method = UserMethod::new(
            vec![dummy_name()],
            dummy_expr_id(),
            HashMap::new(),
            dummy_arena(),
        );
        registry1.register(point, distance, method);

        // Register derived in second registry
        let x_name = interner.intern("x");
        let info = DerivedMethodInfo::new(DerivedTrait::Clone, vec![x_name]);
        registry2.register_derived(point, clone_name, info);

        // Merge
        registry1.merge(registry2);

        // Both should be present
        assert!(registry1.has_method(point, distance));
        assert!(registry1.has_method(point, clone_name));
    }
}
