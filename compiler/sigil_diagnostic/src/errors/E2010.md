# E2010: Coherence Violation

There are conflicting trait implementations for the same type.

## Example

```sigil
impl Printable for int {
    @to_string (self) -> str = "custom int"
}

impl Printable for int {    // Error: conflicting implementation
    @to_string (self) -> str = "another int"
}
```

## Explanation

Sigil enforces coherence rules: each type can have at most one implementation
of any trait. This ensures that trait method calls are unambiguous.

## Common Causes

1. **Duplicate impl blocks:**
   ```sigil
   // Wrong - two impls for same type
   impl Eq for Point { ... }
   impl Eq for Point { ... }
   ```

2. **Overlapping generic implementations:**
   ```sigil
   // Wrong - these overlap
   impl<T> Printable for [T] { ... }
   impl Printable for [int] { ... }    // Conflicts with above
   ```

3. **Conflicting blanket implementations:**
   ```sigil
   // Wrong - too broad
   impl<T> MyTrait for T { ... }
   impl MyTrait for int { ... }    // Conflicts with blanket impl
   ```

## Solutions

1. **Remove the duplicate implementation:**
   ```sigil
   // Keep only one
   impl Printable for int {
       @to_string (self) -> str = str(self)
   }
   ```

2. **Use more specific bounds:**
   ```sigil
   // Instead of two overlapping impls
   impl<T: Printable> MyTrait for [T] {
       // Handle printable items
   }

   // No conflict - different bound
   impl<T: Default> OtherTrait for [T] {
       // Handle defaultable items
   }
   ```

3. **Use newtypes for different behavior:**
   ```sigil
   type DebugInt = int
   type DisplayInt = int

   impl Printable for DebugInt {
       @to_string (self) -> str = "debug: " + str(self)
   }

   impl Printable for DisplayInt {
       @to_string (self) -> str = str(self)
   }
   ```

## Orphan Rules

You can only implement:
- Your own traits for any type
- Any trait for your own types

You cannot implement external traits for external types.

## See Also

- E2009: Missing trait bound
- E2006: Duplicate definition
