# E2009: Missing Trait Bound

A generic type parameter is used in a way that requires a trait it doesn't have.

## Example

```sigil
@sort<T> (items: [T]) -> [T] = run(
    // Error: T needs Comparable to be sorted
    items.sort()
)
```

## Explanation

When using generic types, certain operations require the type to implement
specific traits. If the type parameter doesn't have the required bound, the
compiler cannot guarantee the operation is valid.

## Common Causes

1. **Comparison without Comparable:**
   ```sigil
   // Wrong
   @max<T> (a: T, b: T) -> T = if a > b then a else b

   // Right
   @max<T: Comparable> (a: T, b: T) -> T = if a > b then a else b
   ```

2. **Equality without Eq:**
   ```sigil
   // Wrong
   @contains<T> (items: [T], target: T) -> bool = ...

   // Right
   @contains<T: Eq> (items: [T], target: T) -> bool = ...
   ```

3. **Printing without Printable:**
   ```sigil
   // Wrong
   @debug<T> (value: T) -> void = print(msg: str(value))

   // Right
   @debug<T: Printable> (value: T) -> void = print(msg: str(value))
   ```

## Common Trait Bounds

| Trait | Required For |
|-------|-------------|
| `Eq` | `==`, `!=`, `.contains()` |
| `Comparable` | `<`, `>`, `<=`, `>=`, `.sort()`, `min()`, `max()` |
| `Hashable` | Map keys, Set elements |
| `Printable` | String conversion, printing |
| `Clone` | Explicit copying |
| `Default` | Default values |

## Solutions

1. **Add the required bound:**
   ```sigil
   @sort<T: Comparable> (items: [T]) -> [T] = items.sort()
   ```

2. **Multiple bounds:**
   ```sigil
   @process<T: Eq + Printable> (value: T) -> void = run(
       if value == default_value then
           print(msg: "default")
       else
           print(msg: str(value))
   )
   ```

3. **Where clauses for complex bounds:**
   ```sigil
   @merge<K, V> (a: {K: V}, b: {K: V}) -> {K: V}
       where K: Eq + Hashable, V: Clone = ...
   ```

## See Also

- E2010: Coherence violation
- E2001: Type mismatch
