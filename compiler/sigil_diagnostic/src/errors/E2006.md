# E2006: Duplicate Definition

A name is defined more than once in the same scope.

## Example

```sigil
@add (a: int, b: int) -> int = a + b
@add (x: int, y: int) -> int = x + y    // Error: duplicate definition 'add'
```

## Explanation

Each name can only be defined once within a scope. This applies to:
- Functions
- Types
- Traits
- Config variables
- Local bindings (though shadowing is allowed in nested scopes)

## Common Causes

1. **Duplicate function definitions:**
   ```sigil
   // Wrong
   @process (x: int) -> int = x * 2
   @process (x: int) -> int = x + 1    // Error

   // Sigil doesn't have function overloading
   ```

2. **Duplicate type definitions:**
   ```sigil
   // Wrong
   type User = { name: str }
   type User = { id: int, name: str }    // Error
   ```

3. **Conflicting imports:**
   ```sigil
   // Wrong
   use './a' { helper }
   use './b' { helper }    // Error: duplicate 'helper'

   // Right - use aliases
   use './a' { helper as helper_a }
   use './b' { helper as helper_b }
   ```

## Shadowing vs Duplicate Definition

Shadowing (in nested scope) is allowed:
```sigil
@example () -> int = run(
    let x = 1,
    let x = x + 1,    // OK: shadowing in sequence
    x
)
```

Duplicate definition (same scope) is not:
```sigil
// Error: same scope, same name
@foo () -> int = 1
@foo () -> int = 2
```

## Solutions

1. **Rename one of the definitions:**
   ```sigil
   @process_v1 (x: int) -> int = x * 2
   @process_v2 (x: int) -> int = x + 1
   ```

2. **Use aliases for imports:**
   ```sigil
   use './math' { add as math_add }
   use './string' { add as string_add }
   ```

3. **For generic behavior, use traits:**
   ```sigil
   trait Processable {
       @process (self) -> Self
   }

   impl Processable for int { ... }
   impl Processable for str { ... }
   ```

## See Also

- E2003: Unknown identifier
- E1014: Reserved built-in function name
