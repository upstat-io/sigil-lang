# E2008: Cyclic Type Definition

A type definition references itself, creating an infinite type.

## Example

```sigil
type Node = { value: int, next: Node }    // Error: cyclic type
```

## Explanation

Type definitions cannot directly reference themselves without indirection.
A type like `Node = { next: Node }` would require infinite memory to represent.

## Common Causes

1. **Direct self-reference in struct:**
   ```sigil
   // Wrong - infinite size
   type Node = { value: int, next: Node }
   ```

2. **Indirect cycle:**
   ```sigil
   // Wrong - A references B, B references A
   type A = { b: B }
   type B = { a: A }
   ```

## Solutions

1. **Use Option for optional self-reference:**
   ```sigil
   type Node = { value: int, next: Option<Node> }
   ```

2. **Use a sum type for recursive structures:**
   ```sigil
   type List<T> = Nil | Cons(head: T, tail: List<T>)

   // Usage
   let list = Cons(head: 1, tail: Cons(head: 2, tail: Nil))
   ```

3. **For trees:**
   ```sigil
   type Tree<T> = Leaf(value: T) | Branch(left: Tree<T>, right: Tree<T>)
   ```

4. **Break the cycle with Option:**
   ```sigil
   type A = { b: Option<B> }
   type B = { a: Option<A> }
   ```

## Recursive Data Structures

Sigil supports recursive types through sum types (enums) because they have
a base case that terminates the recursion:

```sigil
// This works because Nil terminates the recursion
type LinkedList<T> = Nil | Node(value: T, next: LinkedList<T>)

// This works because Leaf terminates the recursion
type BinaryTree<T> = Leaf(T) | Branch(Tree<T>, Tree<T>)
```

## See Also

- E2007: Closure self-reference
- E2002: Unknown type
