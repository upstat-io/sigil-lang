//! C Code Generation Backend
//!
//! Generates C code from typed Sigil modules with performance optimizations:
//! - Unboxed enums for `Option<primitive>` and `Result<primitive, E>`
//! - Small String Optimization (SSO) for strings â‰¤23 bytes
//! - ARC elision based on ownership analysis

mod expr;
mod function;
mod runtime;
mod stmt;
mod types;

pub use runtime::CRuntime;
pub use types::CTypeMapper;

use sigil_ir::{ExprArena, Module, StringInterner};
use sigil_types::TypeInterner;

use crate::analysis::{OwnershipAnalysis, OwnershipInfo};
use crate::context::CodegenContext;
use crate::CodegenResult;

/// C code generator.
///
/// Generates C code from a typed Sigil module.
pub struct CCodegen<'a> {
    /// The expression arena.
    arena: &'a ExprArena,
    /// The string interner.
    interner: &'a StringInterner,
    /// The type interner.
    type_interner: &'a TypeInterner,
    /// Types for each expression.
    expr_types: &'a [sigil_ir::TypeId],
    /// Ownership analysis results.
    ownership: OwnershipInfo,
}

impl<'a> CCodegen<'a> {
    /// Create a new C code generator.
    pub fn new(
        arena: &'a ExprArena,
        interner: &'a StringInterner,
        type_interner: &'a TypeInterner,
        expr_types: &'a [sigil_ir::TypeId],
    ) -> Self {
        Self {
            arena,
            interner,
            type_interner,
            expr_types,
            ownership: OwnershipInfo::default(),
        }
    }

    /// Run ownership analysis for ARC elision.
    pub fn analyze_ownership(&mut self, root: sigil_ir::ExprId) {
        let analysis = OwnershipAnalysis::new(
            self.arena,
            self.type_interner,
            self.expr_types,
        );
        self.ownership = analysis.analyze(root);
    }

    /// Generate C code for a module.
    pub fn generate(&self, module: &Module) -> CodegenResult {
        let mut ctx = CodegenContext::new(
            self.interner,
            self.type_interner,
            self.expr_types,
        )
        .with_ownership(self.ownership.clone());

        // Generate header with includes and runtime types
        self.emit_header(&mut ctx);

        // Generate forward declarations
        self.emit_forward_declarations(&mut ctx, module);

        // Generate each function
        for func in &module.functions {
            self.emit_function(&mut ctx, func);
        }

        // Generate main wrapper if needed
        if let Some(main_func) = module.functions.iter().find(|f| {
            self.interner.lookup(f.name) == "main"
        }) {
            self.emit_main_wrapper(&mut ctx, main_func);
        }

        CodegenResult::success(ctx.take_output())
    }

    /// Emit the C header with includes and runtime definitions.
    fn emit_header(&self, ctx: &mut CodegenContext<'_>) {
        ctx.writeln("// Generated by Sigil Compiler");
        ctx.writeln("// DO NOT EDIT - This file is automatically generated");
        ctx.newline();
        ctx.writeln("#include <stdint.h>");
        ctx.writeln("#include <stdbool.h>");
        ctx.writeln("#include <stdlib.h>");
        ctx.writeln("#include <string.h>");
        ctx.writeln("#include <stdio.h>");
        ctx.newline();

        // Emit runtime type definitions
        CRuntime::emit_types(ctx);
        ctx.newline();

        // Emit runtime function declarations
        CRuntime::emit_functions(ctx);
        ctx.newline();
    }

    /// Emit forward declarations for all functions.
    fn emit_forward_declarations(&self, ctx: &mut CodegenContext<'_>, module: &Module) {
        ctx.writeln("// Forward declarations");
        for func in &module.functions {
            let name = ctx.mangle(func.name);
            let params = self.arena.get_params(func.params);

            // Get return type
            let ret_type = self.map_return_type(func);

            ctx.write_indent();
            ctx.write(&ret_type);
            ctx.write(" ");
            ctx.write(&name);
            ctx.write("(");

            if params.is_empty() {
                ctx.write("void");
            } else {
                for (i, param) in params.iter().enumerate() {
                    if i > 0 {
                        ctx.write(", ");
                    }
                    // Use the type annotation if present
                    let param_type = if let Some(ref parsed_ty) = param.ty {
                        CTypeMapper::map_parsed_type(parsed_ty, self.interner)
                    } else {
                        "void*".to_string() // Fallback for untyped params
                    };
                    ctx.write(&param_type);
                    ctx.write(" ");
                    ctx.write(&ctx.mangle(param.name));
                }
            }

            ctx.write(");\n");
        }
        ctx.newline();
    }

    /// Map the return type of a function.
    fn map_return_type(&self, func: &sigil_ir::ast::Function) -> String {
        if let Some(ret_ty) = &func.return_ty {
            CTypeMapper::map_parsed_type(ret_ty, self.interner)
        } else {
            "void".to_string()
        }
    }

    /// Emit a function definition.
    fn emit_function(&self, ctx: &mut CodegenContext<'_>, func: &sigil_ir::ast::Function) {
        let name = ctx.mangle(func.name);
        let params = self.arena.get_params(func.params);

        // Get return type
        let ret_type = self.map_return_type(func);

        ctx.write_indent();
        ctx.write(&ret_type);
        ctx.write(" ");
        ctx.write(&name);
        ctx.write("(");

        if params.is_empty() {
            ctx.write("void");
        } else {
            for (i, param) in params.iter().enumerate() {
                if i > 0 {
                    ctx.write(", ");
                }
                // Use the type annotation if present
                let param_type = if let Some(ref parsed_ty) = param.ty {
                    CTypeMapper::map_parsed_type(parsed_ty, self.interner)
                } else {
                    "void*".to_string() // Fallback for untyped params
                };
                ctx.write(&param_type);
                ctx.write(" ");
                ctx.write(&ctx.mangle(param.name));
            }
        }

        ctx.write(") {\n");
        ctx.indent();

        // Generate function body
        function::emit_body(ctx, self.arena, func.body, &ret_type != "void");

        ctx.dedent();
        ctx.writeln("}");
        ctx.newline();
    }

    /// Emit the main() wrapper that calls the Sigil @main function.
    fn emit_main_wrapper(&self, ctx: &mut CodegenContext<'_>, func: &sigil_ir::ast::Function) {
        let sigil_main = ctx.mangle(func.name);
        let ret_type = self.map_return_type(func);

        ctx.writeln("int main(int argc, char** argv) {");
        ctx.indent();

        // Initialize runtime
        ctx.writeln("sigil_runtime_init();");

        if ret_type == "int64_t" || ret_type == "int" {
            // Return int - use as exit code
            ctx.write_indent();
            ctx.write("int64_t result = ");
            ctx.write(&sigil_main);
            ctx.write("();\n");
            ctx.writeln("sigil_runtime_cleanup();");
            ctx.writeln("return (int)result;");
        } else if ret_type == "void" {
            // Return void - exit code 0
            ctx.write_indent();
            ctx.write(&sigil_main);
            ctx.write("();\n");
            ctx.writeln("sigil_runtime_cleanup();");
            ctx.writeln("return 0;");
        } else {
            // Other return type - ignore and exit 0
            ctx.write_indent();
            ctx.write(&sigil_main);
            ctx.write("();\n");
            ctx.writeln("sigil_runtime_cleanup();");
            ctx.writeln("return 0;");
        }

        ctx.dedent();
        ctx.writeln("}");
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_codegen_empty_module() {
        let arena = ExprArena::new();
        let interner = StringInterner::new();
        let type_interner = TypeInterner::new();

        let module = Module::default();
        let codegen = CCodegen::new(&arena, &interner, &type_interner, &[]);
        let result = codegen.generate(&module);

        assert!(result.success);
        assert!(result.code.contains("#include <stdint.h>"));
        assert!(result.code.contains("sigil_string_t"));
    }
}
