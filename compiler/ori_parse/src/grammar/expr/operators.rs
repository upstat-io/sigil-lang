//! Operator Matching Helpers
//!
//! Helper methods for matching operators during parsing:
//! - `infix_binding_power`: Pratt parser binding power table for binary operators
//! - `match_unary_op`: Unary operator detection
//! - `match_function_exp_kind`: Pattern/function keyword detection
//!
//! # Specification
//!
//! - Syntax: `docs/ori_lang/0.1-alpha/spec/grammar.ebnf` § EXPRESSIONS
//! - Semantics: `docs/ori_lang/0.1-alpha/spec/operator-rules.md`
//! - Precedence: `docs/ori_lang/0.1-alpha/spec/operator-rules.md` § Precedence Table
//!
//! ## Compound Operators
//!
//! The lexer produces individual `>` tokens to enable parsing nested generics
//! like `Result<Result<T, E>, E>`. In expression context, the parser combines
//! adjacent `>` tokens into compound operators:
//!
//! - `>` followed by `>` (no whitespace) → `>>` (right shift)
//! - `>` followed by `=` (no whitespace) → `>=` (greater-equal)

use super::bp;
use crate::context::ParseContext;
use crate::Parser;
use ori_ir::{BinaryOp, FunctionExpKind, TokenKind, UnaryOp};

/// Packed operator info for the static lookup table.
///
/// Stores left/right binding power, `BinaryOp` variant (as u8), and token count
/// in 4 bytes. A `left_bp` of 0 means "not an operator".
#[derive(Clone, Copy)]
struct OperInfo {
    left_bp: u8,
    right_bp: u8,
    op: u8,
    token_count: u8,
}

impl OperInfo {
    const NONE: Self = OperInfo {
        left_bp: 0,
        right_bp: 0,
        op: 0,
        token_count: 0,
    };

    const fn new(left_bp: u8, right_bp: u8, op: u8, token_count: u8) -> Self {
        OperInfo {
            left_bp,
            right_bp,
            op,
            token_count,
        }
    }
}

/// Declare the operator table, `op_from_u8()`, and `TABLE_OPERATOR_COUNT` from
/// a single list. Indices are auto-assigned — no manual coordination needed.
///
/// Each entry: `TAG_CONSTANT, BinaryOpVariant, bp_pair, token_count;`
///
/// Operators NOT in this table (handled as special cases in `infix_binding_power`):
/// - `Range`, `RangeInclusive` — non-associative, parsed in the Pratt loop
/// - `GtEq`, `Shr` — compound tokens synthesized from `>` + `=`/`>`
macro_rules! define_operators {
    ( $( $tag:expr, $op:ident, $bp:expr, $token_count:expr; )* ) => {
        /// Number of operators in the table (excludes special-case operators).
        #[cfg(test)]
        const TABLE_OPERATOR_COUNT: usize = {
            let mut count = 0usize;
            $( let _ = $tag; count += 1; )*
            count
        };

        /// Convert a `u8` op index back to `BinaryOp`.
        ///
        /// Indices are auto-generated by `define_operators!` and match `OPER_TABLE`.
        #[inline]
        fn op_from_u8(op: u8) -> BinaryOp {
            let mut _idx: u8 = 0;
            $(
                if op == _idx { return BinaryOp::$op; }
                _idx += 1;
            )*
            unreachable!()
        }

        /// Static lookup table indexed by token discriminant tag.
        ///
        /// For each tag that represents a binary operator, stores the binding powers,
        /// op variant, and token count. Non-operator tags have `left_bp == 0`.
        ///
        /// The `Gt` token is special: it maps to `BinaryOp::Gt` here,
        /// but compound `>=` and `>>` are handled separately at the call site.
        static OPER_TABLE: [OperInfo; 128] = {
            let mut table = [OperInfo::NONE; 128];
            let mut _idx: u8 = 0;
            $(
                table[$tag as usize] = OperInfo::new($bp.0, $bp.1, _idx, $token_count);
                _idx += 1;
            )*
            table
        };
    };
}

define_operators! {
    // Coalesce (right-associative)
    TokenKind::TAG_DOUBLE_QUESTION, Coalesce,  bp::COALESCE,       1;
    // Logical
    TokenKind::TAG_PIPEPIPE,        Or,        bp::OR,             1;
    TokenKind::TAG_AMPAMP,          And,       bp::AND,            1;
    // Bitwise
    TokenKind::TAG_PIPE,            BitOr,     bp::BIT_OR,         1;
    TokenKind::TAG_CARET,           BitXor,    bp::BIT_XOR,        1;
    TokenKind::TAG_AMP,             BitAnd,    bp::BIT_AND,        1;
    // Equality
    TokenKind::TAG_EQEQ,           Eq,        bp::EQUALITY,       1;
    TokenKind::TAG_NOTEQ,          NotEq,     bp::EQUALITY,       1;
    // Comparison
    TokenKind::TAG_LT,             Lt,        bp::COMPARISON,     1;
    TokenKind::TAG_LTEQ,           LtEq,      bp::COMPARISON,     1;
    TokenKind::TAG_GT,             Gt,        bp::COMPARISON,     1;
    // Shift
    TokenKind::TAG_SHL,            Shl,       bp::SHIFT,          1;
    // Additive
    TokenKind::TAG_PLUS,           Add,       bp::ADDITIVE,       1;
    TokenKind::TAG_MINUS,          Sub,       bp::ADDITIVE,       1;
    // Multiplicative
    TokenKind::TAG_STAR,           Mul,       bp::MULTIPLICATIVE,  1;
    TokenKind::TAG_SLASH,          Div,       bp::MULTIPLICATIVE,  1;
    TokenKind::TAG_PERCENT,        Mod,       bp::MULTIPLICATIVE,  1;
    TokenKind::TAG_DIV,            FloorDiv,  bp::MULTIPLICATIVE,  1;
}

/// Map a compound assignment token tag to its corresponding `BinaryOp`.
///
/// Extracted as a free function (rather than a `Parser` method) so it can be
/// tested directly without constructing a parser. `compound_assign_op()`
/// delegates to this.
///
/// Note: `>>=` is NOT handled here because it's synthesized from three adjacent
/// `>` `>` `=` tokens — not a single lexer token. It's handled separately
/// via `is_shift_right_assign()` in `parse_expr_inner`.
#[inline]
fn compound_op_for_tag(tag: u8) -> Option<BinaryOp> {
    match tag {
        TokenKind::TAG_PLUS_EQ => Some(BinaryOp::Add),
        TokenKind::TAG_MINUS_EQ => Some(BinaryOp::Sub),
        TokenKind::TAG_STAR_EQ => Some(BinaryOp::Mul),
        TokenKind::TAG_SLASH_EQ => Some(BinaryOp::Div),
        TokenKind::TAG_PERCENT_EQ => Some(BinaryOp::Mod),
        TokenKind::TAG_AT_EQ => Some(BinaryOp::MatMul),
        TokenKind::TAG_AMP_EQ => Some(BinaryOp::BitAnd),
        TokenKind::TAG_PIPE_EQ => Some(BinaryOp::BitOr),
        TokenKind::TAG_CARET_EQ => Some(BinaryOp::BitXor),
        TokenKind::TAG_SHL_EQ => Some(BinaryOp::Shl),
        TokenKind::TAG_AMPAMP_EQ => Some(BinaryOp::And),
        TokenKind::TAG_PIPEPIPE_EQ => Some(BinaryOp::Or),
        _ => None,
    }
}

impl Parser<'_> {
    /// Get the infix binding power for the current token.
    ///
    /// Uses a static lookup table indexed by the token's discriminant tag
    /// for O(1) dispatch — a single memory read instead of a 20-arm match.
    ///
    /// Returns `(left_bp, right_bp, op, token_count)` or `None` if the
    /// current token is not a binary operator.
    #[inline]
    pub(crate) fn infix_binding_power(&self) -> Option<(u8, u8, BinaryOp, usize)> {
        let tag = self.cursor.current_tag();

        // Fast path: tags >= 128 are never operators (we only have 116 token kinds)
        if tag >= 128 {
            return None;
        }

        // In check expressions, `|` is a message separator, not bitwise OR.
        if tag == TokenKind::TAG_PIPE && self.context.has(ParseContext::PIPE_IS_SEPARATOR) {
            return None;
        }

        let info = OPER_TABLE[tag as usize];
        if info.left_bp == 0 {
            return None;
        }

        // Special case: Gt may be compound >= or >> or >>=
        if tag == TokenKind::TAG_GT {
            // Check >>= first: if we greedily match >> here, parse_expr_inner
            // can't see >>=. Returning None defers to the compound assignment path.
            if self.cursor.is_shift_right_assign() {
                return None;
            }
            if self.cursor.is_greater_equal() {
                return Some((bp::COMPARISON.0, bp::COMPARISON.1, BinaryOp::GtEq, 2));
            }
            if self.cursor.is_shift_right() {
                return Some((bp::SHIFT.0, bp::SHIFT.1, BinaryOp::Shr, 2));
            }
        }

        Some((
            info.left_bp,
            info.right_bp,
            op_from_u8(info.op),
            info.token_count as usize,
        ))
    }

    /// Map a compound assignment token tag to its corresponding `BinaryOp`.
    ///
    /// Returns `None` for non-compound-assignment tags. The `>>=` case is
    /// handled separately via `is_shift_right_assign()` since it's synthesized
    /// from three adjacent `>` `>` `=` tokens (not a single lexer token).
    #[inline]
    pub(crate) fn compound_assign_op(&self) -> Option<BinaryOp> {
        compound_op_for_tag(self.cursor.current_tag())
    }

    /// Match prefix unary operators (`-`, `!`, `~`).
    ///
    /// Note: `UnaryOp::Try` exists in `ori_ir` but is intentionally not produced here.
    /// Postfix `?` is parsed as `ExprKind::Try` in `apply_postfix_ops()`, not as a unary op.
    #[inline]
    pub(crate) fn match_unary_op(&self) -> Option<UnaryOp> {
        match self.cursor.current_tag() {
            TokenKind::TAG_MINUS => Some(UnaryOp::Neg),
            TokenKind::TAG_BANG => Some(UnaryOp::Not),
            TokenKind::TAG_TILDE => Some(UnaryOp::BitNot),
            _ => None,
        }
    }

    /// Match `function_exp` keywords.
    pub(crate) fn match_function_exp_kind(&self) -> Option<FunctionExpKind> {
        let tag = self.cursor.current_tag();

        // `with` has special capability provision syntax: with Ident = ...
        if tag == TokenKind::TAG_WITH {
            if self.cursor.is_with_capability_syntax() {
                return None;
            }
            if self.cursor.next_is_lparen() {
                return Some(FunctionExpKind::With);
            }
            return None;
        }

        // All pattern/function keywords are context-sensitive:
        // only treated as keywords when followed by `(`
        if !self.cursor.next_is_lparen() {
            return None;
        }

        match tag {
            TokenKind::TAG_RECURSE => Some(FunctionExpKind::Recurse),
            TokenKind::TAG_PARALLEL => Some(FunctionExpKind::Parallel),
            TokenKind::TAG_SPAWN => Some(FunctionExpKind::Spawn),
            TokenKind::TAG_TIMEOUT => Some(FunctionExpKind::Timeout),
            TokenKind::TAG_CACHE => Some(FunctionExpKind::Cache),
            TokenKind::TAG_WITH => Some(FunctionExpKind::With),
            TokenKind::TAG_PRINT => Some(FunctionExpKind::Print),
            TokenKind::TAG_PANIC => Some(FunctionExpKind::Panic),
            TokenKind::TAG_CATCH => Some(FunctionExpKind::Catch),
            TokenKind::TAG_TODO => Some(FunctionExpKind::Todo),
            TokenKind::TAG_UNREACHABLE => Some(FunctionExpKind::Unreachable),
            _ => None,
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    /// Number of `BinaryOp` variants that are NOT in the table because they
    /// are handled as special cases in `infix_binding_power`:
    /// - `Range`, `RangeInclusive`: non-associative, parsed in the Pratt loop
    /// - `GtEq`, `Shr`: compound tokens synthesized from `>` + `=`/`>`
    /// - `MatMul`: not yet wired as infix `@` (only reachable via `@=` desugaring)
    const SPECIAL_CASE_COUNT: usize = 5;

    /// Count all `BinaryOp` variants via exhaustive match (compiler-enforced).
    ///
    /// If a variant is added to `BinaryOp`, this match will fail to compile,
    /// forcing the developer to update this count and the operator table.
    #[expect(
        clippy::no_effect_underscore_binding,
        reason = "closure exists purely for exhaustive match enforcement"
    )]
    fn binary_op_variant_count() -> usize {
        let _exhaustive_check = |op: BinaryOp| match op {
            BinaryOp::Add
            | BinaryOp::Sub
            | BinaryOp::Mul
            | BinaryOp::Div
            | BinaryOp::Mod
            | BinaryOp::FloorDiv
            | BinaryOp::MatMul
            | BinaryOp::Eq
            | BinaryOp::NotEq
            | BinaryOp::Lt
            | BinaryOp::LtEq
            | BinaryOp::Gt
            | BinaryOp::GtEq
            | BinaryOp::And
            | BinaryOp::Or
            | BinaryOp::BitAnd
            | BinaryOp::BitOr
            | BinaryOp::BitXor
            | BinaryOp::Shl
            | BinaryOp::Shr
            | BinaryOp::Range
            | BinaryOp::RangeInclusive
            | BinaryOp::Coalesce => {}
        };
        23
    }

    #[test]
    fn table_covers_all_non_special_operators() {
        let total = binary_op_variant_count();
        assert_eq!(
            TABLE_OPERATOR_COUNT + SPECIAL_CASE_COUNT,
            total,
            "define_operators! entries ({TABLE_OPERATOR_COUNT}) + special cases \
             ({SPECIAL_CASE_COUNT}) must equal BinaryOp variant count ({total})",
        );
    }

    #[test]
    fn no_duplicate_tags_in_table() {
        let mut seen = [false; 128];
        for (i, info) in OPER_TABLE.iter().enumerate() {
            if info.left_bp != 0 {
                assert!(!seen[i], "duplicate tag index {i} in OPER_TABLE");
                seen[i] = true;
            }
        }
    }

    #[test]
    fn op_from_u8_roundtrips_all_table_entries() {
        for info in &OPER_TABLE {
            if info.left_bp != 0 {
                // Verify that every op index in the table resolves to a valid BinaryOp
                let _ = op_from_u8(info.op);
            }
        }
    }

    /// Verify that every tag in the compound assignment range (128..=139)
    /// maps to a `BinaryOp` via `compound_op_for_tag()`.
    ///
    /// If a new compound assignment operator is added to `TokenTag` (e.g.,
    /// tag 140), the range size will exceed `EXPECTED_COUNT`, forcing the
    /// developer to update both `compound_op_for_tag()` and this test.
    #[test]
    fn compound_assign_covers_all_tags() {
        const EXPECTED_COUNT: u8 = 12;
        let range_size = TokenKind::TAG_PIPEPIPE_EQ - TokenKind::TAG_PLUS_EQ + 1;
        assert_eq!(
            range_size, EXPECTED_COUNT,
            "compound assignment tag range changed (was {EXPECTED_COUNT}, now {range_size}) \
             — update compound_op_for_tag() and this constant",
        );

        for tag in TokenKind::TAG_PLUS_EQ..=TokenKind::TAG_PIPEPIPE_EQ {
            assert!(
                compound_op_for_tag(tag).is_some(),
                "compound assignment tag {tag} has no BinaryOp mapping in compound_op_for_tag()",
            );
        }
    }
}
