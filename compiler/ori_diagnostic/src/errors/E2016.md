# E2016: Missing Type Argument

A generic type or function was used without providing a required type argument
that has no default.

## Example

```ori
type Pair<A, B> = { first: A, second: B }

// Error: Pair requires 2 type arguments, but only 1 was provided
let p: Pair<int> = { first: 1, second: "hello" }
```

## Explanation

Generic types and functions declare type parameters that must be supplied by the
caller. When a parameter has no default type, the argument must be provided
explicitly. The compiler cannot infer the missing type from context alone in type
annotations.

## Common Causes

1. **Forgetting a type argument:**
   ```ori
   type Result<T, E> = Ok(T) | Err(E)

   // Wrong â€” missing error type E
   let r: Result<int> = Ok(42)

   // Right
   let r: Result<int, str> = Ok(42)
   ```

2. **Confusing defaulted and required parameters:**
   ```ori
   // Add<Rhs = Self> has a default for Rhs, so this is OK
   impl Add for Point { ... }

   // Map<K, V> has no defaults, so both are required
   let m: Map<str, int> = {}
   ```

## Solutions

1. **Provide all required type arguments:**
   ```ori
   let p: Pair<int, str> = { first: 1, second: "hello" }
   ```

2. **Let inference fill in types where possible:**
   ```ori
   // In expressions, type arguments can often be inferred
   let p = Pair { first: 1, second: "hello" }
   // Compiler infers Pair<int, str>
   ```

## See Also

- E2015: Type parameter ordering violation
- E2017: Too many type arguments
- E2018: Missing associated type
