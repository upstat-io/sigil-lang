# E2018: Missing Associated Type

An impl block for a trait is missing a required associated type definition.

## Example

```ori
trait Container {
    type Item              // Required associated type (no default)
    @get (self) -> Self.Item
}

impl Container for Box {   // Error: missing associated type `Item`
    @get (self) -> int = self.value
}
```

## Explanation

When a trait declares an associated type without a default value, every impl of
that trait must define a concrete type for it. The compiler cannot infer what
type should be used.

## Common Causes

1. **Forgetting to define the associated type:**
   ```ori
   trait Iterator {
       type Item
       @next (self) -> Option<Self.Item>
   }

   // Wrong - missing type Item
   impl Iterator for Counter {
       @next (self) -> Option<int> = ...
   }

   // Right
   impl Iterator for Counter {
       type Item = int
       @next (self) -> Option<int> = ...
   }
   ```

2. **Expecting a default that doesn't exist:**
   ```ori
   // Trait has no default for Item
   trait Collection {
       type Item
   }

   // Wrong - assuming Item defaults to something
   impl Collection for IntList { }

   // Right - must specify Item
   impl Collection for IntList {
       type Item = int
   }
   ```

## Solutions

1. **Add the missing associated type definition:**
   ```ori
   impl Container for Box {
       type Item = int      // Add this line
       @get (self) -> int = self.value
   }
   ```

2. **Check if the trait has a default:**
   If the trait defines a default associated type (e.g., `type Output = Self`),
   you can omit it and the default will be used.
   ```ori
   trait Add<Rhs = Self> {
       type Output = Self   // Has default
       @add (self, rhs: Rhs) -> Self.Output
   }

   // OK - Output defaults to Point
   impl Add for Point {
       @add (self, rhs: Point) -> Point = ...
   }
   ```

## See Also

- E2009: Missing trait bound
- E2016: Missing type argument
