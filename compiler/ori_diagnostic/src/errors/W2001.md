# W2001: Infinite Iterator Consumed Without Bound

A consuming method was called on an iterator that produces infinitely many
elements. The program will hang or run out of memory at runtime.

## Example

```ori
use std.testing { assert_eq }

@example () -> void = run(
    let xs = repeat(1).collect(),    // Warning: `collect()` on `repeat()`
    let n = (0..).count(),           // Warning: `count()` on unbounded range
    let s = repeat(0).cycle().fold(0, |acc, x| acc + x),  // Warning: `fold()` on `cycle()`
)
```

## Explanation

Some iterator methods need to consume every element before they can return:

| Method | Why it hangs |
|--------|-------------|
| `collect()` | Builds a list from all elements |
| `count()` | Counts all elements |
| `fold(init, f)` | Applies `f` to every element |
| `for_each(f)` | Calls `f` on every element |
| `to_list()` | Alias for `collect()` |

When the source iterator is infinite — `repeat(x)`, an unbounded range like
`0..`, or any chain ending in `.cycle()` — these methods will never terminate.

Adapter methods like `.map()`, `.filter()`, `.skip()`, `.enumerate()`, `.zip()`,
`.chain()`, `.flatten()`, and `.flat_map()` are transparent: they don't bound
the iterator, so the warning propagates through them.

## Solution

Add `.take(n)` before the consuming method to bound the iteration:

```ori
use std.testing { assert_eq }

@bounded () -> [int] = repeat(1).take(5).collect()

tests {
    assert_eq(bounded(), [1, 1, 1, 1, 1])
}
```

## See Also

- E2001: Type mismatch
- E2004: Argument count mismatch
