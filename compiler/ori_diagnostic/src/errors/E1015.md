# E1015: Unsupported Keyword

A keyword from other languages was used that is not valid in Ori.

## Example

```ori
@calculate (x: int) -> int = run(
    if x < 0 then return 0,    // Error: `return` is not valid in Ori
    x * 2,
)
```

## Explanation

Ori is an **expression-based language**. Every construct evaluates to a value,
and the last expression in a block becomes its result. There is no `return`
statement because it's unnecessary.

```ori
// In Ori, the last expression IS the result
@add (a: int, b: int) -> int = a + b

// Multi-expression functions use run()
@process (x: int) -> int = run(
    let doubled = x * 2,
    let adjusted = doubled + 1,
    adjusted,  // This is the result
)
```

## Solutions

### For simple returns

Just make the value the last expression:

```ori
// Wrong (from other languages)
@abs (x: int) -> int = if x < 0 then return -x else return x

// Right (Ori way)
@abs (x: int) -> int = if x < 0 then -x else x
```

### For early error exit

Use the `?` operator to propagate errors:

```ori
// Wrong
@load (path: str) -> Result<Data, Error> = run(
    let content = read_file(path),
    if content.is_err() then return content,
    parse(content.unwrap()),
)

// Right
@load (path: str) -> Result<Data, Error> = run(
    let content = read_file(path)?,   // Propagates Err automatically
    Ok(parse(content)),
)
```

### For conditional logic

Use `if...then...else` as an expression:

```ori
// Wrong
@classify (x: int) -> str = run(
    if x < 0 then return "negative",
    if x == 0 then return "zero",
    return "positive",
)

// Right
@classify (x: int) -> str =
    if x < 0 then "negative"
    else if x == 0 then "zero"
    else "positive"
```

### For loop exit with value

Use `break value`:

```ori
// Wrong
@find_first (items: [int], target: int) -> Option<int> = run(
    for i in 0..len(items) do
        if items[i] == target then return Some(i),
    None,
)

// Right
@find_first (items: [int], target: int) -> Option<int> =
    loop:search(
        for i in 0..len(items) do
            if items[i] == target then break:search Some(i),
        None,
    )

// Or use stdlib
@find_first (items: [int], target: int) -> Option<int> =
    items.enumerate().find((i, x) -> x == target).map((i, _) -> i)
```

## Why Ori Doesn't Have Return

1. **Expression-based**: Every construct produces a value
2. **Cleaner code**: No need to track multiple exit points
3. **Better composition**: Expressions can be nested and combined
4. **Error handling**: `?` operator handles early exit for errors elegantly

## See Also

- E1001: Unexpected token
- [Control Flow](https://ori-lang.com/spec/control-flow) — Break, continue, and `?`
- [Expressions](https://ori-lang.com/spec/expressions) — Expression-based design
