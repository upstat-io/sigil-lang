# E2007: Closure Self-Reference

A closure attempts to capture itself, creating a reference cycle.

## Example

```ori
@main () -> void = run(
    let f = x -> f(x + 1)    // Error: closure captures itself
)
```

## Explanation

In Ori, closures capture variables by value. A closure cannot capture itself
because at the time of capture, the closure doesn't exist yet. This also prevents
reference cycles that would cause memory leaks.

## Common Causes

1. **Trying to write recursive lambdas:**
   ```ori
   // Wrong
   let factorial = n -> if n <= 1 then 1 else n * factorial(n - 1)

   // The closure 'factorial' tries to capture itself
   ```

2. **Mutual references:**
   ```ori
   // Wrong
   let f = x -> g(x)
   let g = x -> f(x)    // g captures f, but f references g
   ```

## Solutions

1. **Use `recurse` for recursion:**
   ```ori
   @factorial (n: int) -> int = recurse(
       condition: n <= 1,
       base: 1,
       step: n * self(n - 1)
   )
   ```

2. **Define a named function instead:**
   ```ori
   // Define as a proper function
   @process (x: int) -> int = if x <= 0 then x else process(x: x - 1)

   @main () -> void = run(
       let result = process(x: 10)
   )
   ```

3. **Use higher-order patterns:**
   ```ori
   // Instead of recursive lambda, use fold
   let sum = items.fold(initial: 0, op: (acc, x) -> acc + x)
   ```

## Why This Restriction?

Ori uses ARC (Automatic Reference Counting) for memory management. Self-
referencing closures would create reference cycles that ARC cannot collect,
leading to memory leaks. The `recurse` pattern provides safe recursion without
this issue.

## See Also

- E3001: Unknown pattern (for recurse)
- E2008: Cyclic type definition
