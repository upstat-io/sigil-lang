# E2021: Overlapping Implementations

Two trait implementations with equal specificity could both apply to the same type.

## Example

```ori
trait Render {
    @render (self) -> str
}

impl<T: Printable> Render for T {
    @render (self) -> str = self.to_string()
}

impl<T: Clone> Render for T {    // Error: overlaps with above
    @render (self) -> str = "cloned"
}
```

## Explanation

When multiple `impl` blocks have the same specificity level and could apply to
the same type, the compiler cannot determine which implementation to use. Ori
uses a three-tier specificity system:

1. **Concrete** (`impl Trait for Type`) — highest priority
2. **Constrained** (`impl<T: Bound> Trait for T`) — medium priority
3. **Generic** (`impl<T> Trait for T`) — lowest priority

If two impls are at the same level and could both apply, it is an overlap error.

## Solution

1. **Use different specificity levels:**
   ```ori
   // Concrete impl wins over generic
   impl<T> Render for T { ... }     // Generic fallback
   impl Render for Point { ... }     // Concrete override - no conflict
   ```

2. **Add distinguishing constraints:**
   ```ori
   impl<T: Printable> Render for T where T: Eq { ... }
   impl<T: Clone> Render for T where T: Default { ... }
   ```

## See Also

- E2010: Duplicate implementation (exact same trait+type)
- E2023: Ambiguous method call
