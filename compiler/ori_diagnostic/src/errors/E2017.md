# E2017: Too Many Type Arguments

More type arguments were provided than the generic type or function declares.

## Example

```ori
type Wrapper<T> = { value: T }

// Error: Wrapper takes 1 type argument, but 2 were provided
let w: Wrapper<int, str> = { value: 42 }
```

## Explanation

Each generic type or function declares a fixed number of type parameters. When
you supply more arguments than there are parameters, the compiler has no
parameter to bind the extra arguments to.

## Common Causes

1. **Extra type argument on a simple generic:**
   ```ori
   // Option<T> takes exactly 1 type argument
   // Wrong
   let x: Option<int, str> = Some(42)

   // Right
   let x: Option<int> = Some(42)
   ```

2. **Confusing nested generics with multiple arguments:**
   ```ori
   // Wrong — trying to parameterize both the list and its elements
   let items: [Option<int>, str] = ...

   // Right — Option<int> is the element type of the list
   let items: [Option<int>] = [Some(1), None]
   ```

3. **Forgetting that a default doesn't add an extra slot:**
   ```ori
   // Add<Rhs = Self> has 1 parameter (Rhs), not 2
   // Wrong
   impl Add<Point, int> for Point { ... }

   // Right
   impl Add<int> for Point { ... }
   ```

## Solutions

1. **Remove the extra type arguments:**
   ```ori
   let w: Wrapper<int> = { value: 42 }
   ```

2. **Check the type's declaration for the expected parameter count:**
   ```ori
   // If you need two type parameters, use a type that has two
   type Pair<A, B> = { first: A, second: B }
   let p: Pair<int, str> = { first: 1, second: "hello" }
   ```

## See Also

- E2015: Type parameter ordering violation
- E2016: Missing type argument
