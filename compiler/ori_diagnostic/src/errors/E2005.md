# E2005: Cannot Infer Type

The compiler cannot determine the type of an expression from context.

## Example

```ori
@main () -> void = run(
    let x = []    // Error: cannot infer type of empty list
)
```

## Explanation

Ori uses type inference to determine types automatically in most cases.
However, some expressions don't provide enough information for the compiler
to infer a concrete type.

## Common Cases

1. **Empty collections:**
   ```ori
   let list = []      // What type of list?
   let map = {}       // What key/value types?
   ```

2. **Ambiguous numeric literals:**
   ```ori
   let x = 0    // Usually inferred from context, but sometimes ambiguous
   ```

3. **Generic function results without context:**
   ```ori
   let result = None    // Option<what?>
   ```

## Solutions

1. **Add a type annotation:**
   ```ori
   // For variables
   let list: [int] = []
   let map: {str: int} = {}

   // For function parameters/returns
   @process (items: [str]) -> [str] = items
   ```

2. **Provide context through usage:**
   ```ori
   // The compiler can infer [int] from how it's used
   let list = []
   let list = list + [1, 2, 3]    // Now we know it's [int]
   ```

3. **Use typed constructors:**
   ```ori
   // Instead of None, use a typed Option
   let result: Option<int> = None
   ```

## See Also

- E2001: Type mismatch
