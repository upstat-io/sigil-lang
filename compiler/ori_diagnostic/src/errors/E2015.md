# E2015: Type Parameter Ordering Violation

A type parameter without a default appears after one that has a default.

## Example

```ori
// Error: T has no default but appears after Rhs which defaults to Self
trait Add<Rhs = Self, T> {
    @add (self, rhs: Rhs) -> T
}
```

## Explanation

When a generic type has default type parameters, all parameters with defaults
must come after all parameters without defaults. This is because type arguments
are positional — once a default is used, all subsequent parameters must also
have defaults, or the compiler cannot determine which arguments correspond to
which parameters.

## Common Causes

1. **Default parameter before required parameter:**
   ```ori
   // Wrong — Output has default but Input does not
   type Transform<Output = Self, Input> = ...

   // Right — required parameters first
   type Transform<Input, Output = Self> = ...
   ```

2. **Adding a new parameter after an existing default:**
   ```ori
   // Original
   trait Convert<Target = Self> { ... }

   // Wrong — adding Source after defaulted Target
   trait Convert<Target = Self, Source> { ... }

   // Right — add before the defaulted parameter
   trait Convert<Source, Target = Self> { ... }
   ```

## Solutions

1. **Reorder parameters so defaults come last:**
   ```ori
   // Before
   trait Combine<Output = Self, Input> { ... }

   // After
   trait Combine<Input, Output = Self> { ... }
   ```

2. **Add a default to the trailing parameter:**
   ```ori
   // If both can have sensible defaults
   trait Add<Rhs = Self, Output = Self> {
       @add (self, rhs: Rhs) -> Output
   }
   ```

## See Also

- E2016: Missing type argument
- E2017: Too many type arguments
