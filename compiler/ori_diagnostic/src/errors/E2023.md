# E2023: Ambiguous Method Call

A method call could resolve to implementations from multiple different traits.

## Example

```ori
trait Renderer {
    @draw (self) -> str
}

trait Painter {
    @draw (self) -> str
}

type Canvas = { name: str }

impl Renderer for Canvas {
    @draw (self) -> str = "rendering " + self.name
}

impl Painter for Canvas {
    @draw (self) -> str = "painting " + self.name
}

@example () -> str = run(
    let c = Canvas { name: "test" },
    c.draw()    // Error: ambiguous - Renderer.draw or Painter.draw?
)
```

## Explanation

When a type implements multiple traits that each define a method with the same
name, calling that method without qualification is ambiguous. The compiler
cannot determine which trait's implementation to use.

Note: Inherent methods (defined in `impl Type { ... }`) always take priority
over trait methods and never cause ambiguity.

## Solution

Use fully-qualified syntax to specify which trait's method to call:

```ori
// Not yet supported â€” will use:
// Renderer.draw(c)
// Painter.draw(c)
```

For now, rename one of the methods to avoid the conflict, or use an inherent
method that delegates to the desired trait implementation.

## See Also

- E2010: Duplicate implementation
- E2022: Conflicting default methods
